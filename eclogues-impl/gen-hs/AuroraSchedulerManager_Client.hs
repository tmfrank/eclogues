{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AuroraSchedulerManager_Client(createJob,scheduleCronJob,descheduleCronJob,startCronJob,restartShards,killTasks,addInstances,acquireLock,releaseLock,replaceCronTemplate,startJobUpdate,pauseJobUpdate,resumeJobUpdate,abortJobUpdate,pulseJobUpdate) where
import ReadOnlyScheduler_Client
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Api_Types
import AuroraSchedulerManager
seqid = R.newIORef 0
createJob (ip,op) arg_description arg_lock arg_session = do
  send_createJob op arg_description arg_lock arg_session
  recv_createJob ip
send_createJob op arg_description arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("createJob", T.M_CALL, seqn)
  write_CreateJob_args op (CreateJob_args{createJob_args_description=arg_description,createJob_args_lock=arg_lock,createJob_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_createJob ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_CreateJob_result ip
  T.readMessageEnd ip
  P.return $ createJob_result_success res
scheduleCronJob (ip,op) arg_description arg_lock arg_session = do
  send_scheduleCronJob op arg_description arg_lock arg_session
  recv_scheduleCronJob ip
send_scheduleCronJob op arg_description arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("scheduleCronJob", T.M_CALL, seqn)
  write_ScheduleCronJob_args op (ScheduleCronJob_args{scheduleCronJob_args_description=arg_description,scheduleCronJob_args_lock=arg_lock,scheduleCronJob_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_scheduleCronJob ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ScheduleCronJob_result ip
  T.readMessageEnd ip
  P.return $ scheduleCronJob_result_success res
descheduleCronJob (ip,op) arg_job arg_lock arg_session = do
  send_descheduleCronJob op arg_job arg_lock arg_session
  recv_descheduleCronJob ip
send_descheduleCronJob op arg_job arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("descheduleCronJob", T.M_CALL, seqn)
  write_DescheduleCronJob_args op (DescheduleCronJob_args{descheduleCronJob_args_job=arg_job,descheduleCronJob_args_lock=arg_lock,descheduleCronJob_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_descheduleCronJob ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_DescheduleCronJob_result ip
  T.readMessageEnd ip
  P.return $ descheduleCronJob_result_success res
startCronJob (ip,op) arg_job arg_session = do
  send_startCronJob op arg_job arg_session
  recv_startCronJob ip
send_startCronJob op arg_job arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("startCronJob", T.M_CALL, seqn)
  write_StartCronJob_args op (StartCronJob_args{startCronJob_args_job=arg_job,startCronJob_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_startCronJob ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_StartCronJob_result ip
  T.readMessageEnd ip
  P.return $ startCronJob_result_success res
restartShards (ip,op) arg_job arg_shardIds arg_lock arg_session = do
  send_restartShards op arg_job arg_shardIds arg_lock arg_session
  recv_restartShards ip
send_restartShards op arg_job arg_shardIds arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("restartShards", T.M_CALL, seqn)
  write_RestartShards_args op (RestartShards_args{restartShards_args_job=arg_job,restartShards_args_shardIds=arg_shardIds,restartShards_args_lock=arg_lock,restartShards_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_restartShards ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_RestartShards_result ip
  T.readMessageEnd ip
  P.return $ restartShards_result_success res
killTasks (ip,op) arg_query arg_lock arg_session = do
  send_killTasks op arg_query arg_lock arg_session
  recv_killTasks ip
send_killTasks op arg_query arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("killTasks", T.M_CALL, seqn)
  write_KillTasks_args op (KillTasks_args{killTasks_args_query=arg_query,killTasks_args_lock=arg_lock,killTasks_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_killTasks ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_KillTasks_result ip
  T.readMessageEnd ip
  P.return $ killTasks_result_success res
addInstances (ip,op) arg_config arg_lock arg_session = do
  send_addInstances op arg_config arg_lock arg_session
  recv_addInstances ip
send_addInstances op arg_config arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("addInstances", T.M_CALL, seqn)
  write_AddInstances_args op (AddInstances_args{addInstances_args_config=arg_config,addInstances_args_lock=arg_lock,addInstances_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_addInstances ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_AddInstances_result ip
  T.readMessageEnd ip
  P.return $ addInstances_result_success res
acquireLock (ip,op) arg_lockKey arg_session = do
  send_acquireLock op arg_lockKey arg_session
  recv_acquireLock ip
send_acquireLock op arg_lockKey arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("acquireLock", T.M_CALL, seqn)
  write_AcquireLock_args op (AcquireLock_args{acquireLock_args_lockKey=arg_lockKey,acquireLock_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_acquireLock ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_AcquireLock_result ip
  T.readMessageEnd ip
  P.return $ acquireLock_result_success res
releaseLock (ip,op) arg_lock arg_validation arg_session = do
  send_releaseLock op arg_lock arg_validation arg_session
  recv_releaseLock ip
send_releaseLock op arg_lock arg_validation arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("releaseLock", T.M_CALL, seqn)
  write_ReleaseLock_args op (ReleaseLock_args{releaseLock_args_lock=arg_lock,releaseLock_args_validation=arg_validation,releaseLock_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_releaseLock ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ReleaseLock_result ip
  T.readMessageEnd ip
  P.return $ releaseLock_result_success res
replaceCronTemplate (ip,op) arg_config arg_lock arg_session = do
  send_replaceCronTemplate op arg_config arg_lock arg_session
  recv_replaceCronTemplate ip
send_replaceCronTemplate op arg_config arg_lock arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("replaceCronTemplate", T.M_CALL, seqn)
  write_ReplaceCronTemplate_args op (ReplaceCronTemplate_args{replaceCronTemplate_args_config=arg_config,replaceCronTemplate_args_lock=arg_lock,replaceCronTemplate_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_replaceCronTemplate ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ReplaceCronTemplate_result ip
  T.readMessageEnd ip
  P.return $ replaceCronTemplate_result_success res
startJobUpdate (ip,op) arg_request arg_session = do
  send_startJobUpdate op arg_request arg_session
  recv_startJobUpdate ip
send_startJobUpdate op arg_request arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("startJobUpdate", T.M_CALL, seqn)
  write_StartJobUpdate_args op (StartJobUpdate_args{startJobUpdate_args_request=arg_request,startJobUpdate_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_startJobUpdate ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_StartJobUpdate_result ip
  T.readMessageEnd ip
  P.return $ startJobUpdate_result_success res
pauseJobUpdate (ip,op) arg_jobKey arg_session = do
  send_pauseJobUpdate op arg_jobKey arg_session
  recv_pauseJobUpdate ip
send_pauseJobUpdate op arg_jobKey arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("pauseJobUpdate", T.M_CALL, seqn)
  write_PauseJobUpdate_args op (PauseJobUpdate_args{pauseJobUpdate_args_jobKey=arg_jobKey,pauseJobUpdate_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_pauseJobUpdate ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_PauseJobUpdate_result ip
  T.readMessageEnd ip
  P.return $ pauseJobUpdate_result_success res
resumeJobUpdate (ip,op) arg_jobKey arg_session = do
  send_resumeJobUpdate op arg_jobKey arg_session
  recv_resumeJobUpdate ip
send_resumeJobUpdate op arg_jobKey arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("resumeJobUpdate", T.M_CALL, seqn)
  write_ResumeJobUpdate_args op (ResumeJobUpdate_args{resumeJobUpdate_args_jobKey=arg_jobKey,resumeJobUpdate_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_resumeJobUpdate ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ResumeJobUpdate_result ip
  T.readMessageEnd ip
  P.return $ resumeJobUpdate_result_success res
abortJobUpdate (ip,op) arg_jobKey arg_session = do
  send_abortJobUpdate op arg_jobKey arg_session
  recv_abortJobUpdate ip
send_abortJobUpdate op arg_jobKey arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("abortJobUpdate", T.M_CALL, seqn)
  write_AbortJobUpdate_args op (AbortJobUpdate_args{abortJobUpdate_args_jobKey=arg_jobKey,abortJobUpdate_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_abortJobUpdate ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_AbortJobUpdate_result ip
  T.readMessageEnd ip
  P.return $ abortJobUpdate_result_success res
pulseJobUpdate (ip,op) arg_updateId arg_session = do
  send_pulseJobUpdate op arg_updateId arg_session
  recv_pulseJobUpdate ip
send_pulseJobUpdate op arg_updateId arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("pulseJobUpdate", T.M_CALL, seqn)
  write_PulseJobUpdate_args op (PulseJobUpdate_args{pulseJobUpdate_args_updateId=arg_updateId,pulseJobUpdate_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_pulseJobUpdate ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_PulseJobUpdate_result ip
  T.readMessageEnd ip
  P.return $ pulseJobUpdate_result_success res
