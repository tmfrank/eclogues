{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Api_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Api_Types2 (ScheduleStatus, ResponseCode)

data MaintenanceMode = NONE|SCHEDULED|DRAINING|DRAINED  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MaintenanceMode where
  fromEnum t = case t of
    NONE -> 1
    SCHEDULED -> 2
    DRAINING -> 3
    DRAINED -> 4
  toEnum t = case t of
    1 -> NONE
    2 -> SCHEDULED
    3 -> DRAINING
    4 -> DRAINED
    _ -> X.throw T.ThriftException
instance H.Hashable MaintenanceMode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MaintenanceMode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data LockValidation = CHECKED|UNCHECKED  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum LockValidation where
  fromEnum t = case t of
    CHECKED -> 0
    UNCHECKED -> 1
  toEnum t = case t of
    0 -> CHECKED
    1 -> UNCHECKED
    _ -> X.throw T.ThriftException
instance H.Hashable LockValidation where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary LockValidation where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data CronCollisionPolicy = KILL_EXISTING|CANCEL_NEW|RUN_OVERLAP  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum CronCollisionPolicy where
  fromEnum t = case t of
    KILL_EXISTING -> 0
    CANCEL_NEW -> 1
    RUN_OVERLAP -> 2
  toEnum t = case t of
    0 -> KILL_EXISTING
    1 -> CANCEL_NEW
    2 -> RUN_OVERLAP
    _ -> X.throw T.ThriftException
instance H.Hashable CronCollisionPolicy where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary CronCollisionPolicy where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)

data JobUpdateStatus = ROLLING_FORWARD|ROLLING_BACK|ROLL_FORWARD_PAUSED|ROLL_BACK_PAUSED|ROLLED_FORWARD|ROLLED_BACK|ABORTED|ERROR|FAILED  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum JobUpdateStatus where
  fromEnum t = case t of
    ROLLING_FORWARD -> 0
    ROLLING_BACK -> 1
    ROLL_FORWARD_PAUSED -> 2
    ROLL_BACK_PAUSED -> 3
    ROLLED_FORWARD -> 4
    ROLLED_BACK -> 5
    ABORTED -> 6
    ERROR -> 7
    FAILED -> 8
  toEnum t = case t of
    0 -> ROLLING_FORWARD
    1 -> ROLLING_BACK
    2 -> ROLL_FORWARD_PAUSED
    3 -> ROLL_BACK_PAUSED
    4 -> ROLLED_FORWARD
    5 -> ROLLED_BACK
    6 -> ABORTED
    7 -> ERROR
    8 -> FAILED
    _ -> X.throw T.ThriftException
instance H.Hashable JobUpdateStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary JobUpdateStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data JobUpdateAction = INSTANCE_UPDATED|INSTANCE_ROLLED_BACK|INSTANCE_UPDATING|INSTANCE_ROLLING_BACK|INSTANCE_UPDATE_FAILED|INSTANCE_ROLLBACK_FAILED  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum JobUpdateAction where
  fromEnum t = case t of
    INSTANCE_UPDATED -> 1
    INSTANCE_ROLLED_BACK -> 2
    INSTANCE_UPDATING -> 3
    INSTANCE_ROLLING_BACK -> 4
    INSTANCE_UPDATE_FAILED -> 5
    INSTANCE_ROLLBACK_FAILED -> 6
  toEnum t = case t of
    1 -> INSTANCE_UPDATED
    2 -> INSTANCE_ROLLED_BACK
    3 -> INSTANCE_UPDATING
    4 -> INSTANCE_ROLLING_BACK
    5 -> INSTANCE_UPDATE_FAILED
    6 -> INSTANCE_ROLLBACK_FAILED
    _ -> X.throw T.ThriftException
instance H.Hashable JobUpdateAction where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary JobUpdateAction where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data JobUpdatePulseStatus = OK|PAUSED|FINISHED  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum JobUpdatePulseStatus where
  fromEnum t = case t of
    OK -> 1
    PAUSED -> 2
    FINISHED -> 3
  toEnum t = case t of
    1 -> OK
    2 -> PAUSED
    3 -> FINISHED
    _ -> X.throw T.ThriftException
instance H.Hashable JobUpdatePulseStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary JobUpdatePulseStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data APIVersion = APIVersion  { aPIVersion_major :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable APIVersion where
  hashWithSalt salt record = salt   `H.hashWithSalt` aPIVersion_major record  
instance QC.Arbitrary APIVersion where 
  arbitrary = M.liftM APIVersion (QC.arbitrary)
  shrink obj | obj == default_APIVersion = []
             | P.otherwise = M.catMaybes
    [ if obj == default_APIVersion{aPIVersion_major = aPIVersion_major obj} then P.Nothing else P.Just $ default_APIVersion{aPIVersion_major = aPIVersion_major obj}
    ]
from_APIVersion :: APIVersion -> T.ThriftVal
from_APIVersion record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("major",T.TI32 _v2))) $ aPIVersion_major record
  ]
write_APIVersion :: (T.Protocol p, T.Transport t) => p t -> APIVersion -> P.IO ()
write_APIVersion oprot record = T.writeVal oprot $ from_APIVersion record
encode_APIVersion :: (T.Protocol p, T.Transport t) => p t -> APIVersion -> LBS.ByteString
encode_APIVersion oprot record = T.serializeVal oprot $ from_APIVersion record
to_APIVersion :: T.ThriftVal -> APIVersion
to_APIVersion (T.TStruct fields) = APIVersion{
  aPIVersion_major = P.maybe (P.error "Missing required field: major") (\(_,_val4) -> (case _val4 of {T.TI32 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_APIVersion _ = P.error "not a struct"
read_APIVersion :: (T.Transport t, T.Protocol p) => p t -> P.IO APIVersion
read_APIVersion iprot = to_APIVersion <$> T.readVal iprot (T.T_STRUCT typemap_APIVersion)
decode_APIVersion :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> APIVersion
decode_APIVersion iprot bs = to_APIVersion $ T.deserializeVal iprot (T.T_STRUCT typemap_APIVersion) bs
typemap_APIVersion :: T.TypeMap
typemap_APIVersion = Map.fromList [(1,("major",T.T_I32))]
default_APIVersion :: APIVersion
default_APIVersion = APIVersion{
  aPIVersion_major = 0}
data Identity = Identity  { identity_role :: LT.Text
  , identity_user :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Identity where
  hashWithSalt salt record = salt   `H.hashWithSalt` identity_role record   `H.hashWithSalt` identity_user record  
instance QC.Arbitrary Identity where 
  arbitrary = M.liftM Identity (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Identity = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Identity{identity_role = identity_role obj} then P.Nothing else P.Just $ default_Identity{identity_role = identity_role obj}
    , if obj == default_Identity{identity_user = identity_user obj} then P.Nothing else P.Just $ default_Identity{identity_user = identity_user obj}
    ]
from_Identity :: Identity -> T.ThriftVal
from_Identity record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8 -> P.Just (1, ("role",T.TString $ E.encodeUtf8 _v8))) $ identity_role record
  , (\_v8 -> P.Just (2, ("user",T.TString $ E.encodeUtf8 _v8))) $ identity_user record
  ]
write_Identity :: (T.Protocol p, T.Transport t) => p t -> Identity -> P.IO ()
write_Identity oprot record = T.writeVal oprot $ from_Identity record
encode_Identity :: (T.Protocol p, T.Transport t) => p t -> Identity -> LBS.ByteString
encode_Identity oprot record = T.serializeVal oprot $ from_Identity record
to_Identity :: T.ThriftVal -> Identity
to_Identity (T.TStruct fields) = Identity{
  identity_role = P.maybe (identity_role default_Identity) (\(_,_val10) -> (case _val10 of {T.TString _val11 -> E.decodeUtf8 _val11; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  identity_user = P.maybe (identity_user default_Identity) (\(_,_val10) -> (case _val10 of {T.TString _val12 -> E.decodeUtf8 _val12; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Identity _ = P.error "not a struct"
read_Identity :: (T.Transport t, T.Protocol p) => p t -> P.IO Identity
read_Identity iprot = to_Identity <$> T.readVal iprot (T.T_STRUCT typemap_Identity)
decode_Identity :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Identity
decode_Identity iprot bs = to_Identity $ T.deserializeVal iprot (T.T_STRUCT typemap_Identity) bs
typemap_Identity :: T.TypeMap
typemap_Identity = Map.fromList [(1,("role",T.T_STRING)),(2,("user",T.T_STRING))]
default_Identity :: Identity
default_Identity = Identity{
  identity_role = "",
  identity_user = ""}
data SessionKey = SessionKey  { sessionKey_mechanism :: P.Maybe LT.Text
  , sessionKey_data :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable SessionKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` sessionKey_mechanism record   `H.hashWithSalt` sessionKey_data record  
instance QC.Arbitrary SessionKey where 
  arbitrary = M.liftM SessionKey (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SessionKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SessionKey{sessionKey_mechanism = sessionKey_mechanism obj} then P.Nothing else P.Just $ default_SessionKey{sessionKey_mechanism = sessionKey_mechanism obj}
    , if obj == default_SessionKey{sessionKey_data = sessionKey_data obj} then P.Nothing else P.Just $ default_SessionKey{sessionKey_data = sessionKey_data obj}
    ]
from_SessionKey :: SessionKey -> T.ThriftVal
from_SessionKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v15 -> (4, ("mechanism",T.TString $ E.encodeUtf8 _v15))) <$> sessionKey_mechanism record
  , (\_v15 -> (5, ("data",T.TString _v15))) <$> sessionKey_data record
  ]
write_SessionKey :: (T.Protocol p, T.Transport t) => p t -> SessionKey -> P.IO ()
write_SessionKey oprot record = T.writeVal oprot $ from_SessionKey record
encode_SessionKey :: (T.Protocol p, T.Transport t) => p t -> SessionKey -> LBS.ByteString
encode_SessionKey oprot record = T.serializeVal oprot $ from_SessionKey record
to_SessionKey :: T.ThriftVal -> SessionKey
to_SessionKey (T.TStruct fields) = SessionKey{
  sessionKey_mechanism = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val18 -> E.decodeUtf8 _val18; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sessionKey_data = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val19 -> _val19; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SessionKey _ = P.error "not a struct"
read_SessionKey :: (T.Transport t, T.Protocol p) => p t -> P.IO SessionKey
read_SessionKey iprot = to_SessionKey <$> T.readVal iprot (T.T_STRUCT typemap_SessionKey)
decode_SessionKey :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SessionKey
decode_SessionKey iprot bs = to_SessionKey $ T.deserializeVal iprot (T.T_STRUCT typemap_SessionKey) bs
typemap_SessionKey :: T.TypeMap
typemap_SessionKey = Map.fromList [(4,("mechanism",T.T_STRING)),(5,("data",T.T_STRING))]
default_SessionKey :: SessionKey
default_SessionKey = SessionKey{
  sessionKey_mechanism = P.Nothing,
  sessionKey_data = P.Nothing}
data ResourceAggregate = ResourceAggregate  { resourceAggregate_numCpus :: P.Double
  , resourceAggregate_ramMb :: I.Int64
  , resourceAggregate_diskMb :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ResourceAggregate where
  hashWithSalt salt record = salt   `H.hashWithSalt` resourceAggregate_numCpus record   `H.hashWithSalt` resourceAggregate_ramMb record   `H.hashWithSalt` resourceAggregate_diskMb record  
instance QC.Arbitrary ResourceAggregate where 
  arbitrary = M.liftM ResourceAggregate (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ResourceAggregate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResourceAggregate{resourceAggregate_numCpus = resourceAggregate_numCpus obj} then P.Nothing else P.Just $ default_ResourceAggregate{resourceAggregate_numCpus = resourceAggregate_numCpus obj}
    , if obj == default_ResourceAggregate{resourceAggregate_ramMb = resourceAggregate_ramMb obj} then P.Nothing else P.Just $ default_ResourceAggregate{resourceAggregate_ramMb = resourceAggregate_ramMb obj}
    , if obj == default_ResourceAggregate{resourceAggregate_diskMb = resourceAggregate_diskMb obj} then P.Nothing else P.Just $ default_ResourceAggregate{resourceAggregate_diskMb = resourceAggregate_diskMb obj}
    ]
from_ResourceAggregate :: ResourceAggregate -> T.ThriftVal
from_ResourceAggregate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v22 -> P.Just (1, ("numCpus",T.TDouble _v22))) $ resourceAggregate_numCpus record
  , (\_v22 -> P.Just (2, ("ramMb",T.TI64 _v22))) $ resourceAggregate_ramMb record
  , (\_v22 -> P.Just (3, ("diskMb",T.TI64 _v22))) $ resourceAggregate_diskMb record
  ]
write_ResourceAggregate :: (T.Protocol p, T.Transport t) => p t -> ResourceAggregate -> P.IO ()
write_ResourceAggregate oprot record = T.writeVal oprot $ from_ResourceAggregate record
encode_ResourceAggregate :: (T.Protocol p, T.Transport t) => p t -> ResourceAggregate -> LBS.ByteString
encode_ResourceAggregate oprot record = T.serializeVal oprot $ from_ResourceAggregate record
to_ResourceAggregate :: T.ThriftVal -> ResourceAggregate
to_ResourceAggregate (T.TStruct fields) = ResourceAggregate{
  resourceAggregate_numCpus = P.maybe (resourceAggregate_numCpus default_ResourceAggregate) (\(_,_val24) -> (case _val24 of {T.TDouble _val25 -> _val25; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  resourceAggregate_ramMb = P.maybe (resourceAggregate_ramMb default_ResourceAggregate) (\(_,_val24) -> (case _val24 of {T.TI64 _val26 -> _val26; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  resourceAggregate_diskMb = P.maybe (resourceAggregate_diskMb default_ResourceAggregate) (\(_,_val24) -> (case _val24 of {T.TI64 _val27 -> _val27; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ResourceAggregate _ = P.error "not a struct"
read_ResourceAggregate :: (T.Transport t, T.Protocol p) => p t -> P.IO ResourceAggregate
read_ResourceAggregate iprot = to_ResourceAggregate <$> T.readVal iprot (T.T_STRUCT typemap_ResourceAggregate)
decode_ResourceAggregate :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ResourceAggregate
decode_ResourceAggregate iprot bs = to_ResourceAggregate $ T.deserializeVal iprot (T.T_STRUCT typemap_ResourceAggregate) bs
typemap_ResourceAggregate :: T.TypeMap
typemap_ResourceAggregate = Map.fromList [(1,("numCpus",T.T_DOUBLE)),(2,("ramMb",T.T_I64)),(3,("diskMb",T.T_I64))]
default_ResourceAggregate :: ResourceAggregate
default_ResourceAggregate = ResourceAggregate{
  resourceAggregate_numCpus = 0,
  resourceAggregate_ramMb = 0,
  resourceAggregate_diskMb = 0}
data Attribute = Attribute  { attribute_name :: LT.Text
  , attribute_values :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Attribute where
  hashWithSalt salt record = salt   `H.hashWithSalt` attribute_name record   `H.hashWithSalt` attribute_values record  
instance QC.Arbitrary Attribute where 
  arbitrary = M.liftM Attribute (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Attribute = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Attribute{attribute_name = attribute_name obj} then P.Nothing else P.Just $ default_Attribute{attribute_name = attribute_name obj}
    , if obj == default_Attribute{attribute_values = attribute_values obj} then P.Nothing else P.Just $ default_Attribute{attribute_values = attribute_values obj}
    ]
from_Attribute :: Attribute -> T.ThriftVal
from_Attribute record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v30 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v30))) $ attribute_name record
  , (\_v30 -> P.Just (2, ("values",T.TSet T.T_STRING $ P.map (\_v32 -> T.TString $ E.encodeUtf8 _v32) $ Set.toList _v30))) $ attribute_values record
  ]
write_Attribute :: (T.Protocol p, T.Transport t) => p t -> Attribute -> P.IO ()
write_Attribute oprot record = T.writeVal oprot $ from_Attribute record
encode_Attribute :: (T.Protocol p, T.Transport t) => p t -> Attribute -> LBS.ByteString
encode_Attribute oprot record = T.serializeVal oprot $ from_Attribute record
to_Attribute :: T.ThriftVal -> Attribute
to_Attribute (T.TStruct fields) = Attribute{
  attribute_name = P.maybe (attribute_name default_Attribute) (\(_,_val34) -> (case _val34 of {T.TString _val35 -> E.decodeUtf8 _val35; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  attribute_values = P.maybe (attribute_values default_Attribute) (\(_,_val34) -> (case _val34 of {T.TSet _ _val36 -> (Set.fromList $ P.map (\_v37 -> (case _v37 of {T.TString _val38 -> E.decodeUtf8 _val38; _ -> P.error "wrong type"})) _val36); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Attribute _ = P.error "not a struct"
read_Attribute :: (T.Transport t, T.Protocol p) => p t -> P.IO Attribute
read_Attribute iprot = to_Attribute <$> T.readVal iprot (T.T_STRUCT typemap_Attribute)
decode_Attribute :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Attribute
decode_Attribute iprot bs = to_Attribute $ T.deserializeVal iprot (T.T_STRUCT typemap_Attribute) bs
typemap_Attribute :: T.TypeMap
typemap_Attribute = Map.fromList [(1,("name",T.T_STRING)),(2,("values",(T.T_SET T.T_STRING)))]
default_Attribute :: Attribute
default_Attribute = Attribute{
  attribute_name = "",
  attribute_values = Set.empty}
data HostAttributes = HostAttributes  { hostAttributes_host :: LT.Text
  , hostAttributes_attributes :: (Set.HashSet Attribute)
  , hostAttributes_mode :: P.Maybe MaintenanceMode
  , hostAttributes_slaveId :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable HostAttributes where
  hashWithSalt salt record = salt   `H.hashWithSalt` hostAttributes_host record   `H.hashWithSalt` hostAttributes_attributes record   `H.hashWithSalt` hostAttributes_mode record   `H.hashWithSalt` hostAttributes_slaveId record  
instance QC.Arbitrary HostAttributes where 
  arbitrary = M.liftM HostAttributes (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_HostAttributes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_HostAttributes{hostAttributes_host = hostAttributes_host obj} then P.Nothing else P.Just $ default_HostAttributes{hostAttributes_host = hostAttributes_host obj}
    , if obj == default_HostAttributes{hostAttributes_attributes = hostAttributes_attributes obj} then P.Nothing else P.Just $ default_HostAttributes{hostAttributes_attributes = hostAttributes_attributes obj}
    , if obj == default_HostAttributes{hostAttributes_mode = hostAttributes_mode obj} then P.Nothing else P.Just $ default_HostAttributes{hostAttributes_mode = hostAttributes_mode obj}
    , if obj == default_HostAttributes{hostAttributes_slaveId = hostAttributes_slaveId obj} then P.Nothing else P.Just $ default_HostAttributes{hostAttributes_slaveId = hostAttributes_slaveId obj}
    ]
from_HostAttributes :: HostAttributes -> T.ThriftVal
from_HostAttributes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v41 -> P.Just (1, ("host",T.TString $ E.encodeUtf8 _v41))) $ hostAttributes_host record
  , (\_v41 -> P.Just (2, ("attributes",T.TSet (T.T_STRUCT typemap_Attribute) $ P.map (\_v43 -> from_Attribute _v43) $ Set.toList _v41))) $ hostAttributes_attributes record
  , (\_v41 -> (3, ("mode",T.TI32 $ P.fromIntegral $ P.fromEnum _v41))) <$> hostAttributes_mode record
  , (\_v41 -> (4, ("slaveId",T.TString $ E.encodeUtf8 _v41))) <$> hostAttributes_slaveId record
  ]
write_HostAttributes :: (T.Protocol p, T.Transport t) => p t -> HostAttributes -> P.IO ()
write_HostAttributes oprot record = T.writeVal oprot $ from_HostAttributes record
encode_HostAttributes :: (T.Protocol p, T.Transport t) => p t -> HostAttributes -> LBS.ByteString
encode_HostAttributes oprot record = T.serializeVal oprot $ from_HostAttributes record
to_HostAttributes :: T.ThriftVal -> HostAttributes
to_HostAttributes (T.TStruct fields) = HostAttributes{
  hostAttributes_host = P.maybe (hostAttributes_host default_HostAttributes) (\(_,_val45) -> (case _val45 of {T.TString _val46 -> E.decodeUtf8 _val46; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  hostAttributes_attributes = P.maybe (hostAttributes_attributes default_HostAttributes) (\(_,_val45) -> (case _val45 of {T.TSet _ _val47 -> (Set.fromList $ P.map (\_v48 -> (case _v48 of {T.TStruct _val49 -> (to_Attribute (T.TStruct _val49)); _ -> P.error "wrong type"})) _val47); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  hostAttributes_mode = P.maybe (P.Nothing) (\(_,_val45) -> P.Just (case _val45 of {T.TI32 _val50 -> P.toEnum $ P.fromIntegral _val50; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  hostAttributes_slaveId = P.maybe (P.Nothing) (\(_,_val45) -> P.Just (case _val45 of {T.TString _val51 -> E.decodeUtf8 _val51; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_HostAttributes _ = P.error "not a struct"
read_HostAttributes :: (T.Transport t, T.Protocol p) => p t -> P.IO HostAttributes
read_HostAttributes iprot = to_HostAttributes <$> T.readVal iprot (T.T_STRUCT typemap_HostAttributes)
decode_HostAttributes :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> HostAttributes
decode_HostAttributes iprot bs = to_HostAttributes $ T.deserializeVal iprot (T.T_STRUCT typemap_HostAttributes) bs
typemap_HostAttributes :: T.TypeMap
typemap_HostAttributes = Map.fromList [(1,("host",T.T_STRING)),(2,("attributes",(T.T_SET (T.T_STRUCT typemap_Attribute)))),(3,("mode",T.T_I32)),(4,("slaveId",T.T_STRING))]
default_HostAttributes :: HostAttributes
default_HostAttributes = HostAttributes{
  hostAttributes_host = "",
  hostAttributes_attributes = Set.empty,
  hostAttributes_mode = P.Nothing,
  hostAttributes_slaveId = P.Nothing}
data ValueConstraint = ValueConstraint  { valueConstraint_negated :: P.Bool
  , valueConstraint_values :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ValueConstraint where
  hashWithSalt salt record = salt   `H.hashWithSalt` valueConstraint_negated record   `H.hashWithSalt` valueConstraint_values record  
instance QC.Arbitrary ValueConstraint where 
  arbitrary = M.liftM ValueConstraint (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ValueConstraint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ValueConstraint{valueConstraint_negated = valueConstraint_negated obj} then P.Nothing else P.Just $ default_ValueConstraint{valueConstraint_negated = valueConstraint_negated obj}
    , if obj == default_ValueConstraint{valueConstraint_values = valueConstraint_values obj} then P.Nothing else P.Just $ default_ValueConstraint{valueConstraint_values = valueConstraint_values obj}
    ]
from_ValueConstraint :: ValueConstraint -> T.ThriftVal
from_ValueConstraint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v54 -> P.Just (1, ("negated",T.TBool _v54))) $ valueConstraint_negated record
  , (\_v54 -> P.Just (2, ("values",T.TSet T.T_STRING $ P.map (\_v56 -> T.TString $ E.encodeUtf8 _v56) $ Set.toList _v54))) $ valueConstraint_values record
  ]
write_ValueConstraint :: (T.Protocol p, T.Transport t) => p t -> ValueConstraint -> P.IO ()
write_ValueConstraint oprot record = T.writeVal oprot $ from_ValueConstraint record
encode_ValueConstraint :: (T.Protocol p, T.Transport t) => p t -> ValueConstraint -> LBS.ByteString
encode_ValueConstraint oprot record = T.serializeVal oprot $ from_ValueConstraint record
to_ValueConstraint :: T.ThriftVal -> ValueConstraint
to_ValueConstraint (T.TStruct fields) = ValueConstraint{
  valueConstraint_negated = P.maybe (valueConstraint_negated default_ValueConstraint) (\(_,_val58) -> (case _val58 of {T.TBool _val59 -> _val59; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  valueConstraint_values = P.maybe (valueConstraint_values default_ValueConstraint) (\(_,_val58) -> (case _val58 of {T.TSet _ _val60 -> (Set.fromList $ P.map (\_v61 -> (case _v61 of {T.TString _val62 -> E.decodeUtf8 _val62; _ -> P.error "wrong type"})) _val60); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ValueConstraint _ = P.error "not a struct"
read_ValueConstraint :: (T.Transport t, T.Protocol p) => p t -> P.IO ValueConstraint
read_ValueConstraint iprot = to_ValueConstraint <$> T.readVal iprot (T.T_STRUCT typemap_ValueConstraint)
decode_ValueConstraint :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ValueConstraint
decode_ValueConstraint iprot bs = to_ValueConstraint $ T.deserializeVal iprot (T.T_STRUCT typemap_ValueConstraint) bs
typemap_ValueConstraint :: T.TypeMap
typemap_ValueConstraint = Map.fromList [(1,("negated",T.T_BOOL)),(2,("values",(T.T_SET T.T_STRING)))]
default_ValueConstraint :: ValueConstraint
default_ValueConstraint = ValueConstraint{
  valueConstraint_negated = P.False,
  valueConstraint_values = Set.empty}
data LimitConstraint = LimitConstraint  { limitConstraint_limit :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable LimitConstraint where
  hashWithSalt salt record = salt   `H.hashWithSalt` limitConstraint_limit record  
instance QC.Arbitrary LimitConstraint where 
  arbitrary = M.liftM LimitConstraint (QC.arbitrary)
  shrink obj | obj == default_LimitConstraint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LimitConstraint{limitConstraint_limit = limitConstraint_limit obj} then P.Nothing else P.Just $ default_LimitConstraint{limitConstraint_limit = limitConstraint_limit obj}
    ]
from_LimitConstraint :: LimitConstraint -> T.ThriftVal
from_LimitConstraint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v65 -> P.Just (1, ("limit",T.TI32 _v65))) $ limitConstraint_limit record
  ]
write_LimitConstraint :: (T.Protocol p, T.Transport t) => p t -> LimitConstraint -> P.IO ()
write_LimitConstraint oprot record = T.writeVal oprot $ from_LimitConstraint record
encode_LimitConstraint :: (T.Protocol p, T.Transport t) => p t -> LimitConstraint -> LBS.ByteString
encode_LimitConstraint oprot record = T.serializeVal oprot $ from_LimitConstraint record
to_LimitConstraint :: T.ThriftVal -> LimitConstraint
to_LimitConstraint (T.TStruct fields) = LimitConstraint{
  limitConstraint_limit = P.maybe (limitConstraint_limit default_LimitConstraint) (\(_,_val67) -> (case _val67 of {T.TI32 _val68 -> _val68; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LimitConstraint _ = P.error "not a struct"
read_LimitConstraint :: (T.Transport t, T.Protocol p) => p t -> P.IO LimitConstraint
read_LimitConstraint iprot = to_LimitConstraint <$> T.readVal iprot (T.T_STRUCT typemap_LimitConstraint)
decode_LimitConstraint :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> LimitConstraint
decode_LimitConstraint iprot bs = to_LimitConstraint $ T.deserializeVal iprot (T.T_STRUCT typemap_LimitConstraint) bs
typemap_LimitConstraint :: T.TypeMap
typemap_LimitConstraint = Map.fromList [(1,("limit",T.T_I32))]
default_LimitConstraint :: LimitConstraint
default_LimitConstraint = LimitConstraint{
  limitConstraint_limit = 0}
data TaskConstraint = TaskConstraint  { taskConstraint_value :: ValueConstraint
  , taskConstraint_limit :: LimitConstraint
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable TaskConstraint where
  hashWithSalt salt record = salt   `H.hashWithSalt` taskConstraint_value record   `H.hashWithSalt` taskConstraint_limit record  
instance QC.Arbitrary TaskConstraint where 
  arbitrary = M.liftM TaskConstraint (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TaskConstraint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TaskConstraint{taskConstraint_value = taskConstraint_value obj} then P.Nothing else P.Just $ default_TaskConstraint{taskConstraint_value = taskConstraint_value obj}
    , if obj == default_TaskConstraint{taskConstraint_limit = taskConstraint_limit obj} then P.Nothing else P.Just $ default_TaskConstraint{taskConstraint_limit = taskConstraint_limit obj}
    ]
from_TaskConstraint :: TaskConstraint -> T.ThriftVal
from_TaskConstraint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v71 -> P.Just (1, ("value",from_ValueConstraint _v71))) $ taskConstraint_value record
  , (\_v71 -> P.Just (2, ("limit",from_LimitConstraint _v71))) $ taskConstraint_limit record
  ]
write_TaskConstraint :: (T.Protocol p, T.Transport t) => p t -> TaskConstraint -> P.IO ()
write_TaskConstraint oprot record = T.writeVal oprot $ from_TaskConstraint record
encode_TaskConstraint :: (T.Protocol p, T.Transport t) => p t -> TaskConstraint -> LBS.ByteString
encode_TaskConstraint oprot record = T.serializeVal oprot $ from_TaskConstraint record
to_TaskConstraint :: T.ThriftVal -> TaskConstraint
to_TaskConstraint (T.TStruct fields) = TaskConstraint{
  taskConstraint_value = P.maybe (taskConstraint_value default_TaskConstraint) (\(_,_val73) -> (case _val73 of {T.TStruct _val74 -> (to_ValueConstraint (T.TStruct _val74)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  taskConstraint_limit = P.maybe (taskConstraint_limit default_TaskConstraint) (\(_,_val73) -> (case _val73 of {T.TStruct _val75 -> (to_LimitConstraint (T.TStruct _val75)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TaskConstraint _ = P.error "not a struct"
read_TaskConstraint :: (T.Transport t, T.Protocol p) => p t -> P.IO TaskConstraint
read_TaskConstraint iprot = to_TaskConstraint <$> T.readVal iprot (T.T_STRUCT typemap_TaskConstraint)
decode_TaskConstraint :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TaskConstraint
decode_TaskConstraint iprot bs = to_TaskConstraint $ T.deserializeVal iprot (T.T_STRUCT typemap_TaskConstraint) bs
typemap_TaskConstraint :: T.TypeMap
typemap_TaskConstraint = Map.fromList [(1,("value",(T.T_STRUCT typemap_ValueConstraint))),(2,("limit",(T.T_STRUCT typemap_LimitConstraint)))]
default_TaskConstraint :: TaskConstraint
default_TaskConstraint = TaskConstraint{
  taskConstraint_value = default_ValueConstraint,
  taskConstraint_limit = default_LimitConstraint}
data Constraint = Constraint  { constraint_name :: LT.Text
  , constraint_constraint :: TaskConstraint
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Constraint where
  hashWithSalt salt record = salt   `H.hashWithSalt` constraint_name record   `H.hashWithSalt` constraint_constraint record  
instance QC.Arbitrary Constraint where 
  arbitrary = M.liftM Constraint (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Constraint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Constraint{constraint_name = constraint_name obj} then P.Nothing else P.Just $ default_Constraint{constraint_name = constraint_name obj}
    , if obj == default_Constraint{constraint_constraint = constraint_constraint obj} then P.Nothing else P.Just $ default_Constraint{constraint_constraint = constraint_constraint obj}
    ]
from_Constraint :: Constraint -> T.ThriftVal
from_Constraint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v78 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v78))) $ constraint_name record
  , (\_v78 -> P.Just (2, ("constraint",from_TaskConstraint _v78))) $ constraint_constraint record
  ]
write_Constraint :: (T.Protocol p, T.Transport t) => p t -> Constraint -> P.IO ()
write_Constraint oprot record = T.writeVal oprot $ from_Constraint record
encode_Constraint :: (T.Protocol p, T.Transport t) => p t -> Constraint -> LBS.ByteString
encode_Constraint oprot record = T.serializeVal oprot $ from_Constraint record
to_Constraint :: T.ThriftVal -> Constraint
to_Constraint (T.TStruct fields) = Constraint{
  constraint_name = P.maybe (constraint_name default_Constraint) (\(_,_val80) -> (case _val80 of {T.TString _val81 -> E.decodeUtf8 _val81; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  constraint_constraint = P.maybe (constraint_constraint default_Constraint) (\(_,_val80) -> (case _val80 of {T.TStruct _val82 -> (to_TaskConstraint (T.TStruct _val82)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Constraint _ = P.error "not a struct"
read_Constraint :: (T.Transport t, T.Protocol p) => p t -> P.IO Constraint
read_Constraint iprot = to_Constraint <$> T.readVal iprot (T.T_STRUCT typemap_Constraint)
decode_Constraint :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Constraint
decode_Constraint iprot bs = to_Constraint $ T.deserializeVal iprot (T.T_STRUCT typemap_Constraint) bs
typemap_Constraint :: T.TypeMap
typemap_Constraint = Map.fromList [(1,("name",T.T_STRING)),(2,("constraint",(T.T_STRUCT typemap_TaskConstraint)))]
default_Constraint :: Constraint
default_Constraint = Constraint{
  constraint_name = "",
  constraint_constraint = default_TaskConstraint}
data Package = Package  { package_role :: LT.Text
  , package_name :: LT.Text
  , package_version :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Package where
  hashWithSalt salt record = salt   `H.hashWithSalt` package_role record   `H.hashWithSalt` package_name record   `H.hashWithSalt` package_version record  
instance QC.Arbitrary Package where 
  arbitrary = M.liftM Package (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Package = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Package{package_role = package_role obj} then P.Nothing else P.Just $ default_Package{package_role = package_role obj}
    , if obj == default_Package{package_name = package_name obj} then P.Nothing else P.Just $ default_Package{package_name = package_name obj}
    , if obj == default_Package{package_version = package_version obj} then P.Nothing else P.Just $ default_Package{package_version = package_version obj}
    ]
from_Package :: Package -> T.ThriftVal
from_Package record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v85 -> P.Just (1, ("role",T.TString $ E.encodeUtf8 _v85))) $ package_role record
  , (\_v85 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v85))) $ package_name record
  , (\_v85 -> P.Just (3, ("version",T.TI32 _v85))) $ package_version record
  ]
write_Package :: (T.Protocol p, T.Transport t) => p t -> Package -> P.IO ()
write_Package oprot record = T.writeVal oprot $ from_Package record
encode_Package :: (T.Protocol p, T.Transport t) => p t -> Package -> LBS.ByteString
encode_Package oprot record = T.serializeVal oprot $ from_Package record
to_Package :: T.ThriftVal -> Package
to_Package (T.TStruct fields) = Package{
  package_role = P.maybe (package_role default_Package) (\(_,_val87) -> (case _val87 of {T.TString _val88 -> E.decodeUtf8 _val88; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  package_name = P.maybe (package_name default_Package) (\(_,_val87) -> (case _val87 of {T.TString _val89 -> E.decodeUtf8 _val89; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  package_version = P.maybe (package_version default_Package) (\(_,_val87) -> (case _val87 of {T.TI32 _val90 -> _val90; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Package _ = P.error "not a struct"
read_Package :: (T.Transport t, T.Protocol p) => p t -> P.IO Package
read_Package iprot = to_Package <$> T.readVal iprot (T.T_STRUCT typemap_Package)
decode_Package :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Package
decode_Package iprot bs = to_Package $ T.deserializeVal iprot (T.T_STRUCT typemap_Package) bs
typemap_Package :: T.TypeMap
typemap_Package = Map.fromList [(1,("role",T.T_STRING)),(2,("name",T.T_STRING)),(3,("version",T.T_I32))]
default_Package :: Package
default_Package = Package{
  package_role = "",
  package_name = "",
  package_version = 0}
data Metadata = Metadata  { metadata_key :: LT.Text
  , metadata_value :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Metadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` metadata_key record   `H.hashWithSalt` metadata_value record  
instance QC.Arbitrary Metadata where 
  arbitrary = M.liftM Metadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Metadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Metadata{metadata_key = metadata_key obj} then P.Nothing else P.Just $ default_Metadata{metadata_key = metadata_key obj}
    , if obj == default_Metadata{metadata_value = metadata_value obj} then P.Nothing else P.Just $ default_Metadata{metadata_value = metadata_value obj}
    ]
from_Metadata :: Metadata -> T.ThriftVal
from_Metadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v93 -> P.Just (1, ("key",T.TString $ E.encodeUtf8 _v93))) $ metadata_key record
  , (\_v93 -> P.Just (2, ("value",T.TString $ E.encodeUtf8 _v93))) $ metadata_value record
  ]
write_Metadata :: (T.Protocol p, T.Transport t) => p t -> Metadata -> P.IO ()
write_Metadata oprot record = T.writeVal oprot $ from_Metadata record
encode_Metadata :: (T.Protocol p, T.Transport t) => p t -> Metadata -> LBS.ByteString
encode_Metadata oprot record = T.serializeVal oprot $ from_Metadata record
to_Metadata :: T.ThriftVal -> Metadata
to_Metadata (T.TStruct fields) = Metadata{
  metadata_key = P.maybe (metadata_key default_Metadata) (\(_,_val95) -> (case _val95 of {T.TString _val96 -> E.decodeUtf8 _val96; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  metadata_value = P.maybe (metadata_value default_Metadata) (\(_,_val95) -> (case _val95 of {T.TString _val97 -> E.decodeUtf8 _val97; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Metadata _ = P.error "not a struct"
read_Metadata :: (T.Transport t, T.Protocol p) => p t -> P.IO Metadata
read_Metadata iprot = to_Metadata <$> T.readVal iprot (T.T_STRUCT typemap_Metadata)
decode_Metadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Metadata
decode_Metadata iprot bs = to_Metadata $ T.deserializeVal iprot (T.T_STRUCT typemap_Metadata) bs
typemap_Metadata :: T.TypeMap
typemap_Metadata = Map.fromList [(1,("key",T.T_STRING)),(2,("value",T.T_STRING))]
default_Metadata :: Metadata
default_Metadata = Metadata{
  metadata_key = "",
  metadata_value = ""}
data JobKey = JobKey  { jobKey_role :: LT.Text
  , jobKey_environment :: LT.Text
  , jobKey_name :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobKey_role record   `H.hashWithSalt` jobKey_environment record   `H.hashWithSalt` jobKey_name record  
instance QC.Arbitrary JobKey where 
  arbitrary = M.liftM JobKey (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobKey{jobKey_role = jobKey_role obj} then P.Nothing else P.Just $ default_JobKey{jobKey_role = jobKey_role obj}
    , if obj == default_JobKey{jobKey_environment = jobKey_environment obj} then P.Nothing else P.Just $ default_JobKey{jobKey_environment = jobKey_environment obj}
    , if obj == default_JobKey{jobKey_name = jobKey_name obj} then P.Nothing else P.Just $ default_JobKey{jobKey_name = jobKey_name obj}
    ]
from_JobKey :: JobKey -> T.ThriftVal
from_JobKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v100 -> P.Just (1, ("role",T.TString $ E.encodeUtf8 _v100))) $ jobKey_role record
  , (\_v100 -> P.Just (2, ("environment",T.TString $ E.encodeUtf8 _v100))) $ jobKey_environment record
  , (\_v100 -> P.Just (3, ("name",T.TString $ E.encodeUtf8 _v100))) $ jobKey_name record
  ]
write_JobKey :: (T.Protocol p, T.Transport t) => p t -> JobKey -> P.IO ()
write_JobKey oprot record = T.writeVal oprot $ from_JobKey record
encode_JobKey :: (T.Protocol p, T.Transport t) => p t -> JobKey -> LBS.ByteString
encode_JobKey oprot record = T.serializeVal oprot $ from_JobKey record
to_JobKey :: T.ThriftVal -> JobKey
to_JobKey (T.TStruct fields) = JobKey{
  jobKey_role = P.maybe (jobKey_role default_JobKey) (\(_,_val102) -> (case _val102 of {T.TString _val103 -> E.decodeUtf8 _val103; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobKey_environment = P.maybe (jobKey_environment default_JobKey) (\(_,_val102) -> (case _val102 of {T.TString _val104 -> E.decodeUtf8 _val104; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobKey_name = P.maybe (jobKey_name default_JobKey) (\(_,_val102) -> (case _val102 of {T.TString _val105 -> E.decodeUtf8 _val105; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobKey _ = P.error "not a struct"
read_JobKey :: (T.Transport t, T.Protocol p) => p t -> P.IO JobKey
read_JobKey iprot = to_JobKey <$> T.readVal iprot (T.T_STRUCT typemap_JobKey)
decode_JobKey :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobKey
decode_JobKey iprot bs = to_JobKey $ T.deserializeVal iprot (T.T_STRUCT typemap_JobKey) bs
typemap_JobKey :: T.TypeMap
typemap_JobKey = Map.fromList [(1,("role",T.T_STRING)),(2,("environment",T.T_STRING)),(3,("name",T.T_STRING))]
default_JobKey :: JobKey
default_JobKey = JobKey{
  jobKey_role = "",
  jobKey_environment = "",
  jobKey_name = ""}
data LockKey = LockKey  { lockKey_job :: JobKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable LockKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` lockKey_job record  
instance QC.Arbitrary LockKey where 
  arbitrary = M.liftM LockKey (QC.arbitrary)
  shrink obj | obj == default_LockKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LockKey{lockKey_job = lockKey_job obj} then P.Nothing else P.Just $ default_LockKey{lockKey_job = lockKey_job obj}
    ]
from_LockKey :: LockKey -> T.ThriftVal
from_LockKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v108 -> P.Just (1, ("job",from_JobKey _v108))) $ lockKey_job record
  ]
write_LockKey :: (T.Protocol p, T.Transport t) => p t -> LockKey -> P.IO ()
write_LockKey oprot record = T.writeVal oprot $ from_LockKey record
encode_LockKey :: (T.Protocol p, T.Transport t) => p t -> LockKey -> LBS.ByteString
encode_LockKey oprot record = T.serializeVal oprot $ from_LockKey record
to_LockKey :: T.ThriftVal -> LockKey
to_LockKey (T.TStruct fields) = LockKey{
  lockKey_job = P.maybe (lockKey_job default_LockKey) (\(_,_val110) -> (case _val110 of {T.TStruct _val111 -> (to_JobKey (T.TStruct _val111)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LockKey _ = P.error "not a struct"
read_LockKey :: (T.Transport t, T.Protocol p) => p t -> P.IO LockKey
read_LockKey iprot = to_LockKey <$> T.readVal iprot (T.T_STRUCT typemap_LockKey)
decode_LockKey :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> LockKey
decode_LockKey iprot bs = to_LockKey $ T.deserializeVal iprot (T.T_STRUCT typemap_LockKey) bs
typemap_LockKey :: T.TypeMap
typemap_LockKey = Map.fromList [(1,("job",(T.T_STRUCT typemap_JobKey)))]
default_LockKey :: LockKey
default_LockKey = LockKey{
  lockKey_job = default_JobKey}
data Lock = Lock  { lock_key :: LockKey
  , lock_token :: LT.Text
  , lock_user :: LT.Text
  , lock_timestampMs :: I.Int64
  , lock_message :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Lock where
  hashWithSalt salt record = salt   `H.hashWithSalt` lock_key record   `H.hashWithSalt` lock_token record   `H.hashWithSalt` lock_user record   `H.hashWithSalt` lock_timestampMs record   `H.hashWithSalt` lock_message record  
instance QC.Arbitrary Lock where 
  arbitrary = M.liftM Lock (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Lock = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Lock{lock_key = lock_key obj} then P.Nothing else P.Just $ default_Lock{lock_key = lock_key obj}
    , if obj == default_Lock{lock_token = lock_token obj} then P.Nothing else P.Just $ default_Lock{lock_token = lock_token obj}
    , if obj == default_Lock{lock_user = lock_user obj} then P.Nothing else P.Just $ default_Lock{lock_user = lock_user obj}
    , if obj == default_Lock{lock_timestampMs = lock_timestampMs obj} then P.Nothing else P.Just $ default_Lock{lock_timestampMs = lock_timestampMs obj}
    , if obj == default_Lock{lock_message = lock_message obj} then P.Nothing else P.Just $ default_Lock{lock_message = lock_message obj}
    ]
from_Lock :: Lock -> T.ThriftVal
from_Lock record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v114 -> P.Just (1, ("key",from_LockKey _v114))) $ lock_key record
  , (\_v114 -> P.Just (2, ("token",T.TString $ E.encodeUtf8 _v114))) $ lock_token record
  , (\_v114 -> P.Just (3, ("user",T.TString $ E.encodeUtf8 _v114))) $ lock_user record
  , (\_v114 -> P.Just (4, ("timestampMs",T.TI64 _v114))) $ lock_timestampMs record
  , (\_v114 -> (5, ("message",T.TString $ E.encodeUtf8 _v114))) <$> lock_message record
  ]
write_Lock :: (T.Protocol p, T.Transport t) => p t -> Lock -> P.IO ()
write_Lock oprot record = T.writeVal oprot $ from_Lock record
encode_Lock :: (T.Protocol p, T.Transport t) => p t -> Lock -> LBS.ByteString
encode_Lock oprot record = T.serializeVal oprot $ from_Lock record
to_Lock :: T.ThriftVal -> Lock
to_Lock (T.TStruct fields) = Lock{
  lock_key = P.maybe (lock_key default_Lock) (\(_,_val116) -> (case _val116 of {T.TStruct _val117 -> (to_LockKey (T.TStruct _val117)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lock_token = P.maybe (lock_token default_Lock) (\(_,_val116) -> (case _val116 of {T.TString _val118 -> E.decodeUtf8 _val118; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  lock_user = P.maybe (lock_user default_Lock) (\(_,_val116) -> (case _val116 of {T.TString _val119 -> E.decodeUtf8 _val119; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  lock_timestampMs = P.maybe (lock_timestampMs default_Lock) (\(_,_val116) -> (case _val116 of {T.TI64 _val120 -> _val120; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  lock_message = P.maybe (P.Nothing) (\(_,_val116) -> P.Just (case _val116 of {T.TString _val121 -> E.decodeUtf8 _val121; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Lock _ = P.error "not a struct"
read_Lock :: (T.Transport t, T.Protocol p) => p t -> P.IO Lock
read_Lock iprot = to_Lock <$> T.readVal iprot (T.T_STRUCT typemap_Lock)
decode_Lock :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Lock
decode_Lock iprot bs = to_Lock $ T.deserializeVal iprot (T.T_STRUCT typemap_Lock) bs
typemap_Lock :: T.TypeMap
typemap_Lock = Map.fromList [(1,("key",(T.T_STRUCT typemap_LockKey))),(2,("token",T.T_STRING)),(3,("user",T.T_STRING)),(4,("timestampMs",T.T_I64)),(5,("message",T.T_STRING))]
default_Lock :: Lock
default_Lock = Lock{
  lock_key = default_LockKey,
  lock_token = "",
  lock_user = "",
  lock_timestampMs = 0,
  lock_message = P.Nothing}
data InstanceKey = InstanceKey  { instanceKey_jobKey :: JobKey
  , instanceKey_instanceId :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable InstanceKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` instanceKey_jobKey record   `H.hashWithSalt` instanceKey_instanceId record  
instance QC.Arbitrary InstanceKey where 
  arbitrary = M.liftM InstanceKey (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InstanceKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InstanceKey{instanceKey_jobKey = instanceKey_jobKey obj} then P.Nothing else P.Just $ default_InstanceKey{instanceKey_jobKey = instanceKey_jobKey obj}
    , if obj == default_InstanceKey{instanceKey_instanceId = instanceKey_instanceId obj} then P.Nothing else P.Just $ default_InstanceKey{instanceKey_instanceId = instanceKey_instanceId obj}
    ]
from_InstanceKey :: InstanceKey -> T.ThriftVal
from_InstanceKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v124 -> P.Just (1, ("jobKey",from_JobKey _v124))) $ instanceKey_jobKey record
  , (\_v124 -> P.Just (2, ("instanceId",T.TI32 _v124))) $ instanceKey_instanceId record
  ]
write_InstanceKey :: (T.Protocol p, T.Transport t) => p t -> InstanceKey -> P.IO ()
write_InstanceKey oprot record = T.writeVal oprot $ from_InstanceKey record
encode_InstanceKey :: (T.Protocol p, T.Transport t) => p t -> InstanceKey -> LBS.ByteString
encode_InstanceKey oprot record = T.serializeVal oprot $ from_InstanceKey record
to_InstanceKey :: T.ThriftVal -> InstanceKey
to_InstanceKey (T.TStruct fields) = InstanceKey{
  instanceKey_jobKey = P.maybe (instanceKey_jobKey default_InstanceKey) (\(_,_val126) -> (case _val126 of {T.TStruct _val127 -> (to_JobKey (T.TStruct _val127)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  instanceKey_instanceId = P.maybe (instanceKey_instanceId default_InstanceKey) (\(_,_val126) -> (case _val126 of {T.TI32 _val128 -> _val128; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InstanceKey _ = P.error "not a struct"
read_InstanceKey :: (T.Transport t, T.Protocol p) => p t -> P.IO InstanceKey
read_InstanceKey iprot = to_InstanceKey <$> T.readVal iprot (T.T_STRUCT typemap_InstanceKey)
decode_InstanceKey :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> InstanceKey
decode_InstanceKey iprot bs = to_InstanceKey $ T.deserializeVal iprot (T.T_STRUCT typemap_InstanceKey) bs
typemap_InstanceKey :: T.TypeMap
typemap_InstanceKey = Map.fromList [(1,("jobKey",(T.T_STRUCT typemap_JobKey))),(2,("instanceId",T.T_I32))]
default_InstanceKey :: InstanceKey
default_InstanceKey = InstanceKey{
  instanceKey_jobKey = default_JobKey,
  instanceKey_instanceId = 0}
data ExecutorConfig = ExecutorConfig  { executorConfig_name :: LT.Text
  , executorConfig_data :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ExecutorConfig where
  hashWithSalt salt record = salt   `H.hashWithSalt` executorConfig_name record   `H.hashWithSalt` executorConfig_data record  
instance QC.Arbitrary ExecutorConfig where 
  arbitrary = M.liftM ExecutorConfig (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExecutorConfig = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExecutorConfig{executorConfig_name = executorConfig_name obj} then P.Nothing else P.Just $ default_ExecutorConfig{executorConfig_name = executorConfig_name obj}
    , if obj == default_ExecutorConfig{executorConfig_data = executorConfig_data obj} then P.Nothing else P.Just $ default_ExecutorConfig{executorConfig_data = executorConfig_data obj}
    ]
from_ExecutorConfig :: ExecutorConfig -> T.ThriftVal
from_ExecutorConfig record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v131 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v131))) $ executorConfig_name record
  , (\_v131 -> P.Just (2, ("data",T.TString $ E.encodeUtf8 _v131))) $ executorConfig_data record
  ]
write_ExecutorConfig :: (T.Protocol p, T.Transport t) => p t -> ExecutorConfig -> P.IO ()
write_ExecutorConfig oprot record = T.writeVal oprot $ from_ExecutorConfig record
encode_ExecutorConfig :: (T.Protocol p, T.Transport t) => p t -> ExecutorConfig -> LBS.ByteString
encode_ExecutorConfig oprot record = T.serializeVal oprot $ from_ExecutorConfig record
to_ExecutorConfig :: T.ThriftVal -> ExecutorConfig
to_ExecutorConfig (T.TStruct fields) = ExecutorConfig{
  executorConfig_name = P.maybe (executorConfig_name default_ExecutorConfig) (\(_,_val133) -> (case _val133 of {T.TString _val134 -> E.decodeUtf8 _val134; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  executorConfig_data = P.maybe (executorConfig_data default_ExecutorConfig) (\(_,_val133) -> (case _val133 of {T.TString _val135 -> E.decodeUtf8 _val135; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ExecutorConfig _ = P.error "not a struct"
read_ExecutorConfig :: (T.Transport t, T.Protocol p) => p t -> P.IO ExecutorConfig
read_ExecutorConfig iprot = to_ExecutorConfig <$> T.readVal iprot (T.T_STRUCT typemap_ExecutorConfig)
decode_ExecutorConfig :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ExecutorConfig
decode_ExecutorConfig iprot bs = to_ExecutorConfig $ T.deserializeVal iprot (T.T_STRUCT typemap_ExecutorConfig) bs
typemap_ExecutorConfig :: T.TypeMap
typemap_ExecutorConfig = Map.fromList [(1,("name",T.T_STRING)),(2,("data",T.T_STRING))]
default_ExecutorConfig :: ExecutorConfig
default_ExecutorConfig = ExecutorConfig{
  executorConfig_name = "",
  executorConfig_data = ""}
data MesosContainer = MesosContainer deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable MesosContainer where
  hashWithSalt salt record = salt  
instance QC.Arbitrary MesosContainer where 
  arbitrary = QC.elements [MesosContainer]
from_MesosContainer :: MesosContainer -> T.ThriftVal
from_MesosContainer record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_MesosContainer :: (T.Protocol p, T.Transport t) => p t -> MesosContainer -> P.IO ()
write_MesosContainer oprot record = T.writeVal oprot $ from_MesosContainer record
encode_MesosContainer :: (T.Protocol p, T.Transport t) => p t -> MesosContainer -> LBS.ByteString
encode_MesosContainer oprot record = T.serializeVal oprot $ from_MesosContainer record
to_MesosContainer :: T.ThriftVal -> MesosContainer
to_MesosContainer (T.TStruct fields) = MesosContainer{

  }
to_MesosContainer _ = P.error "not a struct"
read_MesosContainer :: (T.Transport t, T.Protocol p) => p t -> P.IO MesosContainer
read_MesosContainer iprot = to_MesosContainer <$> T.readVal iprot (T.T_STRUCT typemap_MesosContainer)
decode_MesosContainer :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> MesosContainer
decode_MesosContainer iprot bs = to_MesosContainer $ T.deserializeVal iprot (T.T_STRUCT typemap_MesosContainer) bs
typemap_MesosContainer :: T.TypeMap
typemap_MesosContainer = Map.fromList []
default_MesosContainer :: MesosContainer
default_MesosContainer = MesosContainer{
}
data DockerContainer = DockerContainer  { dockerContainer_image :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DockerContainer where
  hashWithSalt salt record = salt   `H.hashWithSalt` dockerContainer_image record  
instance QC.Arbitrary DockerContainer where 
  arbitrary = M.liftM DockerContainer (QC.arbitrary)
  shrink obj | obj == default_DockerContainer = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DockerContainer{dockerContainer_image = dockerContainer_image obj} then P.Nothing else P.Just $ default_DockerContainer{dockerContainer_image = dockerContainer_image obj}
    ]
from_DockerContainer :: DockerContainer -> T.ThriftVal
from_DockerContainer record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v143 -> P.Just (1, ("image",T.TString $ E.encodeUtf8 _v143))) $ dockerContainer_image record
  ]
write_DockerContainer :: (T.Protocol p, T.Transport t) => p t -> DockerContainer -> P.IO ()
write_DockerContainer oprot record = T.writeVal oprot $ from_DockerContainer record
encode_DockerContainer :: (T.Protocol p, T.Transport t) => p t -> DockerContainer -> LBS.ByteString
encode_DockerContainer oprot record = T.serializeVal oprot $ from_DockerContainer record
to_DockerContainer :: T.ThriftVal -> DockerContainer
to_DockerContainer (T.TStruct fields) = DockerContainer{
  dockerContainer_image = P.maybe (dockerContainer_image default_DockerContainer) (\(_,_val145) -> (case _val145 of {T.TString _val146 -> E.decodeUtf8 _val146; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DockerContainer _ = P.error "not a struct"
read_DockerContainer :: (T.Transport t, T.Protocol p) => p t -> P.IO DockerContainer
read_DockerContainer iprot = to_DockerContainer <$> T.readVal iprot (T.T_STRUCT typemap_DockerContainer)
decode_DockerContainer :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DockerContainer
decode_DockerContainer iprot bs = to_DockerContainer $ T.deserializeVal iprot (T.T_STRUCT typemap_DockerContainer) bs
typemap_DockerContainer :: T.TypeMap
typemap_DockerContainer = Map.fromList [(1,("image",T.T_STRING))]
default_DockerContainer :: DockerContainer
default_DockerContainer = DockerContainer{
  dockerContainer_image = ""}
data Container = Container  { container_mesos :: MesosContainer
  , container_docker :: DockerContainer
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Container where
  hashWithSalt salt record = salt   `H.hashWithSalt` container_mesos record   `H.hashWithSalt` container_docker record  
instance QC.Arbitrary Container where 
  arbitrary = M.liftM Container (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Container = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Container{container_mesos = container_mesos obj} then P.Nothing else P.Just $ default_Container{container_mesos = container_mesos obj}
    , if obj == default_Container{container_docker = container_docker obj} then P.Nothing else P.Just $ default_Container{container_docker = container_docker obj}
    ]
from_Container :: Container -> T.ThriftVal
from_Container record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v149 -> P.Just (1, ("mesos",from_MesosContainer _v149))) $ container_mesos record
  , (\_v149 -> P.Just (2, ("docker",from_DockerContainer _v149))) $ container_docker record
  ]
write_Container :: (T.Protocol p, T.Transport t) => p t -> Container -> P.IO ()
write_Container oprot record = T.writeVal oprot $ from_Container record
encode_Container :: (T.Protocol p, T.Transport t) => p t -> Container -> LBS.ByteString
encode_Container oprot record = T.serializeVal oprot $ from_Container record
to_Container :: T.ThriftVal -> Container
to_Container (T.TStruct fields) = Container{
  container_mesos = P.maybe (container_mesos default_Container) (\(_,_val151) -> (case _val151 of {T.TStruct _val152 -> (to_MesosContainer (T.TStruct _val152)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  container_docker = P.maybe (container_docker default_Container) (\(_,_val151) -> (case _val151 of {T.TStruct _val153 -> (to_DockerContainer (T.TStruct _val153)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Container _ = P.error "not a struct"
read_Container :: (T.Transport t, T.Protocol p) => p t -> P.IO Container
read_Container iprot = to_Container <$> T.readVal iprot (T.T_STRUCT typemap_Container)
decode_Container :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Container
decode_Container iprot bs = to_Container $ T.deserializeVal iprot (T.T_STRUCT typemap_Container) bs
typemap_Container :: T.TypeMap
typemap_Container = Map.fromList [(1,("mesos",(T.T_STRUCT typemap_MesosContainer))),(2,("docker",(T.T_STRUCT typemap_DockerContainer)))]
default_Container :: Container
default_Container = Container{
  container_mesos = default_MesosContainer,
  container_docker = default_DockerContainer}
data TaskConfig = TaskConfig  { taskConfig_job :: JobKey
  , taskConfig_owner :: Identity
  , taskConfig_environment :: LT.Text
  , taskConfig_jobName :: LT.Text
  , taskConfig_isService :: P.Bool
  , taskConfig_numCpus :: P.Double
  , taskConfig_ramMb :: I.Int64
  , taskConfig_diskMb :: I.Int64
  , taskConfig_priority :: I.Int32
  , taskConfig_maxTaskFailures :: I.Int32
  , taskConfig_production :: P.Maybe P.Bool
  , taskConfig_constraints :: (Set.HashSet Constraint)
  , taskConfig_requestedPorts :: (Set.HashSet LT.Text)
  , taskConfig_container :: P.Maybe Container
  , taskConfig_taskLinks :: P.Maybe (Map.HashMap LT.Text LT.Text)
  , taskConfig_contactEmail :: P.Maybe LT.Text
  , taskConfig_executorConfig :: P.Maybe ExecutorConfig
  , taskConfig_metadata :: P.Maybe (Set.HashSet Metadata)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable TaskConfig where
  hashWithSalt salt record = salt   `H.hashWithSalt` taskConfig_job record   `H.hashWithSalt` taskConfig_owner record   `H.hashWithSalt` taskConfig_environment record   `H.hashWithSalt` taskConfig_jobName record   `H.hashWithSalt` taskConfig_isService record   `H.hashWithSalt` taskConfig_numCpus record   `H.hashWithSalt` taskConfig_ramMb record   `H.hashWithSalt` taskConfig_diskMb record   `H.hashWithSalt` taskConfig_priority record   `H.hashWithSalt` taskConfig_maxTaskFailures record   `H.hashWithSalt` taskConfig_production record   `H.hashWithSalt` taskConfig_constraints record   `H.hashWithSalt` taskConfig_requestedPorts record   `H.hashWithSalt` taskConfig_container record   `H.hashWithSalt` taskConfig_taskLinks record   `H.hashWithSalt` taskConfig_contactEmail record   `H.hashWithSalt` taskConfig_executorConfig record   `H.hashWithSalt` taskConfig_metadata record  
instance QC.Arbitrary TaskConfig where 
  arbitrary = M.liftM TaskConfig (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TaskConfig = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TaskConfig{taskConfig_job = taskConfig_job obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_job = taskConfig_job obj}
    , if obj == default_TaskConfig{taskConfig_owner = taskConfig_owner obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_owner = taskConfig_owner obj}
    , if obj == default_TaskConfig{taskConfig_environment = taskConfig_environment obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_environment = taskConfig_environment obj}
    , if obj == default_TaskConfig{taskConfig_jobName = taskConfig_jobName obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_jobName = taskConfig_jobName obj}
    , if obj == default_TaskConfig{taskConfig_isService = taskConfig_isService obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_isService = taskConfig_isService obj}
    , if obj == default_TaskConfig{taskConfig_numCpus = taskConfig_numCpus obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_numCpus = taskConfig_numCpus obj}
    , if obj == default_TaskConfig{taskConfig_ramMb = taskConfig_ramMb obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_ramMb = taskConfig_ramMb obj}
    , if obj == default_TaskConfig{taskConfig_diskMb = taskConfig_diskMb obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_diskMb = taskConfig_diskMb obj}
    , if obj == default_TaskConfig{taskConfig_priority = taskConfig_priority obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_priority = taskConfig_priority obj}
    , if obj == default_TaskConfig{taskConfig_maxTaskFailures = taskConfig_maxTaskFailures obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_maxTaskFailures = taskConfig_maxTaskFailures obj}
    , if obj == default_TaskConfig{taskConfig_production = taskConfig_production obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_production = taskConfig_production obj}
    , if obj == default_TaskConfig{taskConfig_constraints = taskConfig_constraints obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_constraints = taskConfig_constraints obj}
    , if obj == default_TaskConfig{taskConfig_requestedPorts = taskConfig_requestedPorts obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_requestedPorts = taskConfig_requestedPorts obj}
    , if obj == default_TaskConfig{taskConfig_container = taskConfig_container obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_container = taskConfig_container obj}
    , if obj == default_TaskConfig{taskConfig_taskLinks = taskConfig_taskLinks obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_taskLinks = taskConfig_taskLinks obj}
    , if obj == default_TaskConfig{taskConfig_contactEmail = taskConfig_contactEmail obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_contactEmail = taskConfig_contactEmail obj}
    , if obj == default_TaskConfig{taskConfig_executorConfig = taskConfig_executorConfig obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_executorConfig = taskConfig_executorConfig obj}
    , if obj == default_TaskConfig{taskConfig_metadata = taskConfig_metadata obj} then P.Nothing else P.Just $ default_TaskConfig{taskConfig_metadata = taskConfig_metadata obj}
    ]
from_TaskConfig :: TaskConfig -> T.ThriftVal
from_TaskConfig record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v156 -> P.Just (3, ("jobName",T.TString $ E.encodeUtf8 _v156))) $ taskConfig_jobName record
  , (\_v156 -> P.Just (7, ("isService",T.TBool _v156))) $ taskConfig_isService record
  , (\_v156 -> P.Just (8, ("numCpus",T.TDouble _v156))) $ taskConfig_numCpus record
  , (\_v156 -> P.Just (9, ("ramMb",T.TI64 _v156))) $ taskConfig_ramMb record
  , (\_v156 -> P.Just (10, ("diskMb",T.TI64 _v156))) $ taskConfig_diskMb record
  , (\_v156 -> P.Just (11, ("priority",T.TI32 _v156))) $ taskConfig_priority record
  , (\_v156 -> P.Just (13, ("maxTaskFailures",T.TI32 _v156))) $ taskConfig_maxTaskFailures record
  , (\_v156 -> P.Just (17, ("owner",from_Identity _v156))) $ taskConfig_owner record
  , (\_v156 -> (18, ("production",T.TBool _v156))) <$> taskConfig_production record
  , (\_v156 -> P.Just (20, ("constraints",T.TSet (T.T_STRUCT typemap_Constraint) $ P.map (\_v158 -> from_Constraint _v158) $ Set.toList _v156))) $ taskConfig_constraints record
  , (\_v156 -> P.Just (21, ("requestedPorts",T.TSet T.T_STRING $ P.map (\_v160 -> T.TString $ E.encodeUtf8 _v160) $ Set.toList _v156))) $ taskConfig_requestedPorts record
  , (\_v156 -> (22, ("taskLinks",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k161,_v162) -> (T.TString $ E.encodeUtf8 _k161, T.TString $ E.encodeUtf8 _v162)) $ Map.toList _v156))) <$> taskConfig_taskLinks record
  , (\_v156 -> (23, ("contactEmail",T.TString $ E.encodeUtf8 _v156))) <$> taskConfig_contactEmail record
  , (\_v156 -> (25, ("executorConfig",from_ExecutorConfig _v156))) <$> taskConfig_executorConfig record
  , (\_v156 -> P.Just (26, ("environment",T.TString $ E.encodeUtf8 _v156))) $ taskConfig_environment record
  , (\_v156 -> (27, ("metadata",T.TSet (T.T_STRUCT typemap_Metadata) $ P.map (\_v164 -> from_Metadata _v164) $ Set.toList _v156))) <$> taskConfig_metadata record
  , (\_v156 -> P.Just (28, ("job",from_JobKey _v156))) $ taskConfig_job record
  , (\_v156 -> (29, ("container",from_Container _v156))) <$> taskConfig_container record
  ]
write_TaskConfig :: (T.Protocol p, T.Transport t) => p t -> TaskConfig -> P.IO ()
write_TaskConfig oprot record = T.writeVal oprot $ from_TaskConfig record
encode_TaskConfig :: (T.Protocol p, T.Transport t) => p t -> TaskConfig -> LBS.ByteString
encode_TaskConfig oprot record = T.serializeVal oprot $ from_TaskConfig record
to_TaskConfig :: T.ThriftVal -> TaskConfig
to_TaskConfig (T.TStruct fields) = TaskConfig{
  taskConfig_job = P.maybe (taskConfig_job default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TStruct _val167 -> (to_JobKey (T.TStruct _val167)); _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  taskConfig_owner = P.maybe (taskConfig_owner default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TStruct _val168 -> (to_Identity (T.TStruct _val168)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  taskConfig_environment = P.maybe (taskConfig_environment default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TString _val169 -> E.decodeUtf8 _val169; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  taskConfig_jobName = P.maybe (taskConfig_jobName default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TString _val170 -> E.decodeUtf8 _val170; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  taskConfig_isService = P.maybe (taskConfig_isService default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TBool _val171 -> _val171; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  taskConfig_numCpus = P.maybe (taskConfig_numCpus default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TDouble _val172 -> _val172; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  taskConfig_ramMb = P.maybe (taskConfig_ramMb default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TI64 _val173 -> _val173; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  taskConfig_diskMb = P.maybe (taskConfig_diskMb default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TI64 _val174 -> _val174; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  taskConfig_priority = P.maybe (taskConfig_priority default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TI32 _val175 -> _val175; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  taskConfig_maxTaskFailures = P.maybe (taskConfig_maxTaskFailures default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TI32 _val176 -> _val176; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  taskConfig_production = P.maybe (P.Nothing) (\(_,_val166) -> P.Just (case _val166 of {T.TBool _val177 -> _val177; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  taskConfig_constraints = P.maybe (taskConfig_constraints default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TSet _ _val178 -> (Set.fromList $ P.map (\_v179 -> (case _v179 of {T.TStruct _val180 -> (to_Constraint (T.TStruct _val180)); _ -> P.error "wrong type"})) _val178); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  taskConfig_requestedPorts = P.maybe (taskConfig_requestedPorts default_TaskConfig) (\(_,_val166) -> (case _val166 of {T.TSet _ _val181 -> (Set.fromList $ P.map (\_v182 -> (case _v182 of {T.TString _val183 -> E.decodeUtf8 _val183; _ -> P.error "wrong type"})) _val181); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  taskConfig_container = P.maybe (taskConfig_container default_TaskConfig) (\(_,_val166) -> P.Just (case _val166 of {T.TStruct _val184 -> (to_Container (T.TStruct _val184)); _ -> P.error "wrong type"})) (Map.lookup (29) fields),
  taskConfig_taskLinks = P.maybe (P.Nothing) (\(_,_val166) -> P.Just (case _val166 of {T.TMap _ _ _val185 -> (Map.fromList $ P.map (\(_k187,_v186) -> ((case _k187 of {T.TString _val188 -> E.decodeUtf8 _val188; _ -> P.error "wrong type"}),(case _v186 of {T.TString _val189 -> E.decodeUtf8 _val189; _ -> P.error "wrong type"}))) _val185); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  taskConfig_contactEmail = P.maybe (P.Nothing) (\(_,_val166) -> P.Just (case _val166 of {T.TString _val190 -> E.decodeUtf8 _val190; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  taskConfig_executorConfig = P.maybe (P.Nothing) (\(_,_val166) -> P.Just (case _val166 of {T.TStruct _val191 -> (to_ExecutorConfig (T.TStruct _val191)); _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  taskConfig_metadata = P.maybe (P.Nothing) (\(_,_val166) -> P.Just (case _val166 of {T.TSet _ _val192 -> (Set.fromList $ P.map (\_v193 -> (case _v193 of {T.TStruct _val194 -> (to_Metadata (T.TStruct _val194)); _ -> P.error "wrong type"})) _val192); _ -> P.error "wrong type"})) (Map.lookup (27) fields)
  }
to_TaskConfig _ = P.error "not a struct"
read_TaskConfig :: (T.Transport t, T.Protocol p) => p t -> P.IO TaskConfig
read_TaskConfig iprot = to_TaskConfig <$> T.readVal iprot (T.T_STRUCT typemap_TaskConfig)
decode_TaskConfig :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TaskConfig
decode_TaskConfig iprot bs = to_TaskConfig $ T.deserializeVal iprot (T.T_STRUCT typemap_TaskConfig) bs
typemap_TaskConfig :: T.TypeMap
typemap_TaskConfig = Map.fromList [(3,("jobName",T.T_STRING)),(7,("isService",T.T_BOOL)),(8,("numCpus",T.T_DOUBLE)),(9,("ramMb",T.T_I64)),(10,("diskMb",T.T_I64)),(11,("priority",T.T_I32)),(13,("maxTaskFailures",T.T_I32)),(17,("owner",(T.T_STRUCT typemap_Identity))),(18,("production",T.T_BOOL)),(20,("constraints",(T.T_SET (T.T_STRUCT typemap_Constraint)))),(21,("requestedPorts",(T.T_SET T.T_STRING))),(22,("taskLinks",(T.T_MAP T.T_STRING T.T_STRING))),(23,("contactEmail",T.T_STRING)),(25,("executorConfig",(T.T_STRUCT typemap_ExecutorConfig))),(26,("environment",T.T_STRING)),(27,("metadata",(T.T_SET (T.T_STRUCT typemap_Metadata)))),(28,("job",(T.T_STRUCT typemap_JobKey))),(29,("container",(T.T_STRUCT typemap_Container)))]
default_TaskConfig :: TaskConfig
default_TaskConfig = TaskConfig{
  taskConfig_jobName = "",
  taskConfig_isService = P.False,
  taskConfig_numCpus = 0,
  taskConfig_ramMb = 0,
  taskConfig_diskMb = 0,
  taskConfig_priority = 0,
  taskConfig_maxTaskFailures = 0,
  taskConfig_owner = default_Identity,
  taskConfig_production = P.Nothing,
  taskConfig_constraints = Set.empty,
  taskConfig_requestedPorts = Set.empty,
  taskConfig_taskLinks = P.Nothing,
  taskConfig_contactEmail = P.Nothing,
  taskConfig_executorConfig = P.Nothing,
  taskConfig_environment = "",
  taskConfig_metadata = P.Nothing,
  taskConfig_job = default_JobKey,
  taskConfig_container = P.Just default_Container{container_mesos = default_MesosContainer}}
data JobConfiguration = JobConfiguration  { jobConfiguration_key :: JobKey
  , jobConfiguration_owner :: Identity
  , jobConfiguration_cronSchedule :: P.Maybe LT.Text
  , jobConfiguration_cronCollisionPolicy :: CronCollisionPolicy
  , jobConfiguration_taskConfig :: TaskConfig
  , jobConfiguration_instanceCount :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobConfiguration where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobConfiguration_key record   `H.hashWithSalt` jobConfiguration_owner record   `H.hashWithSalt` jobConfiguration_cronSchedule record   `H.hashWithSalt` jobConfiguration_cronCollisionPolicy record   `H.hashWithSalt` jobConfiguration_taskConfig record   `H.hashWithSalt` jobConfiguration_instanceCount record  
instance QC.Arbitrary JobConfiguration where 
  arbitrary = M.liftM JobConfiguration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobConfiguration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobConfiguration{jobConfiguration_key = jobConfiguration_key obj} then P.Nothing else P.Just $ default_JobConfiguration{jobConfiguration_key = jobConfiguration_key obj}
    , if obj == default_JobConfiguration{jobConfiguration_owner = jobConfiguration_owner obj} then P.Nothing else P.Just $ default_JobConfiguration{jobConfiguration_owner = jobConfiguration_owner obj}
    , if obj == default_JobConfiguration{jobConfiguration_cronSchedule = jobConfiguration_cronSchedule obj} then P.Nothing else P.Just $ default_JobConfiguration{jobConfiguration_cronSchedule = jobConfiguration_cronSchedule obj}
    , if obj == default_JobConfiguration{jobConfiguration_cronCollisionPolicy = jobConfiguration_cronCollisionPolicy obj} then P.Nothing else P.Just $ default_JobConfiguration{jobConfiguration_cronCollisionPolicy = jobConfiguration_cronCollisionPolicy obj}
    , if obj == default_JobConfiguration{jobConfiguration_taskConfig = jobConfiguration_taskConfig obj} then P.Nothing else P.Just $ default_JobConfiguration{jobConfiguration_taskConfig = jobConfiguration_taskConfig obj}
    , if obj == default_JobConfiguration{jobConfiguration_instanceCount = jobConfiguration_instanceCount obj} then P.Nothing else P.Just $ default_JobConfiguration{jobConfiguration_instanceCount = jobConfiguration_instanceCount obj}
    ]
from_JobConfiguration :: JobConfiguration -> T.ThriftVal
from_JobConfiguration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v197 -> (4, ("cronSchedule",T.TString $ E.encodeUtf8 _v197))) <$> jobConfiguration_cronSchedule record
  , (\_v197 -> P.Just (5, ("cronCollisionPolicy",T.TI32 $ P.fromIntegral $ P.fromEnum _v197))) $ jobConfiguration_cronCollisionPolicy record
  , (\_v197 -> P.Just (6, ("taskConfig",from_TaskConfig _v197))) $ jobConfiguration_taskConfig record
  , (\_v197 -> P.Just (7, ("owner",from_Identity _v197))) $ jobConfiguration_owner record
  , (\_v197 -> P.Just (8, ("instanceCount",T.TI32 _v197))) $ jobConfiguration_instanceCount record
  , (\_v197 -> P.Just (9, ("key",from_JobKey _v197))) $ jobConfiguration_key record
  ]
write_JobConfiguration :: (T.Protocol p, T.Transport t) => p t -> JobConfiguration -> P.IO ()
write_JobConfiguration oprot record = T.writeVal oprot $ from_JobConfiguration record
encode_JobConfiguration :: (T.Protocol p, T.Transport t) => p t -> JobConfiguration -> LBS.ByteString
encode_JobConfiguration oprot record = T.serializeVal oprot $ from_JobConfiguration record
to_JobConfiguration :: T.ThriftVal -> JobConfiguration
to_JobConfiguration (T.TStruct fields) = JobConfiguration{
  jobConfiguration_key = P.maybe (jobConfiguration_key default_JobConfiguration) (\(_,_val199) -> (case _val199 of {T.TStruct _val200 -> (to_JobKey (T.TStruct _val200)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  jobConfiguration_owner = P.maybe (jobConfiguration_owner default_JobConfiguration) (\(_,_val199) -> (case _val199 of {T.TStruct _val201 -> (to_Identity (T.TStruct _val201)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  jobConfiguration_cronSchedule = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TString _val202 -> E.decodeUtf8 _val202; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  jobConfiguration_cronCollisionPolicy = P.maybe (jobConfiguration_cronCollisionPolicy default_JobConfiguration) (\(_,_val199) -> (case _val199 of {T.TI32 _val203 -> P.toEnum $ P.fromIntegral _val203; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  jobConfiguration_taskConfig = P.maybe (jobConfiguration_taskConfig default_JobConfiguration) (\(_,_val199) -> (case _val199 of {T.TStruct _val204 -> (to_TaskConfig (T.TStruct _val204)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  jobConfiguration_instanceCount = P.maybe (jobConfiguration_instanceCount default_JobConfiguration) (\(_,_val199) -> (case _val199 of {T.TI32 _val205 -> _val205; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_JobConfiguration _ = P.error "not a struct"
read_JobConfiguration :: (T.Transport t, T.Protocol p) => p t -> P.IO JobConfiguration
read_JobConfiguration iprot = to_JobConfiguration <$> T.readVal iprot (T.T_STRUCT typemap_JobConfiguration)
decode_JobConfiguration :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobConfiguration
decode_JobConfiguration iprot bs = to_JobConfiguration $ T.deserializeVal iprot (T.T_STRUCT typemap_JobConfiguration) bs
typemap_JobConfiguration :: T.TypeMap
typemap_JobConfiguration = Map.fromList [(4,("cronSchedule",T.T_STRING)),(5,("cronCollisionPolicy",T.T_I32)),(6,("taskConfig",(T.T_STRUCT typemap_TaskConfig))),(7,("owner",(T.T_STRUCT typemap_Identity))),(8,("instanceCount",T.T_I32)),(9,("key",(T.T_STRUCT typemap_JobKey)))]
default_JobConfiguration :: JobConfiguration
default_JobConfiguration = JobConfiguration{
  jobConfiguration_cronSchedule = P.Nothing,
  jobConfiguration_cronCollisionPolicy = (P.toEnum 0),
  jobConfiguration_taskConfig = default_TaskConfig,
  jobConfiguration_owner = default_Identity,
  jobConfiguration_instanceCount = 0,
  jobConfiguration_key = default_JobKey}
data JobStats = JobStats  { jobStats_activeTaskCount :: I.Int32
  , jobStats_finishedTaskCount :: I.Int32
  , jobStats_failedTaskCount :: I.Int32
  , jobStats_pendingTaskCount :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobStats where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobStats_activeTaskCount record   `H.hashWithSalt` jobStats_finishedTaskCount record   `H.hashWithSalt` jobStats_failedTaskCount record   `H.hashWithSalt` jobStats_pendingTaskCount record  
instance QC.Arbitrary JobStats where 
  arbitrary = M.liftM JobStats (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobStats = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobStats{jobStats_activeTaskCount = jobStats_activeTaskCount obj} then P.Nothing else P.Just $ default_JobStats{jobStats_activeTaskCount = jobStats_activeTaskCount obj}
    , if obj == default_JobStats{jobStats_finishedTaskCount = jobStats_finishedTaskCount obj} then P.Nothing else P.Just $ default_JobStats{jobStats_finishedTaskCount = jobStats_finishedTaskCount obj}
    , if obj == default_JobStats{jobStats_failedTaskCount = jobStats_failedTaskCount obj} then P.Nothing else P.Just $ default_JobStats{jobStats_failedTaskCount = jobStats_failedTaskCount obj}
    , if obj == default_JobStats{jobStats_pendingTaskCount = jobStats_pendingTaskCount obj} then P.Nothing else P.Just $ default_JobStats{jobStats_pendingTaskCount = jobStats_pendingTaskCount obj}
    ]
from_JobStats :: JobStats -> T.ThriftVal
from_JobStats record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v208 -> P.Just (1, ("activeTaskCount",T.TI32 _v208))) $ jobStats_activeTaskCount record
  , (\_v208 -> P.Just (2, ("finishedTaskCount",T.TI32 _v208))) $ jobStats_finishedTaskCount record
  , (\_v208 -> P.Just (3, ("failedTaskCount",T.TI32 _v208))) $ jobStats_failedTaskCount record
  , (\_v208 -> P.Just (4, ("pendingTaskCount",T.TI32 _v208))) $ jobStats_pendingTaskCount record
  ]
write_JobStats :: (T.Protocol p, T.Transport t) => p t -> JobStats -> P.IO ()
write_JobStats oprot record = T.writeVal oprot $ from_JobStats record
encode_JobStats :: (T.Protocol p, T.Transport t) => p t -> JobStats -> LBS.ByteString
encode_JobStats oprot record = T.serializeVal oprot $ from_JobStats record
to_JobStats :: T.ThriftVal -> JobStats
to_JobStats (T.TStruct fields) = JobStats{
  jobStats_activeTaskCount = P.maybe (jobStats_activeTaskCount default_JobStats) (\(_,_val210) -> (case _val210 of {T.TI32 _val211 -> _val211; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobStats_finishedTaskCount = P.maybe (jobStats_finishedTaskCount default_JobStats) (\(_,_val210) -> (case _val210 of {T.TI32 _val212 -> _val212; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobStats_failedTaskCount = P.maybe (jobStats_failedTaskCount default_JobStats) (\(_,_val210) -> (case _val210 of {T.TI32 _val213 -> _val213; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  jobStats_pendingTaskCount = P.maybe (jobStats_pendingTaskCount default_JobStats) (\(_,_val210) -> (case _val210 of {T.TI32 _val214 -> _val214; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_JobStats _ = P.error "not a struct"
read_JobStats :: (T.Transport t, T.Protocol p) => p t -> P.IO JobStats
read_JobStats iprot = to_JobStats <$> T.readVal iprot (T.T_STRUCT typemap_JobStats)
decode_JobStats :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobStats
decode_JobStats iprot bs = to_JobStats $ T.deserializeVal iprot (T.T_STRUCT typemap_JobStats) bs
typemap_JobStats :: T.TypeMap
typemap_JobStats = Map.fromList [(1,("activeTaskCount",T.T_I32)),(2,("finishedTaskCount",T.T_I32)),(3,("failedTaskCount",T.T_I32)),(4,("pendingTaskCount",T.T_I32))]
default_JobStats :: JobStats
default_JobStats = JobStats{
  jobStats_activeTaskCount = 0,
  jobStats_finishedTaskCount = 0,
  jobStats_failedTaskCount = 0,
  jobStats_pendingTaskCount = 0}
data JobSummary = JobSummary  { jobSummary_job :: JobConfiguration
  , jobSummary_stats :: JobStats
  , jobSummary_nextCronRunMs :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobSummary where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobSummary_job record   `H.hashWithSalt` jobSummary_stats record   `H.hashWithSalt` jobSummary_nextCronRunMs record  
instance QC.Arbitrary JobSummary where 
  arbitrary = M.liftM JobSummary (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_JobSummary = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobSummary{jobSummary_job = jobSummary_job obj} then P.Nothing else P.Just $ default_JobSummary{jobSummary_job = jobSummary_job obj}
    , if obj == default_JobSummary{jobSummary_stats = jobSummary_stats obj} then P.Nothing else P.Just $ default_JobSummary{jobSummary_stats = jobSummary_stats obj}
    , if obj == default_JobSummary{jobSummary_nextCronRunMs = jobSummary_nextCronRunMs obj} then P.Nothing else P.Just $ default_JobSummary{jobSummary_nextCronRunMs = jobSummary_nextCronRunMs obj}
    ]
from_JobSummary :: JobSummary -> T.ThriftVal
from_JobSummary record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v217 -> P.Just (1, ("job",from_JobConfiguration _v217))) $ jobSummary_job record
  , (\_v217 -> P.Just (2, ("stats",from_JobStats _v217))) $ jobSummary_stats record
  , (\_v217 -> (3, ("nextCronRunMs",T.TI64 _v217))) <$> jobSummary_nextCronRunMs record
  ]
write_JobSummary :: (T.Protocol p, T.Transport t) => p t -> JobSummary -> P.IO ()
write_JobSummary oprot record = T.writeVal oprot $ from_JobSummary record
encode_JobSummary :: (T.Protocol p, T.Transport t) => p t -> JobSummary -> LBS.ByteString
encode_JobSummary oprot record = T.serializeVal oprot $ from_JobSummary record
to_JobSummary :: T.ThriftVal -> JobSummary
to_JobSummary (T.TStruct fields) = JobSummary{
  jobSummary_job = P.maybe (jobSummary_job default_JobSummary) (\(_,_val219) -> (case _val219 of {T.TStruct _val220 -> (to_JobConfiguration (T.TStruct _val220)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobSummary_stats = P.maybe (jobSummary_stats default_JobSummary) (\(_,_val219) -> (case _val219 of {T.TStruct _val221 -> (to_JobStats (T.TStruct _val221)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobSummary_nextCronRunMs = P.maybe (P.Nothing) (\(_,_val219) -> P.Just (case _val219 of {T.TI64 _val222 -> _val222; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobSummary _ = P.error "not a struct"
read_JobSummary :: (T.Transport t, T.Protocol p) => p t -> P.IO JobSummary
read_JobSummary iprot = to_JobSummary <$> T.readVal iprot (T.T_STRUCT typemap_JobSummary)
decode_JobSummary :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobSummary
decode_JobSummary iprot bs = to_JobSummary $ T.deserializeVal iprot (T.T_STRUCT typemap_JobSummary) bs
typemap_JobSummary :: T.TypeMap
typemap_JobSummary = Map.fromList [(1,("job",(T.T_STRUCT typemap_JobConfiguration))),(2,("stats",(T.T_STRUCT typemap_JobStats))),(3,("nextCronRunMs",T.T_I64))]
default_JobSummary :: JobSummary
default_JobSummary = JobSummary{
  jobSummary_job = default_JobConfiguration,
  jobSummary_stats = default_JobStats,
  jobSummary_nextCronRunMs = P.Nothing}
data AddInstancesConfig = AddInstancesConfig  { addInstancesConfig_key :: JobKey
  , addInstancesConfig_taskConfig :: TaskConfig
  , addInstancesConfig_instanceIds :: (Set.HashSet I.Int32)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AddInstancesConfig where
  hashWithSalt salt record = salt   `H.hashWithSalt` addInstancesConfig_key record   `H.hashWithSalt` addInstancesConfig_taskConfig record   `H.hashWithSalt` addInstancesConfig_instanceIds record  
instance QC.Arbitrary AddInstancesConfig where 
  arbitrary = M.liftM AddInstancesConfig (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddInstancesConfig = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddInstancesConfig{addInstancesConfig_key = addInstancesConfig_key obj} then P.Nothing else P.Just $ default_AddInstancesConfig{addInstancesConfig_key = addInstancesConfig_key obj}
    , if obj == default_AddInstancesConfig{addInstancesConfig_taskConfig = addInstancesConfig_taskConfig obj} then P.Nothing else P.Just $ default_AddInstancesConfig{addInstancesConfig_taskConfig = addInstancesConfig_taskConfig obj}
    , if obj == default_AddInstancesConfig{addInstancesConfig_instanceIds = addInstancesConfig_instanceIds obj} then P.Nothing else P.Just $ default_AddInstancesConfig{addInstancesConfig_instanceIds = addInstancesConfig_instanceIds obj}
    ]
from_AddInstancesConfig :: AddInstancesConfig -> T.ThriftVal
from_AddInstancesConfig record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v225 -> P.Just (1, ("key",from_JobKey _v225))) $ addInstancesConfig_key record
  , (\_v225 -> P.Just (2, ("taskConfig",from_TaskConfig _v225))) $ addInstancesConfig_taskConfig record
  , (\_v225 -> P.Just (3, ("instanceIds",T.TSet T.T_I32 $ P.map (\_v227 -> T.TI32 _v227) $ Set.toList _v225))) $ addInstancesConfig_instanceIds record
  ]
write_AddInstancesConfig :: (T.Protocol p, T.Transport t) => p t -> AddInstancesConfig -> P.IO ()
write_AddInstancesConfig oprot record = T.writeVal oprot $ from_AddInstancesConfig record
encode_AddInstancesConfig :: (T.Protocol p, T.Transport t) => p t -> AddInstancesConfig -> LBS.ByteString
encode_AddInstancesConfig oprot record = T.serializeVal oprot $ from_AddInstancesConfig record
to_AddInstancesConfig :: T.ThriftVal -> AddInstancesConfig
to_AddInstancesConfig (T.TStruct fields) = AddInstancesConfig{
  addInstancesConfig_key = P.maybe (addInstancesConfig_key default_AddInstancesConfig) (\(_,_val229) -> (case _val229 of {T.TStruct _val230 -> (to_JobKey (T.TStruct _val230)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  addInstancesConfig_taskConfig = P.maybe (addInstancesConfig_taskConfig default_AddInstancesConfig) (\(_,_val229) -> (case _val229 of {T.TStruct _val231 -> (to_TaskConfig (T.TStruct _val231)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addInstancesConfig_instanceIds = P.maybe (addInstancesConfig_instanceIds default_AddInstancesConfig) (\(_,_val229) -> (case _val229 of {T.TSet _ _val232 -> (Set.fromList $ P.map (\_v233 -> (case _v233 of {T.TI32 _val234 -> _val234; _ -> P.error "wrong type"})) _val232); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AddInstancesConfig _ = P.error "not a struct"
read_AddInstancesConfig :: (T.Transport t, T.Protocol p) => p t -> P.IO AddInstancesConfig
read_AddInstancesConfig iprot = to_AddInstancesConfig <$> T.readVal iprot (T.T_STRUCT typemap_AddInstancesConfig)
decode_AddInstancesConfig :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AddInstancesConfig
decode_AddInstancesConfig iprot bs = to_AddInstancesConfig $ T.deserializeVal iprot (T.T_STRUCT typemap_AddInstancesConfig) bs
typemap_AddInstancesConfig :: T.TypeMap
typemap_AddInstancesConfig = Map.fromList [(1,("key",(T.T_STRUCT typemap_JobKey))),(2,("taskConfig",(T.T_STRUCT typemap_TaskConfig))),(3,("instanceIds",(T.T_SET T.T_I32)))]
default_AddInstancesConfig :: AddInstancesConfig
default_AddInstancesConfig = AddInstancesConfig{
  addInstancesConfig_key = default_JobKey,
  addInstancesConfig_taskConfig = default_TaskConfig,
  addInstancesConfig_instanceIds = Set.empty}
data Range = Range  { range_first :: I.Int32
  , range_last :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Range where
  hashWithSalt salt record = salt   `H.hashWithSalt` range_first record   `H.hashWithSalt` range_last record  
instance QC.Arbitrary Range where 
  arbitrary = M.liftM Range (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Range = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Range{range_first = range_first obj} then P.Nothing else P.Just $ default_Range{range_first = range_first obj}
    , if obj == default_Range{range_last = range_last obj} then P.Nothing else P.Just $ default_Range{range_last = range_last obj}
    ]
from_Range :: Range -> T.ThriftVal
from_Range record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v237 -> P.Just (1, ("first",T.TI32 _v237))) $ range_first record
  , (\_v237 -> P.Just (2, ("last",T.TI32 _v237))) $ range_last record
  ]
write_Range :: (T.Protocol p, T.Transport t) => p t -> Range -> P.IO ()
write_Range oprot record = T.writeVal oprot $ from_Range record
encode_Range :: (T.Protocol p, T.Transport t) => p t -> Range -> LBS.ByteString
encode_Range oprot record = T.serializeVal oprot $ from_Range record
to_Range :: T.ThriftVal -> Range
to_Range (T.TStruct fields) = Range{
  range_first = P.maybe (range_first default_Range) (\(_,_val239) -> (case _val239 of {T.TI32 _val240 -> _val240; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  range_last = P.maybe (range_last default_Range) (\(_,_val239) -> (case _val239 of {T.TI32 _val241 -> _val241; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Range _ = P.error "not a struct"
read_Range :: (T.Transport t, T.Protocol p) => p t -> P.IO Range
read_Range iprot = to_Range <$> T.readVal iprot (T.T_STRUCT typemap_Range)
decode_Range :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Range
decode_Range iprot bs = to_Range $ T.deserializeVal iprot (T.T_STRUCT typemap_Range) bs
typemap_Range :: T.TypeMap
typemap_Range = Map.fromList [(1,("first",T.T_I32)),(2,("last",T.T_I32))]
default_Range :: Range
default_Range = Range{
  range_first = 0,
  range_last = 0}
data ConfigGroup = ConfigGroup  { configGroup_config :: TaskConfig
  , configGroup_instanceIds :: (Set.HashSet I.Int32)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ConfigGroup where
  hashWithSalt salt record = salt   `H.hashWithSalt` configGroup_config record   `H.hashWithSalt` configGroup_instanceIds record  
instance QC.Arbitrary ConfigGroup where 
  arbitrary = M.liftM ConfigGroup (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfigGroup = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfigGroup{configGroup_config = configGroup_config obj} then P.Nothing else P.Just $ default_ConfigGroup{configGroup_config = configGroup_config obj}
    , if obj == default_ConfigGroup{configGroup_instanceIds = configGroup_instanceIds obj} then P.Nothing else P.Just $ default_ConfigGroup{configGroup_instanceIds = configGroup_instanceIds obj}
    ]
from_ConfigGroup :: ConfigGroup -> T.ThriftVal
from_ConfigGroup record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v244 -> P.Just (1, ("config",from_TaskConfig _v244))) $ configGroup_config record
  , (\_v244 -> P.Just (2, ("instanceIds",T.TSet T.T_I32 $ P.map (\_v246 -> T.TI32 _v246) $ Set.toList _v244))) $ configGroup_instanceIds record
  ]
write_ConfigGroup :: (T.Protocol p, T.Transport t) => p t -> ConfigGroup -> P.IO ()
write_ConfigGroup oprot record = T.writeVal oprot $ from_ConfigGroup record
encode_ConfigGroup :: (T.Protocol p, T.Transport t) => p t -> ConfigGroup -> LBS.ByteString
encode_ConfigGroup oprot record = T.serializeVal oprot $ from_ConfigGroup record
to_ConfigGroup :: T.ThriftVal -> ConfigGroup
to_ConfigGroup (T.TStruct fields) = ConfigGroup{
  configGroup_config = P.maybe (configGroup_config default_ConfigGroup) (\(_,_val248) -> (case _val248 of {T.TStruct _val249 -> (to_TaskConfig (T.TStruct _val249)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  configGroup_instanceIds = P.maybe (configGroup_instanceIds default_ConfigGroup) (\(_,_val248) -> (case _val248 of {T.TSet _ _val250 -> (Set.fromList $ P.map (\_v251 -> (case _v251 of {T.TI32 _val252 -> _val252; _ -> P.error "wrong type"})) _val250); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConfigGroup _ = P.error "not a struct"
read_ConfigGroup :: (T.Transport t, T.Protocol p) => p t -> P.IO ConfigGroup
read_ConfigGroup iprot = to_ConfigGroup <$> T.readVal iprot (T.T_STRUCT typemap_ConfigGroup)
decode_ConfigGroup :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ConfigGroup
decode_ConfigGroup iprot bs = to_ConfigGroup $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfigGroup) bs
typemap_ConfigGroup :: T.TypeMap
typemap_ConfigGroup = Map.fromList [(1,("config",(T.T_STRUCT typemap_TaskConfig))),(2,("instanceIds",(T.T_SET T.T_I32)))]
default_ConfigGroup :: ConfigGroup
default_ConfigGroup = ConfigGroup{
  configGroup_config = default_TaskConfig,
  configGroup_instanceIds = Set.empty}
data ConfigSummary = ConfigSummary  { configSummary_key :: JobKey
  , configSummary_groups :: (Set.HashSet ConfigGroup)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ConfigSummary where
  hashWithSalt salt record = salt   `H.hashWithSalt` configSummary_key record   `H.hashWithSalt` configSummary_groups record  
instance QC.Arbitrary ConfigSummary where 
  arbitrary = M.liftM ConfigSummary (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfigSummary = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfigSummary{configSummary_key = configSummary_key obj} then P.Nothing else P.Just $ default_ConfigSummary{configSummary_key = configSummary_key obj}
    , if obj == default_ConfigSummary{configSummary_groups = configSummary_groups obj} then P.Nothing else P.Just $ default_ConfigSummary{configSummary_groups = configSummary_groups obj}
    ]
from_ConfigSummary :: ConfigSummary -> T.ThriftVal
from_ConfigSummary record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v255 -> P.Just (1, ("key",from_JobKey _v255))) $ configSummary_key record
  , (\_v255 -> P.Just (2, ("groups",T.TSet (T.T_STRUCT typemap_ConfigGroup) $ P.map (\_v257 -> from_ConfigGroup _v257) $ Set.toList _v255))) $ configSummary_groups record
  ]
write_ConfigSummary :: (T.Protocol p, T.Transport t) => p t -> ConfigSummary -> P.IO ()
write_ConfigSummary oprot record = T.writeVal oprot $ from_ConfigSummary record
encode_ConfigSummary :: (T.Protocol p, T.Transport t) => p t -> ConfigSummary -> LBS.ByteString
encode_ConfigSummary oprot record = T.serializeVal oprot $ from_ConfigSummary record
to_ConfigSummary :: T.ThriftVal -> ConfigSummary
to_ConfigSummary (T.TStruct fields) = ConfigSummary{
  configSummary_key = P.maybe (configSummary_key default_ConfigSummary) (\(_,_val259) -> (case _val259 of {T.TStruct _val260 -> (to_JobKey (T.TStruct _val260)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  configSummary_groups = P.maybe (configSummary_groups default_ConfigSummary) (\(_,_val259) -> (case _val259 of {T.TSet _ _val261 -> (Set.fromList $ P.map (\_v262 -> (case _v262 of {T.TStruct _val263 -> (to_ConfigGroup (T.TStruct _val263)); _ -> P.error "wrong type"})) _val261); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConfigSummary _ = P.error "not a struct"
read_ConfigSummary :: (T.Transport t, T.Protocol p) => p t -> P.IO ConfigSummary
read_ConfigSummary iprot = to_ConfigSummary <$> T.readVal iprot (T.T_STRUCT typemap_ConfigSummary)
decode_ConfigSummary :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ConfigSummary
decode_ConfigSummary iprot bs = to_ConfigSummary $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfigSummary) bs
typemap_ConfigSummary :: T.TypeMap
typemap_ConfigSummary = Map.fromList [(1,("key",(T.T_STRUCT typemap_JobKey))),(2,("groups",(T.T_SET (T.T_STRUCT typemap_ConfigGroup))))]
default_ConfigSummary :: ConfigSummary
default_ConfigSummary = ConfigSummary{
  configSummary_key = default_JobKey,
  configSummary_groups = Set.empty}
data PopulateJobResult = PopulateJobResult  { populateJobResult_populatedDEPRECATED :: (Set.HashSet TaskConfig)
  , populateJobResult_taskConfig :: TaskConfig
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PopulateJobResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` populateJobResult_populatedDEPRECATED record   `H.hashWithSalt` populateJobResult_taskConfig record  
instance QC.Arbitrary PopulateJobResult where 
  arbitrary = M.liftM PopulateJobResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PopulateJobResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PopulateJobResult{populateJobResult_populatedDEPRECATED = populateJobResult_populatedDEPRECATED obj} then P.Nothing else P.Just $ default_PopulateJobResult{populateJobResult_populatedDEPRECATED = populateJobResult_populatedDEPRECATED obj}
    , if obj == default_PopulateJobResult{populateJobResult_taskConfig = populateJobResult_taskConfig obj} then P.Nothing else P.Just $ default_PopulateJobResult{populateJobResult_taskConfig = populateJobResult_taskConfig obj}
    ]
from_PopulateJobResult :: PopulateJobResult -> T.ThriftVal
from_PopulateJobResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v266 -> P.Just (1, ("populatedDEPRECATED",T.TSet (T.T_STRUCT typemap_TaskConfig) $ P.map (\_v268 -> from_TaskConfig _v268) $ Set.toList _v266))) $ populateJobResult_populatedDEPRECATED record
  , (\_v266 -> P.Just (2, ("taskConfig",from_TaskConfig _v266))) $ populateJobResult_taskConfig record
  ]
write_PopulateJobResult :: (T.Protocol p, T.Transport t) => p t -> PopulateJobResult -> P.IO ()
write_PopulateJobResult oprot record = T.writeVal oprot $ from_PopulateJobResult record
encode_PopulateJobResult :: (T.Protocol p, T.Transport t) => p t -> PopulateJobResult -> LBS.ByteString
encode_PopulateJobResult oprot record = T.serializeVal oprot $ from_PopulateJobResult record
to_PopulateJobResult :: T.ThriftVal -> PopulateJobResult
to_PopulateJobResult (T.TStruct fields) = PopulateJobResult{
  populateJobResult_populatedDEPRECATED = P.maybe (populateJobResult_populatedDEPRECATED default_PopulateJobResult) (\(_,_val270) -> (case _val270 of {T.TSet _ _val271 -> (Set.fromList $ P.map (\_v272 -> (case _v272 of {T.TStruct _val273 -> (to_TaskConfig (T.TStruct _val273)); _ -> P.error "wrong type"})) _val271); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  populateJobResult_taskConfig = P.maybe (populateJobResult_taskConfig default_PopulateJobResult) (\(_,_val270) -> (case _val270 of {T.TStruct _val274 -> (to_TaskConfig (T.TStruct _val274)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PopulateJobResult _ = P.error "not a struct"
read_PopulateJobResult :: (T.Transport t, T.Protocol p) => p t -> P.IO PopulateJobResult
read_PopulateJobResult iprot = to_PopulateJobResult <$> T.readVal iprot (T.T_STRUCT typemap_PopulateJobResult)
decode_PopulateJobResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PopulateJobResult
decode_PopulateJobResult iprot bs = to_PopulateJobResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PopulateJobResult) bs
typemap_PopulateJobResult :: T.TypeMap
typemap_PopulateJobResult = Map.fromList [(1,("populatedDEPRECATED",(T.T_SET (T.T_STRUCT typemap_TaskConfig)))),(2,("taskConfig",(T.T_STRUCT typemap_TaskConfig)))]
default_PopulateJobResult :: PopulateJobResult
default_PopulateJobResult = PopulateJobResult{
  populateJobResult_populatedDEPRECATED = Set.empty,
  populateJobResult_taskConfig = default_TaskConfig}
data GetQuotaResult = GetQuotaResult  { getQuotaResult_quota :: ResourceAggregate
  , getQuotaResult_prodConsumption :: P.Maybe ResourceAggregate
  , getQuotaResult_nonProdConsumption :: P.Maybe ResourceAggregate
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetQuotaResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` getQuotaResult_quota record   `H.hashWithSalt` getQuotaResult_prodConsumption record   `H.hashWithSalt` getQuotaResult_nonProdConsumption record  
instance QC.Arbitrary GetQuotaResult where 
  arbitrary = M.liftM GetQuotaResult (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetQuotaResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetQuotaResult{getQuotaResult_quota = getQuotaResult_quota obj} then P.Nothing else P.Just $ default_GetQuotaResult{getQuotaResult_quota = getQuotaResult_quota obj}
    , if obj == default_GetQuotaResult{getQuotaResult_prodConsumption = getQuotaResult_prodConsumption obj} then P.Nothing else P.Just $ default_GetQuotaResult{getQuotaResult_prodConsumption = getQuotaResult_prodConsumption obj}
    , if obj == default_GetQuotaResult{getQuotaResult_nonProdConsumption = getQuotaResult_nonProdConsumption obj} then P.Nothing else P.Just $ default_GetQuotaResult{getQuotaResult_nonProdConsumption = getQuotaResult_nonProdConsumption obj}
    ]
from_GetQuotaResult :: GetQuotaResult -> T.ThriftVal
from_GetQuotaResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v277 -> P.Just (1, ("quota",from_ResourceAggregate _v277))) $ getQuotaResult_quota record
  , (\_v277 -> (2, ("prodConsumption",from_ResourceAggregate _v277))) <$> getQuotaResult_prodConsumption record
  , (\_v277 -> (3, ("nonProdConsumption",from_ResourceAggregate _v277))) <$> getQuotaResult_nonProdConsumption record
  ]
write_GetQuotaResult :: (T.Protocol p, T.Transport t) => p t -> GetQuotaResult -> P.IO ()
write_GetQuotaResult oprot record = T.writeVal oprot $ from_GetQuotaResult record
encode_GetQuotaResult :: (T.Protocol p, T.Transport t) => p t -> GetQuotaResult -> LBS.ByteString
encode_GetQuotaResult oprot record = T.serializeVal oprot $ from_GetQuotaResult record
to_GetQuotaResult :: T.ThriftVal -> GetQuotaResult
to_GetQuotaResult (T.TStruct fields) = GetQuotaResult{
  getQuotaResult_quota = P.maybe (getQuotaResult_quota default_GetQuotaResult) (\(_,_val279) -> (case _val279 of {T.TStruct _val280 -> (to_ResourceAggregate (T.TStruct _val280)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getQuotaResult_prodConsumption = P.maybe (P.Nothing) (\(_,_val279) -> P.Just (case _val279 of {T.TStruct _val281 -> (to_ResourceAggregate (T.TStruct _val281)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getQuotaResult_nonProdConsumption = P.maybe (P.Nothing) (\(_,_val279) -> P.Just (case _val279 of {T.TStruct _val282 -> (to_ResourceAggregate (T.TStruct _val282)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetQuotaResult _ = P.error "not a struct"
read_GetQuotaResult :: (T.Transport t, T.Protocol p) => p t -> P.IO GetQuotaResult
read_GetQuotaResult iprot = to_GetQuotaResult <$> T.readVal iprot (T.T_STRUCT typemap_GetQuotaResult)
decode_GetQuotaResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetQuotaResult
decode_GetQuotaResult iprot bs = to_GetQuotaResult $ T.deserializeVal iprot (T.T_STRUCT typemap_GetQuotaResult) bs
typemap_GetQuotaResult :: T.TypeMap
typemap_GetQuotaResult = Map.fromList [(1,("quota",(T.T_STRUCT typemap_ResourceAggregate))),(2,("prodConsumption",(T.T_STRUCT typemap_ResourceAggregate))),(3,("nonProdConsumption",(T.T_STRUCT typemap_ResourceAggregate)))]
default_GetQuotaResult :: GetQuotaResult
default_GetQuotaResult = GetQuotaResult{
  getQuotaResult_quota = default_ResourceAggregate,
  getQuotaResult_prodConsumption = P.Nothing,
  getQuotaResult_nonProdConsumption = P.Nothing}
data AcquireLockResult = AcquireLockResult  { acquireLockResult_lock :: Lock
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AcquireLockResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireLockResult_lock record  
instance QC.Arbitrary AcquireLockResult where 
  arbitrary = M.liftM AcquireLockResult (QC.arbitrary)
  shrink obj | obj == default_AcquireLockResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireLockResult{acquireLockResult_lock = acquireLockResult_lock obj} then P.Nothing else P.Just $ default_AcquireLockResult{acquireLockResult_lock = acquireLockResult_lock obj}
    ]
from_AcquireLockResult :: AcquireLockResult -> T.ThriftVal
from_AcquireLockResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v285 -> P.Just (1, ("lock",from_Lock _v285))) $ acquireLockResult_lock record
  ]
write_AcquireLockResult :: (T.Protocol p, T.Transport t) => p t -> AcquireLockResult -> P.IO ()
write_AcquireLockResult oprot record = T.writeVal oprot $ from_AcquireLockResult record
encode_AcquireLockResult :: (T.Protocol p, T.Transport t) => p t -> AcquireLockResult -> LBS.ByteString
encode_AcquireLockResult oprot record = T.serializeVal oprot $ from_AcquireLockResult record
to_AcquireLockResult :: T.ThriftVal -> AcquireLockResult
to_AcquireLockResult (T.TStruct fields) = AcquireLockResult{
  acquireLockResult_lock = P.maybe (acquireLockResult_lock default_AcquireLockResult) (\(_,_val287) -> (case _val287 of {T.TStruct _val288 -> (to_Lock (T.TStruct _val288)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireLockResult _ = P.error "not a struct"
read_AcquireLockResult :: (T.Transport t, T.Protocol p) => p t -> P.IO AcquireLockResult
read_AcquireLockResult iprot = to_AcquireLockResult <$> T.readVal iprot (T.T_STRUCT typemap_AcquireLockResult)
decode_AcquireLockResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AcquireLockResult
decode_AcquireLockResult iprot bs = to_AcquireLockResult $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireLockResult) bs
typemap_AcquireLockResult :: T.TypeMap
typemap_AcquireLockResult = Map.fromList [(1,("lock",(T.T_STRUCT typemap_Lock)))]
default_AcquireLockResult :: AcquireLockResult
default_AcquireLockResult = AcquireLockResult{
  acquireLockResult_lock = default_Lock}
data TaskEvent = TaskEvent  { taskEvent_timestamp :: I.Int64
  , taskEvent_status :: ScheduleStatus
  , taskEvent_message :: P.Maybe LT.Text
  , taskEvent_scheduler :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable TaskEvent where
  hashWithSalt salt record = salt   `H.hashWithSalt` taskEvent_timestamp record   `H.hashWithSalt` taskEvent_status record   `H.hashWithSalt` taskEvent_message record   `H.hashWithSalt` taskEvent_scheduler record  
instance QC.Arbitrary TaskEvent where 
  arbitrary = M.liftM TaskEvent (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TaskEvent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TaskEvent{taskEvent_timestamp = taskEvent_timestamp obj} then P.Nothing else P.Just $ default_TaskEvent{taskEvent_timestamp = taskEvent_timestamp obj}
    , if obj == default_TaskEvent{taskEvent_status = taskEvent_status obj} then P.Nothing else P.Just $ default_TaskEvent{taskEvent_status = taskEvent_status obj}
    , if obj == default_TaskEvent{taskEvent_message = taskEvent_message obj} then P.Nothing else P.Just $ default_TaskEvent{taskEvent_message = taskEvent_message obj}
    , if obj == default_TaskEvent{taskEvent_scheduler = taskEvent_scheduler obj} then P.Nothing else P.Just $ default_TaskEvent{taskEvent_scheduler = taskEvent_scheduler obj}
    ]
from_TaskEvent :: TaskEvent -> T.ThriftVal
from_TaskEvent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v291 -> P.Just (1, ("timestamp",T.TI64 _v291))) $ taskEvent_timestamp record
  , (\_v291 -> P.Just (2, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v291))) $ taskEvent_status record
  , (\_v291 -> (3, ("message",T.TString $ E.encodeUtf8 _v291))) <$> taskEvent_message record
  , (\_v291 -> (4, ("scheduler",T.TString $ E.encodeUtf8 _v291))) <$> taskEvent_scheduler record
  ]
write_TaskEvent :: (T.Protocol p, T.Transport t) => p t -> TaskEvent -> P.IO ()
write_TaskEvent oprot record = T.writeVal oprot $ from_TaskEvent record
encode_TaskEvent :: (T.Protocol p, T.Transport t) => p t -> TaskEvent -> LBS.ByteString
encode_TaskEvent oprot record = T.serializeVal oprot $ from_TaskEvent record
to_TaskEvent :: T.ThriftVal -> TaskEvent
to_TaskEvent (T.TStruct fields) = TaskEvent{
  taskEvent_timestamp = P.maybe (taskEvent_timestamp default_TaskEvent) (\(_,_val293) -> (case _val293 of {T.TI64 _val294 -> _val294; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  taskEvent_status = P.maybe (taskEvent_status default_TaskEvent) (\(_,_val293) -> (case _val293 of {T.TI32 _val295 -> P.toEnum $ P.fromIntegral _val295; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  taskEvent_message = P.maybe (P.Nothing) (\(_,_val293) -> P.Just (case _val293 of {T.TString _val296 -> E.decodeUtf8 _val296; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  taskEvent_scheduler = P.maybe (P.Nothing) (\(_,_val293) -> P.Just (case _val293 of {T.TString _val297 -> E.decodeUtf8 _val297; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TaskEvent _ = P.error "not a struct"
read_TaskEvent :: (T.Transport t, T.Protocol p) => p t -> P.IO TaskEvent
read_TaskEvent iprot = to_TaskEvent <$> T.readVal iprot (T.T_STRUCT typemap_TaskEvent)
decode_TaskEvent :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TaskEvent
decode_TaskEvent iprot bs = to_TaskEvent $ T.deserializeVal iprot (T.T_STRUCT typemap_TaskEvent) bs
typemap_TaskEvent :: T.TypeMap
typemap_TaskEvent = Map.fromList [(1,("timestamp",T.T_I64)),(2,("status",T.T_I32)),(3,("message",T.T_STRING)),(4,("scheduler",T.T_STRING))]
default_TaskEvent :: TaskEvent
default_TaskEvent = TaskEvent{
  taskEvent_timestamp = 0,
  taskEvent_status = (P.toEnum 0),
  taskEvent_message = P.Nothing,
  taskEvent_scheduler = P.Nothing}
data AssignedTask = AssignedTask  { assignedTask_taskId :: LT.Text
  , assignedTask_slaveId :: LT.Text
  , assignedTask_slaveHost :: LT.Text
  , assignedTask_task :: TaskConfig
  , assignedTask_assignedPorts :: (Map.HashMap LT.Text I.Int32)
  , assignedTask_instanceId :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AssignedTask where
  hashWithSalt salt record = salt   `H.hashWithSalt` assignedTask_taskId record   `H.hashWithSalt` assignedTask_slaveId record   `H.hashWithSalt` assignedTask_slaveHost record   `H.hashWithSalt` assignedTask_task record   `H.hashWithSalt` assignedTask_assignedPorts record   `H.hashWithSalt` assignedTask_instanceId record  
instance QC.Arbitrary AssignedTask where 
  arbitrary = M.liftM AssignedTask (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AssignedTask = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AssignedTask{assignedTask_taskId = assignedTask_taskId obj} then P.Nothing else P.Just $ default_AssignedTask{assignedTask_taskId = assignedTask_taskId obj}
    , if obj == default_AssignedTask{assignedTask_slaveId = assignedTask_slaveId obj} then P.Nothing else P.Just $ default_AssignedTask{assignedTask_slaveId = assignedTask_slaveId obj}
    , if obj == default_AssignedTask{assignedTask_slaveHost = assignedTask_slaveHost obj} then P.Nothing else P.Just $ default_AssignedTask{assignedTask_slaveHost = assignedTask_slaveHost obj}
    , if obj == default_AssignedTask{assignedTask_task = assignedTask_task obj} then P.Nothing else P.Just $ default_AssignedTask{assignedTask_task = assignedTask_task obj}
    , if obj == default_AssignedTask{assignedTask_assignedPorts = assignedTask_assignedPorts obj} then P.Nothing else P.Just $ default_AssignedTask{assignedTask_assignedPorts = assignedTask_assignedPorts obj}
    , if obj == default_AssignedTask{assignedTask_instanceId = assignedTask_instanceId obj} then P.Nothing else P.Just $ default_AssignedTask{assignedTask_instanceId = assignedTask_instanceId obj}
    ]
from_AssignedTask :: AssignedTask -> T.ThriftVal
from_AssignedTask record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v300 -> P.Just (1, ("taskId",T.TString $ E.encodeUtf8 _v300))) $ assignedTask_taskId record
  , (\_v300 -> P.Just (2, ("slaveId",T.TString $ E.encodeUtf8 _v300))) $ assignedTask_slaveId record
  , (\_v300 -> P.Just (3, ("slaveHost",T.TString $ E.encodeUtf8 _v300))) $ assignedTask_slaveHost record
  , (\_v300 -> P.Just (4, ("task",from_TaskConfig _v300))) $ assignedTask_task record
  , (\_v300 -> P.Just (5, ("assignedPorts",T.TMap T.T_STRING T.T_I32 $ P.map (\(_k301,_v302) -> (T.TString $ E.encodeUtf8 _k301, T.TI32 _v302)) $ Map.toList _v300))) $ assignedTask_assignedPorts record
  , (\_v300 -> P.Just (6, ("instanceId",T.TI32 _v300))) $ assignedTask_instanceId record
  ]
write_AssignedTask :: (T.Protocol p, T.Transport t) => p t -> AssignedTask -> P.IO ()
write_AssignedTask oprot record = T.writeVal oprot $ from_AssignedTask record
encode_AssignedTask :: (T.Protocol p, T.Transport t) => p t -> AssignedTask -> LBS.ByteString
encode_AssignedTask oprot record = T.serializeVal oprot $ from_AssignedTask record
to_AssignedTask :: T.ThriftVal -> AssignedTask
to_AssignedTask (T.TStruct fields) = AssignedTask{
  assignedTask_taskId = P.maybe (assignedTask_taskId default_AssignedTask) (\(_,_val304) -> (case _val304 of {T.TString _val305 -> E.decodeUtf8 _val305; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  assignedTask_slaveId = P.maybe (assignedTask_slaveId default_AssignedTask) (\(_,_val304) -> (case _val304 of {T.TString _val306 -> E.decodeUtf8 _val306; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  assignedTask_slaveHost = P.maybe (assignedTask_slaveHost default_AssignedTask) (\(_,_val304) -> (case _val304 of {T.TString _val307 -> E.decodeUtf8 _val307; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  assignedTask_task = P.maybe (assignedTask_task default_AssignedTask) (\(_,_val304) -> (case _val304 of {T.TStruct _val308 -> (to_TaskConfig (T.TStruct _val308)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  assignedTask_assignedPorts = P.maybe (assignedTask_assignedPorts default_AssignedTask) (\(_,_val304) -> (case _val304 of {T.TMap _ _ _val309 -> (Map.fromList $ P.map (\(_k311,_v310) -> ((case _k311 of {T.TString _val312 -> E.decodeUtf8 _val312; _ -> P.error "wrong type"}),(case _v310 of {T.TI32 _val313 -> _val313; _ -> P.error "wrong type"}))) _val309); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  assignedTask_instanceId = P.maybe (assignedTask_instanceId default_AssignedTask) (\(_,_val304) -> (case _val304 of {T.TI32 _val314 -> _val314; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_AssignedTask _ = P.error "not a struct"
read_AssignedTask :: (T.Transport t, T.Protocol p) => p t -> P.IO AssignedTask
read_AssignedTask iprot = to_AssignedTask <$> T.readVal iprot (T.T_STRUCT typemap_AssignedTask)
decode_AssignedTask :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AssignedTask
decode_AssignedTask iprot bs = to_AssignedTask $ T.deserializeVal iprot (T.T_STRUCT typemap_AssignedTask) bs
typemap_AssignedTask :: T.TypeMap
typemap_AssignedTask = Map.fromList [(1,("taskId",T.T_STRING)),(2,("slaveId",T.T_STRING)),(3,("slaveHost",T.T_STRING)),(4,("task",(T.T_STRUCT typemap_TaskConfig))),(5,("assignedPorts",(T.T_MAP T.T_STRING T.T_I32))),(6,("instanceId",T.T_I32))]
default_AssignedTask :: AssignedTask
default_AssignedTask = AssignedTask{
  assignedTask_taskId = "",
  assignedTask_slaveId = "",
  assignedTask_slaveHost = "",
  assignedTask_task = default_TaskConfig,
  assignedTask_assignedPorts = Map.empty,
  assignedTask_instanceId = 0}
data ScheduledTask = ScheduledTask  { scheduledTask_assignedTask :: AssignedTask
  , scheduledTask_status :: ScheduleStatus
  , scheduledTask_failureCount :: I.Int32
  , scheduledTask_taskEvents :: (Vector.Vector TaskEvent)
  , scheduledTask_ancestorId :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ScheduledTask where
  hashWithSalt salt record = salt   `H.hashWithSalt` scheduledTask_assignedTask record   `H.hashWithSalt` scheduledTask_status record   `H.hashWithSalt` scheduledTask_failureCount record   `H.hashWithSalt` scheduledTask_taskEvents record   `H.hashWithSalt` scheduledTask_ancestorId record  
instance QC.Arbitrary ScheduledTask where 
  arbitrary = M.liftM ScheduledTask (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ScheduledTask = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ScheduledTask{scheduledTask_assignedTask = scheduledTask_assignedTask obj} then P.Nothing else P.Just $ default_ScheduledTask{scheduledTask_assignedTask = scheduledTask_assignedTask obj}
    , if obj == default_ScheduledTask{scheduledTask_status = scheduledTask_status obj} then P.Nothing else P.Just $ default_ScheduledTask{scheduledTask_status = scheduledTask_status obj}
    , if obj == default_ScheduledTask{scheduledTask_failureCount = scheduledTask_failureCount obj} then P.Nothing else P.Just $ default_ScheduledTask{scheduledTask_failureCount = scheduledTask_failureCount obj}
    , if obj == default_ScheduledTask{scheduledTask_taskEvents = scheduledTask_taskEvents obj} then P.Nothing else P.Just $ default_ScheduledTask{scheduledTask_taskEvents = scheduledTask_taskEvents obj}
    , if obj == default_ScheduledTask{scheduledTask_ancestorId = scheduledTask_ancestorId obj} then P.Nothing else P.Just $ default_ScheduledTask{scheduledTask_ancestorId = scheduledTask_ancestorId obj}
    ]
from_ScheduledTask :: ScheduledTask -> T.ThriftVal
from_ScheduledTask record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v317 -> P.Just (1, ("assignedTask",from_AssignedTask _v317))) $ scheduledTask_assignedTask record
  , (\_v317 -> P.Just (2, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v317))) $ scheduledTask_status record
  , (\_v317 -> P.Just (3, ("failureCount",T.TI32 _v317))) $ scheduledTask_failureCount record
  , (\_v317 -> P.Just (4, ("taskEvents",T.TList (T.T_STRUCT typemap_TaskEvent) $ P.map (\_v319 -> from_TaskEvent _v319) $ Vector.toList _v317))) $ scheduledTask_taskEvents record
  , (\_v317 -> P.Just (5, ("ancestorId",T.TString $ E.encodeUtf8 _v317))) $ scheduledTask_ancestorId record
  ]
write_ScheduledTask :: (T.Protocol p, T.Transport t) => p t -> ScheduledTask -> P.IO ()
write_ScheduledTask oprot record = T.writeVal oprot $ from_ScheduledTask record
encode_ScheduledTask :: (T.Protocol p, T.Transport t) => p t -> ScheduledTask -> LBS.ByteString
encode_ScheduledTask oprot record = T.serializeVal oprot $ from_ScheduledTask record
to_ScheduledTask :: T.ThriftVal -> ScheduledTask
to_ScheduledTask (T.TStruct fields) = ScheduledTask{
  scheduledTask_assignedTask = P.maybe (scheduledTask_assignedTask default_ScheduledTask) (\(_,_val321) -> (case _val321 of {T.TStruct _val322 -> (to_AssignedTask (T.TStruct _val322)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  scheduledTask_status = P.maybe (scheduledTask_status default_ScheduledTask) (\(_,_val321) -> (case _val321 of {T.TI32 _val323 -> P.toEnum $ P.fromIntegral _val323; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  scheduledTask_failureCount = P.maybe (scheduledTask_failureCount default_ScheduledTask) (\(_,_val321) -> (case _val321 of {T.TI32 _val324 -> _val324; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  scheduledTask_taskEvents = P.maybe (scheduledTask_taskEvents default_ScheduledTask) (\(_,_val321) -> (case _val321 of {T.TList _ _val325 -> (Vector.fromList $ P.map (\_v326 -> (case _v326 of {T.TStruct _val327 -> (to_TaskEvent (T.TStruct _val327)); _ -> P.error "wrong type"})) _val325); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  scheduledTask_ancestorId = P.maybe (scheduledTask_ancestorId default_ScheduledTask) (\(_,_val321) -> (case _val321 of {T.TString _val328 -> E.decodeUtf8 _val328; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ScheduledTask _ = P.error "not a struct"
read_ScheduledTask :: (T.Transport t, T.Protocol p) => p t -> P.IO ScheduledTask
read_ScheduledTask iprot = to_ScheduledTask <$> T.readVal iprot (T.T_STRUCT typemap_ScheduledTask)
decode_ScheduledTask :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ScheduledTask
decode_ScheduledTask iprot bs = to_ScheduledTask $ T.deserializeVal iprot (T.T_STRUCT typemap_ScheduledTask) bs
typemap_ScheduledTask :: T.TypeMap
typemap_ScheduledTask = Map.fromList [(1,("assignedTask",(T.T_STRUCT typemap_AssignedTask))),(2,("status",T.T_I32)),(3,("failureCount",T.T_I32)),(4,("taskEvents",(T.T_LIST (T.T_STRUCT typemap_TaskEvent)))),(5,("ancestorId",T.T_STRING))]
default_ScheduledTask :: ScheduledTask
default_ScheduledTask = ScheduledTask{
  scheduledTask_assignedTask = default_AssignedTask,
  scheduledTask_status = (P.toEnum 0),
  scheduledTask_failureCount = 0,
  scheduledTask_taskEvents = Vector.empty,
  scheduledTask_ancestorId = ""}
data ScheduleStatusResult = ScheduleStatusResult  { scheduleStatusResult_tasks :: (Vector.Vector ScheduledTask)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ScheduleStatusResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` scheduleStatusResult_tasks record  
instance QC.Arbitrary ScheduleStatusResult where 
  arbitrary = M.liftM ScheduleStatusResult (QC.arbitrary)
  shrink obj | obj == default_ScheduleStatusResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ScheduleStatusResult{scheduleStatusResult_tasks = scheduleStatusResult_tasks obj} then P.Nothing else P.Just $ default_ScheduleStatusResult{scheduleStatusResult_tasks = scheduleStatusResult_tasks obj}
    ]
from_ScheduleStatusResult :: ScheduleStatusResult -> T.ThriftVal
from_ScheduleStatusResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v331 -> P.Just (1, ("tasks",T.TList (T.T_STRUCT typemap_ScheduledTask) $ P.map (\_v333 -> from_ScheduledTask _v333) $ Vector.toList _v331))) $ scheduleStatusResult_tasks record
  ]
write_ScheduleStatusResult :: (T.Protocol p, T.Transport t) => p t -> ScheduleStatusResult -> P.IO ()
write_ScheduleStatusResult oprot record = T.writeVal oprot $ from_ScheduleStatusResult record
encode_ScheduleStatusResult :: (T.Protocol p, T.Transport t) => p t -> ScheduleStatusResult -> LBS.ByteString
encode_ScheduleStatusResult oprot record = T.serializeVal oprot $ from_ScheduleStatusResult record
to_ScheduleStatusResult :: T.ThriftVal -> ScheduleStatusResult
to_ScheduleStatusResult (T.TStruct fields) = ScheduleStatusResult{
  scheduleStatusResult_tasks = P.maybe (scheduleStatusResult_tasks default_ScheduleStatusResult) (\(_,_val335) -> (case _val335 of {T.TList _ _val336 -> (Vector.fromList $ P.map (\_v337 -> (case _v337 of {T.TStruct _val338 -> (to_ScheduledTask (T.TStruct _val338)); _ -> P.error "wrong type"})) _val336); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ScheduleStatusResult _ = P.error "not a struct"
read_ScheduleStatusResult :: (T.Transport t, T.Protocol p) => p t -> P.IO ScheduleStatusResult
read_ScheduleStatusResult iprot = to_ScheduleStatusResult <$> T.readVal iprot (T.T_STRUCT typemap_ScheduleStatusResult)
decode_ScheduleStatusResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ScheduleStatusResult
decode_ScheduleStatusResult iprot bs = to_ScheduleStatusResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ScheduleStatusResult) bs
typemap_ScheduleStatusResult :: T.TypeMap
typemap_ScheduleStatusResult = Map.fromList [(1,("tasks",(T.T_LIST (T.T_STRUCT typemap_ScheduledTask))))]
default_ScheduleStatusResult :: ScheduleStatusResult
default_ScheduleStatusResult = ScheduleStatusResult{
  scheduleStatusResult_tasks = Vector.empty}
data GetJobsResult = GetJobsResult  { getJobsResult_configs :: (Set.HashSet JobConfiguration)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobsResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobsResult_configs record  
instance QC.Arbitrary GetJobsResult where 
  arbitrary = M.liftM GetJobsResult (QC.arbitrary)
  shrink obj | obj == default_GetJobsResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobsResult{getJobsResult_configs = getJobsResult_configs obj} then P.Nothing else P.Just $ default_GetJobsResult{getJobsResult_configs = getJobsResult_configs obj}
    ]
from_GetJobsResult :: GetJobsResult -> T.ThriftVal
from_GetJobsResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v341 -> P.Just (1, ("configs",T.TSet (T.T_STRUCT typemap_JobConfiguration) $ P.map (\_v343 -> from_JobConfiguration _v343) $ Set.toList _v341))) $ getJobsResult_configs record
  ]
write_GetJobsResult :: (T.Protocol p, T.Transport t) => p t -> GetJobsResult -> P.IO ()
write_GetJobsResult oprot record = T.writeVal oprot $ from_GetJobsResult record
encode_GetJobsResult :: (T.Protocol p, T.Transport t) => p t -> GetJobsResult -> LBS.ByteString
encode_GetJobsResult oprot record = T.serializeVal oprot $ from_GetJobsResult record
to_GetJobsResult :: T.ThriftVal -> GetJobsResult
to_GetJobsResult (T.TStruct fields) = GetJobsResult{
  getJobsResult_configs = P.maybe (getJobsResult_configs default_GetJobsResult) (\(_,_val345) -> (case _val345 of {T.TSet _ _val346 -> (Set.fromList $ P.map (\_v347 -> (case _v347 of {T.TStruct _val348 -> (to_JobConfiguration (T.TStruct _val348)); _ -> P.error "wrong type"})) _val346); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobsResult _ = P.error "not a struct"
read_GetJobsResult :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobsResult
read_GetJobsResult iprot = to_GetJobsResult <$> T.readVal iprot (T.T_STRUCT typemap_GetJobsResult)
decode_GetJobsResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobsResult
decode_GetJobsResult iprot bs = to_GetJobsResult $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobsResult) bs
typemap_GetJobsResult :: T.TypeMap
typemap_GetJobsResult = Map.fromList [(1,("configs",(T.T_SET (T.T_STRUCT typemap_JobConfiguration))))]
default_GetJobsResult :: GetJobsResult
default_GetJobsResult = GetJobsResult{
  getJobsResult_configs = Set.empty}
data TaskQuery = TaskQuery  { taskQuery_owner :: P.Maybe Identity
  , taskQuery_role :: P.Maybe LT.Text
  , taskQuery_environment :: P.Maybe LT.Text
  , taskQuery_jobName :: P.Maybe LT.Text
  , taskQuery_taskIds :: P.Maybe (Set.HashSet LT.Text)
  , taskQuery_statuses :: P.Maybe (Set.HashSet ScheduleStatus)
  , taskQuery_instanceIds :: P.Maybe (Set.HashSet I.Int32)
  , taskQuery_slaveHosts :: P.Maybe (Set.HashSet LT.Text)
  , taskQuery_jobKeys :: P.Maybe (Set.HashSet JobKey)
  , taskQuery_offset :: P.Maybe I.Int32
  , taskQuery_limit :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable TaskQuery where
  hashWithSalt salt record = salt   `H.hashWithSalt` taskQuery_owner record   `H.hashWithSalt` taskQuery_role record   `H.hashWithSalt` taskQuery_environment record   `H.hashWithSalt` taskQuery_jobName record   `H.hashWithSalt` taskQuery_taskIds record   `H.hashWithSalt` taskQuery_statuses record   `H.hashWithSalt` taskQuery_instanceIds record   `H.hashWithSalt` taskQuery_slaveHosts record   `H.hashWithSalt` taskQuery_jobKeys record   `H.hashWithSalt` taskQuery_offset record   `H.hashWithSalt` taskQuery_limit record  
instance QC.Arbitrary TaskQuery where 
  arbitrary = M.liftM TaskQuery (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TaskQuery = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TaskQuery{taskQuery_owner = taskQuery_owner obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_owner = taskQuery_owner obj}
    , if obj == default_TaskQuery{taskQuery_role = taskQuery_role obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_role = taskQuery_role obj}
    , if obj == default_TaskQuery{taskQuery_environment = taskQuery_environment obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_environment = taskQuery_environment obj}
    , if obj == default_TaskQuery{taskQuery_jobName = taskQuery_jobName obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_jobName = taskQuery_jobName obj}
    , if obj == default_TaskQuery{taskQuery_taskIds = taskQuery_taskIds obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_taskIds = taskQuery_taskIds obj}
    , if obj == default_TaskQuery{taskQuery_statuses = taskQuery_statuses obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_statuses = taskQuery_statuses obj}
    , if obj == default_TaskQuery{taskQuery_instanceIds = taskQuery_instanceIds obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_instanceIds = taskQuery_instanceIds obj}
    , if obj == default_TaskQuery{taskQuery_slaveHosts = taskQuery_slaveHosts obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_slaveHosts = taskQuery_slaveHosts obj}
    , if obj == default_TaskQuery{taskQuery_jobKeys = taskQuery_jobKeys obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_jobKeys = taskQuery_jobKeys obj}
    , if obj == default_TaskQuery{taskQuery_offset = taskQuery_offset obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_offset = taskQuery_offset obj}
    , if obj == default_TaskQuery{taskQuery_limit = taskQuery_limit obj} then P.Nothing else P.Just $ default_TaskQuery{taskQuery_limit = taskQuery_limit obj}
    ]
from_TaskQuery :: TaskQuery -> T.ThriftVal
from_TaskQuery record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v351 -> (2, ("jobName",T.TString $ E.encodeUtf8 _v351))) <$> taskQuery_jobName record
  , (\_v351 -> (4, ("taskIds",T.TSet T.T_STRING $ P.map (\_v353 -> T.TString $ E.encodeUtf8 _v353) $ Set.toList _v351))) <$>  taskQuery_taskIds record
  , (\_v351 -> (5, ("statuses",T.TSet T.T_I32 $ P.map (\_v355 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v355) $ Set.toList _v351))) <$> taskQuery_statuses record
  , (\_v351 -> (7, ("instanceIds",T.TSet T.T_I32 $ P.map (\_v357 -> T.TI32 _v357) $ Set.toList _v351))) <$> taskQuery_instanceIds record
  , (\_v351 -> (8, ("owner",from_Identity _v351))) <$> taskQuery_owner record
  , (\_v351 -> (9, ("environment",T.TString $ E.encodeUtf8 _v351))) <$> taskQuery_environment record
  , (\_v351 -> (10, ("slaveHosts",T.TSet T.T_STRING $ P.map (\_v359 -> T.TString $ E.encodeUtf8 _v359) $ Set.toList _v351))) <$> taskQuery_slaveHosts record
  , (\_v351 -> (11, ("jobKeys",T.TSet (T.T_STRUCT typemap_JobKey) $ P.map (\_v361 -> from_JobKey _v361) $ Set.toList _v351))) <$> taskQuery_jobKeys record
  , (\_v351 -> (12, ("offset",T.TI32 _v351))) <$> taskQuery_offset record
  , (\_v351 -> (13, ("limit",T.TI32 _v351))) <$> taskQuery_limit record
  , (\_v351 -> (14, ("role",T.TString $ E.encodeUtf8 _v351))) <$> taskQuery_role record
  ]
write_TaskQuery :: (T.Protocol p, T.Transport t) => p t -> TaskQuery -> P.IO ()
write_TaskQuery oprot record = T.writeVal oprot $ from_TaskQuery record
encode_TaskQuery :: (T.Protocol p, T.Transport t) => p t -> TaskQuery -> LBS.ByteString
encode_TaskQuery oprot record = T.serializeVal oprot $ from_TaskQuery record
to_TaskQuery :: T.ThriftVal -> TaskQuery
to_TaskQuery (T.TStruct fields) = TaskQuery{
  taskQuery_owner = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TStruct _val364 -> (P.Just $ to_Identity (T.TStruct _val364)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  taskQuery_role = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TString _val365 -> P.Just $ E.decodeUtf8 _val365; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  taskQuery_environment = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TString _val366 -> P.Just $ E.decodeUtf8 _val366; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  taskQuery_jobName = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TString _val367 -> P.Just $ E.decodeUtf8 _val367; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  taskQuery_taskIds = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TSet _ _val368 -> P.Just $ (Set.fromList $ P.map (\_v369 -> (case _v369 of {T.TString _val370 -> E.decodeUtf8 _val370; _ -> P.error "wrong type"})) _val368); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  taskQuery_statuses = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TSet _ _val371 -> P.Just $ (Set.fromList $ P.map (\_v372 -> (case _v372 of {T.TI32 _val373 -> P.toEnum $ P.fromIntegral _val373; _ -> P.error "wrong type"})) _val371); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  taskQuery_instanceIds = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TSet _ _val374 -> P.Just $ (Set.fromList $ P.map (\_v375 -> (case _v375 of {T.TI32 _val376 -> _val376; _ -> P.error "wrong type"})) _val374); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  taskQuery_slaveHosts = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TSet _ _val377 -> P.Just $ (Set.fromList $ P.map (\_v378 -> (case _v378 of {T.TString _val379 -> E.decodeUtf8 _val379; _ -> P.error "wrong type"})) _val377); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  taskQuery_jobKeys = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TSet _ _val380 -> P.Just $ (Set.fromList $ P.map (\_v381 -> (case _v381 of {T.TStruct _val382 -> (to_JobKey (T.TStruct _val382)); _ -> P.error "wrong type"})) _val380); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  taskQuery_offset = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TI32 _val383 -> P.Just _val383; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  taskQuery_limit = P.maybe (P.Nothing) (\(_,_val363) -> (case _val363 of {T.TI32 _val384 -> P.Just _val384; _ -> P.error "wrong type"})) (Map.lookup (13) fields)
  }
to_TaskQuery _ = P.error "not a struct"
read_TaskQuery :: (T.Transport t, T.Protocol p) => p t -> P.IO TaskQuery
read_TaskQuery iprot = to_TaskQuery <$> T.readVal iprot (T.T_STRUCT typemap_TaskQuery)
decode_TaskQuery :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TaskQuery
decode_TaskQuery iprot bs = to_TaskQuery $ T.deserializeVal iprot (T.T_STRUCT typemap_TaskQuery) bs
typemap_TaskQuery :: T.TypeMap
typemap_TaskQuery = Map.fromList [(2,("jobName",T.T_STRING)),(4,("taskIds",(T.T_SET T.T_STRING))),(5,("statuses",(T.T_SET T.T_I32))),(7,("instanceIds",(T.T_SET T.T_I32))),(8,("owner",(T.T_STRUCT typemap_Identity))),(9,("environment",T.T_STRING)),(10,("slaveHosts",(T.T_SET T.T_STRING))),(11,("jobKeys",(T.T_SET (T.T_STRUCT typemap_JobKey)))),(12,("offset",T.T_I32)),(13,("limit",T.T_I32)),(14,("role",T.T_STRING))]
default_TaskQuery :: TaskQuery
default_TaskQuery = TaskQuery{
  taskQuery_jobName = P.Nothing,
  taskQuery_taskIds = P.Nothing,
  taskQuery_statuses = P.Nothing,
  taskQuery_instanceIds = P.Nothing,
  taskQuery_owner = P.Nothing,
  taskQuery_environment = P.Nothing,
  taskQuery_slaveHosts = P.Nothing,
  taskQuery_jobKeys = P.Nothing,
  taskQuery_offset = P.Nothing,
  taskQuery_limit =P.Nothing,
  taskQuery_role = P.Nothing}
data HostStatus = HostStatus  { hostStatus_host :: LT.Text
  , hostStatus_mode :: MaintenanceMode
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable HostStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` hostStatus_host record   `H.hashWithSalt` hostStatus_mode record  
instance QC.Arbitrary HostStatus where 
  arbitrary = M.liftM HostStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_HostStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_HostStatus{hostStatus_host = hostStatus_host obj} then P.Nothing else P.Just $ default_HostStatus{hostStatus_host = hostStatus_host obj}
    , if obj == default_HostStatus{hostStatus_mode = hostStatus_mode obj} then P.Nothing else P.Just $ default_HostStatus{hostStatus_mode = hostStatus_mode obj}
    ]
from_HostStatus :: HostStatus -> T.ThriftVal
from_HostStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v387 -> P.Just (1, ("host",T.TString $ E.encodeUtf8 _v387))) $ hostStatus_host record
  , (\_v387 -> P.Just (2, ("mode",T.TI32 $ P.fromIntegral $ P.fromEnum _v387))) $ hostStatus_mode record
  ]
write_HostStatus :: (T.Protocol p, T.Transport t) => p t -> HostStatus -> P.IO ()
write_HostStatus oprot record = T.writeVal oprot $ from_HostStatus record
encode_HostStatus :: (T.Protocol p, T.Transport t) => p t -> HostStatus -> LBS.ByteString
encode_HostStatus oprot record = T.serializeVal oprot $ from_HostStatus record
to_HostStatus :: T.ThriftVal -> HostStatus
to_HostStatus (T.TStruct fields) = HostStatus{
  hostStatus_host = P.maybe (hostStatus_host default_HostStatus) (\(_,_val389) -> (case _val389 of {T.TString _val390 -> E.decodeUtf8 _val390; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  hostStatus_mode = P.maybe (hostStatus_mode default_HostStatus) (\(_,_val389) -> (case _val389 of {T.TI32 _val391 -> P.toEnum $ P.fromIntegral _val391; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_HostStatus _ = P.error "not a struct"
read_HostStatus :: (T.Transport t, T.Protocol p) => p t -> P.IO HostStatus
read_HostStatus iprot = to_HostStatus <$> T.readVal iprot (T.T_STRUCT typemap_HostStatus)
decode_HostStatus :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> HostStatus
decode_HostStatus iprot bs = to_HostStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_HostStatus) bs
typemap_HostStatus :: T.TypeMap
typemap_HostStatus = Map.fromList [(1,("host",T.T_STRING)),(2,("mode",T.T_I32))]
default_HostStatus :: HostStatus
default_HostStatus = HostStatus{
  hostStatus_host = "",
  hostStatus_mode = (P.toEnum 0)}
data RoleSummary = RoleSummary  { roleSummary_role :: LT.Text
  , roleSummary_jobCount :: I.Int32
  , roleSummary_cronJobCount :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RoleSummary where
  hashWithSalt salt record = salt   `H.hashWithSalt` roleSummary_role record   `H.hashWithSalt` roleSummary_jobCount record   `H.hashWithSalt` roleSummary_cronJobCount record  
instance QC.Arbitrary RoleSummary where 
  arbitrary = M.liftM RoleSummary (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RoleSummary = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RoleSummary{roleSummary_role = roleSummary_role obj} then P.Nothing else P.Just $ default_RoleSummary{roleSummary_role = roleSummary_role obj}
    , if obj == default_RoleSummary{roleSummary_jobCount = roleSummary_jobCount obj} then P.Nothing else P.Just $ default_RoleSummary{roleSummary_jobCount = roleSummary_jobCount obj}
    , if obj == default_RoleSummary{roleSummary_cronJobCount = roleSummary_cronJobCount obj} then P.Nothing else P.Just $ default_RoleSummary{roleSummary_cronJobCount = roleSummary_cronJobCount obj}
    ]
from_RoleSummary :: RoleSummary -> T.ThriftVal
from_RoleSummary record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v394 -> P.Just (1, ("role",T.TString $ E.encodeUtf8 _v394))) $ roleSummary_role record
  , (\_v394 -> P.Just (2, ("jobCount",T.TI32 _v394))) $ roleSummary_jobCount record
  , (\_v394 -> P.Just (3, ("cronJobCount",T.TI32 _v394))) $ roleSummary_cronJobCount record
  ]
write_RoleSummary :: (T.Protocol p, T.Transport t) => p t -> RoleSummary -> P.IO ()
write_RoleSummary oprot record = T.writeVal oprot $ from_RoleSummary record
encode_RoleSummary :: (T.Protocol p, T.Transport t) => p t -> RoleSummary -> LBS.ByteString
encode_RoleSummary oprot record = T.serializeVal oprot $ from_RoleSummary record
to_RoleSummary :: T.ThriftVal -> RoleSummary
to_RoleSummary (T.TStruct fields) = RoleSummary{
  roleSummary_role = P.maybe (roleSummary_role default_RoleSummary) (\(_,_val396) -> (case _val396 of {T.TString _val397 -> E.decodeUtf8 _val397; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  roleSummary_jobCount = P.maybe (roleSummary_jobCount default_RoleSummary) (\(_,_val396) -> (case _val396 of {T.TI32 _val398 -> _val398; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  roleSummary_cronJobCount = P.maybe (roleSummary_cronJobCount default_RoleSummary) (\(_,_val396) -> (case _val396 of {T.TI32 _val399 -> _val399; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RoleSummary _ = P.error "not a struct"
read_RoleSummary :: (T.Transport t, T.Protocol p) => p t -> P.IO RoleSummary
read_RoleSummary iprot = to_RoleSummary <$> T.readVal iprot (T.T_STRUCT typemap_RoleSummary)
decode_RoleSummary :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RoleSummary
decode_RoleSummary iprot bs = to_RoleSummary $ T.deserializeVal iprot (T.T_STRUCT typemap_RoleSummary) bs
typemap_RoleSummary :: T.TypeMap
typemap_RoleSummary = Map.fromList [(1,("role",T.T_STRING)),(2,("jobCount",T.T_I32)),(3,("cronJobCount",T.T_I32))]
default_RoleSummary :: RoleSummary
default_RoleSummary = RoleSummary{
  roleSummary_role = "",
  roleSummary_jobCount = 0,
  roleSummary_cronJobCount = 0}
data Hosts = Hosts  { hosts_hostNames :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Hosts where
  hashWithSalt salt record = salt   `H.hashWithSalt` hosts_hostNames record  
instance QC.Arbitrary Hosts where 
  arbitrary = M.liftM Hosts (QC.arbitrary)
  shrink obj | obj == default_Hosts = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Hosts{hosts_hostNames = hosts_hostNames obj} then P.Nothing else P.Just $ default_Hosts{hosts_hostNames = hosts_hostNames obj}
    ]
from_Hosts :: Hosts -> T.ThriftVal
from_Hosts record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v402 -> P.Just (1, ("hostNames",T.TSet T.T_STRING $ P.map (\_v404 -> T.TString $ E.encodeUtf8 _v404) $ Set.toList _v402))) $ hosts_hostNames record
  ]
write_Hosts :: (T.Protocol p, T.Transport t) => p t -> Hosts -> P.IO ()
write_Hosts oprot record = T.writeVal oprot $ from_Hosts record
encode_Hosts :: (T.Protocol p, T.Transport t) => p t -> Hosts -> LBS.ByteString
encode_Hosts oprot record = T.serializeVal oprot $ from_Hosts record
to_Hosts :: T.ThriftVal -> Hosts
to_Hosts (T.TStruct fields) = Hosts{
  hosts_hostNames = P.maybe (hosts_hostNames default_Hosts) (\(_,_val406) -> (case _val406 of {T.TSet _ _val407 -> (Set.fromList $ P.map (\_v408 -> (case _v408 of {T.TString _val409 -> E.decodeUtf8 _val409; _ -> P.error "wrong type"})) _val407); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Hosts _ = P.error "not a struct"
read_Hosts :: (T.Transport t, T.Protocol p) => p t -> P.IO Hosts
read_Hosts iprot = to_Hosts <$> T.readVal iprot (T.T_STRUCT typemap_Hosts)
decode_Hosts :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Hosts
decode_Hosts iprot bs = to_Hosts $ T.deserializeVal iprot (T.T_STRUCT typemap_Hosts) bs
typemap_Hosts :: T.TypeMap
typemap_Hosts = Map.fromList [(1,("hostNames",(T.T_SET T.T_STRING)))]
default_Hosts :: Hosts
default_Hosts = Hosts{
  hosts_hostNames = Set.empty}
data PendingReason = PendingReason  { pendingReason_taskId :: LT.Text
  , pendingReason_reason :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PendingReason where
  hashWithSalt salt record = salt   `H.hashWithSalt` pendingReason_taskId record   `H.hashWithSalt` pendingReason_reason record  
instance QC.Arbitrary PendingReason where 
  arbitrary = M.liftM PendingReason (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PendingReason = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PendingReason{pendingReason_taskId = pendingReason_taskId obj} then P.Nothing else P.Just $ default_PendingReason{pendingReason_taskId = pendingReason_taskId obj}
    , if obj == default_PendingReason{pendingReason_reason = pendingReason_reason obj} then P.Nothing else P.Just $ default_PendingReason{pendingReason_reason = pendingReason_reason obj}
    ]
from_PendingReason :: PendingReason -> T.ThriftVal
from_PendingReason record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v412 -> P.Just (1, ("taskId",T.TString $ E.encodeUtf8 _v412))) $ pendingReason_taskId record
  , (\_v412 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v412))) $ pendingReason_reason record
  ]
write_PendingReason :: (T.Protocol p, T.Transport t) => p t -> PendingReason -> P.IO ()
write_PendingReason oprot record = T.writeVal oprot $ from_PendingReason record
encode_PendingReason :: (T.Protocol p, T.Transport t) => p t -> PendingReason -> LBS.ByteString
encode_PendingReason oprot record = T.serializeVal oprot $ from_PendingReason record
to_PendingReason :: T.ThriftVal -> PendingReason
to_PendingReason (T.TStruct fields) = PendingReason{
  pendingReason_taskId = P.maybe (pendingReason_taskId default_PendingReason) (\(_,_val414) -> (case _val414 of {T.TString _val415 -> E.decodeUtf8 _val415; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  pendingReason_reason = P.maybe (pendingReason_reason default_PendingReason) (\(_,_val414) -> (case _val414 of {T.TString _val416 -> E.decodeUtf8 _val416; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PendingReason _ = P.error "not a struct"
read_PendingReason :: (T.Transport t, T.Protocol p) => p t -> P.IO PendingReason
read_PendingReason iprot = to_PendingReason <$> T.readVal iprot (T.T_STRUCT typemap_PendingReason)
decode_PendingReason :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PendingReason
decode_PendingReason iprot bs = to_PendingReason $ T.deserializeVal iprot (T.T_STRUCT typemap_PendingReason) bs
typemap_PendingReason :: T.TypeMap
typemap_PendingReason = Map.fromList [(1,("taskId",T.T_STRING)),(2,("reason",T.T_STRING))]
default_PendingReason :: PendingReason
default_PendingReason = PendingReason{
  pendingReason_taskId = "",
  pendingReason_reason = ""}
data JobUpdateSettings = JobUpdateSettings  { jobUpdateSettings_updateGroupSize :: I.Int32
  , jobUpdateSettings_maxPerInstanceFailures :: I.Int32
  , jobUpdateSettings_maxFailedInstances :: I.Int32
  , jobUpdateSettings_maxWaitToInstanceRunningMs :: I.Int32
  , jobUpdateSettings_minWaitInInstanceRunningMs :: I.Int32
  , jobUpdateSettings_rollbackOnFailure :: P.Bool
  , jobUpdateSettings_updateOnlyTheseInstances :: (Set.HashSet Range)
  , jobUpdateSettings_waitForBatchCompletion :: P.Bool
  , jobUpdateSettings_blockIfNoPulsesAfterMs :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateSettings where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateSettings_updateGroupSize record   `H.hashWithSalt` jobUpdateSettings_maxPerInstanceFailures record   `H.hashWithSalt` jobUpdateSettings_maxFailedInstances record   `H.hashWithSalt` jobUpdateSettings_maxWaitToInstanceRunningMs record   `H.hashWithSalt` jobUpdateSettings_minWaitInInstanceRunningMs record   `H.hashWithSalt` jobUpdateSettings_rollbackOnFailure record   `H.hashWithSalt` jobUpdateSettings_updateOnlyTheseInstances record   `H.hashWithSalt` jobUpdateSettings_waitForBatchCompletion record   `H.hashWithSalt` jobUpdateSettings_blockIfNoPulsesAfterMs record  
instance QC.Arbitrary JobUpdateSettings where 
  arbitrary = M.liftM JobUpdateSettings (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateSettings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateSettings{jobUpdateSettings_updateGroupSize = jobUpdateSettings_updateGroupSize obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_updateGroupSize = jobUpdateSettings_updateGroupSize obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_maxPerInstanceFailures = jobUpdateSettings_maxPerInstanceFailures obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_maxPerInstanceFailures = jobUpdateSettings_maxPerInstanceFailures obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_maxFailedInstances = jobUpdateSettings_maxFailedInstances obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_maxFailedInstances = jobUpdateSettings_maxFailedInstances obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_maxWaitToInstanceRunningMs = jobUpdateSettings_maxWaitToInstanceRunningMs obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_maxWaitToInstanceRunningMs = jobUpdateSettings_maxWaitToInstanceRunningMs obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_minWaitInInstanceRunningMs = jobUpdateSettings_minWaitInInstanceRunningMs obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_minWaitInInstanceRunningMs = jobUpdateSettings_minWaitInInstanceRunningMs obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_rollbackOnFailure = jobUpdateSettings_rollbackOnFailure obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_rollbackOnFailure = jobUpdateSettings_rollbackOnFailure obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_updateOnlyTheseInstances = jobUpdateSettings_updateOnlyTheseInstances obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_updateOnlyTheseInstances = jobUpdateSettings_updateOnlyTheseInstances obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_waitForBatchCompletion = jobUpdateSettings_waitForBatchCompletion obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_waitForBatchCompletion = jobUpdateSettings_waitForBatchCompletion obj}
    , if obj == default_JobUpdateSettings{jobUpdateSettings_blockIfNoPulsesAfterMs = jobUpdateSettings_blockIfNoPulsesAfterMs obj} then P.Nothing else P.Just $ default_JobUpdateSettings{jobUpdateSettings_blockIfNoPulsesAfterMs = jobUpdateSettings_blockIfNoPulsesAfterMs obj}
    ]
from_JobUpdateSettings :: JobUpdateSettings -> T.ThriftVal
from_JobUpdateSettings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v419 -> P.Just (1, ("updateGroupSize",T.TI32 _v419))) $ jobUpdateSettings_updateGroupSize record
  , (\_v419 -> P.Just (2, ("maxPerInstanceFailures",T.TI32 _v419))) $ jobUpdateSettings_maxPerInstanceFailures record
  , (\_v419 -> P.Just (3, ("maxFailedInstances",T.TI32 _v419))) $ jobUpdateSettings_maxFailedInstances record
  , (\_v419 -> P.Just (4, ("maxWaitToInstanceRunningMs",T.TI32 _v419))) $ jobUpdateSettings_maxWaitToInstanceRunningMs record
  , (\_v419 -> P.Just (5, ("minWaitInInstanceRunningMs",T.TI32 _v419))) $ jobUpdateSettings_minWaitInInstanceRunningMs record
  , (\_v419 -> P.Just (6, ("rollbackOnFailure",T.TBool _v419))) $ jobUpdateSettings_rollbackOnFailure record
  , (\_v419 -> P.Just (7, ("updateOnlyTheseInstances",T.TSet (T.T_STRUCT typemap_Range) $ P.map (\_v421 -> from_Range _v421) $ Set.toList _v419))) $ jobUpdateSettings_updateOnlyTheseInstances record
  , (\_v419 -> P.Just (8, ("waitForBatchCompletion",T.TBool _v419))) $ jobUpdateSettings_waitForBatchCompletion record
  , (\_v419 -> P.Just (9, ("blockIfNoPulsesAfterMs",T.TI32 _v419))) $ jobUpdateSettings_blockIfNoPulsesAfterMs record
  ]
write_JobUpdateSettings :: (T.Protocol p, T.Transport t) => p t -> JobUpdateSettings -> P.IO ()
write_JobUpdateSettings oprot record = T.writeVal oprot $ from_JobUpdateSettings record
encode_JobUpdateSettings :: (T.Protocol p, T.Transport t) => p t -> JobUpdateSettings -> LBS.ByteString
encode_JobUpdateSettings oprot record = T.serializeVal oprot $ from_JobUpdateSettings record
to_JobUpdateSettings :: T.ThriftVal -> JobUpdateSettings
to_JobUpdateSettings (T.TStruct fields) = JobUpdateSettings{
  jobUpdateSettings_updateGroupSize = P.maybe (jobUpdateSettings_updateGroupSize default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TI32 _val424 -> _val424; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateSettings_maxPerInstanceFailures = P.maybe (jobUpdateSettings_maxPerInstanceFailures default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TI32 _val425 -> _val425; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateSettings_maxFailedInstances = P.maybe (jobUpdateSettings_maxFailedInstances default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TI32 _val426 -> _val426; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  jobUpdateSettings_maxWaitToInstanceRunningMs = P.maybe (jobUpdateSettings_maxWaitToInstanceRunningMs default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TI32 _val427 -> _val427; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  jobUpdateSettings_minWaitInInstanceRunningMs = P.maybe (jobUpdateSettings_minWaitInInstanceRunningMs default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TI32 _val428 -> _val428; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  jobUpdateSettings_rollbackOnFailure = P.maybe (jobUpdateSettings_rollbackOnFailure default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TBool _val429 -> _val429; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  jobUpdateSettings_updateOnlyTheseInstances = P.maybe (jobUpdateSettings_updateOnlyTheseInstances default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TSet _ _val430 -> (Set.fromList $ P.map (\_v431 -> (case _v431 of {T.TStruct _val432 -> (to_Range (T.TStruct _val432)); _ -> P.error "wrong type"})) _val430); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  jobUpdateSettings_waitForBatchCompletion = P.maybe (jobUpdateSettings_waitForBatchCompletion default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TBool _val433 -> _val433; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  jobUpdateSettings_blockIfNoPulsesAfterMs = P.maybe (jobUpdateSettings_blockIfNoPulsesAfterMs default_JobUpdateSettings) (\(_,_val423) -> (case _val423 of {T.TI32 _val434 -> _val434; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_JobUpdateSettings _ = P.error "not a struct"
read_JobUpdateSettings :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateSettings
read_JobUpdateSettings iprot = to_JobUpdateSettings <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateSettings)
decode_JobUpdateSettings :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateSettings
decode_JobUpdateSettings iprot bs = to_JobUpdateSettings $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateSettings) bs
typemap_JobUpdateSettings :: T.TypeMap
typemap_JobUpdateSettings = Map.fromList [(1,("updateGroupSize",T.T_I32)),(2,("maxPerInstanceFailures",T.T_I32)),(3,("maxFailedInstances",T.T_I32)),(4,("maxWaitToInstanceRunningMs",T.T_I32)),(5,("minWaitInInstanceRunningMs",T.T_I32)),(6,("rollbackOnFailure",T.T_BOOL)),(7,("updateOnlyTheseInstances",(T.T_SET (T.T_STRUCT typemap_Range)))),(8,("waitForBatchCompletion",T.T_BOOL)),(9,("blockIfNoPulsesAfterMs",T.T_I32))]
default_JobUpdateSettings :: JobUpdateSettings
default_JobUpdateSettings = JobUpdateSettings{
  jobUpdateSettings_updateGroupSize = 0,
  jobUpdateSettings_maxPerInstanceFailures = 0,
  jobUpdateSettings_maxFailedInstances = 0,
  jobUpdateSettings_maxWaitToInstanceRunningMs = 0,
  jobUpdateSettings_minWaitInInstanceRunningMs = 0,
  jobUpdateSettings_rollbackOnFailure = P.False,
  jobUpdateSettings_updateOnlyTheseInstances = Set.empty,
  jobUpdateSettings_waitForBatchCompletion = P.False,
  jobUpdateSettings_blockIfNoPulsesAfterMs = 0}
data JobUpdateEvent = JobUpdateEvent  { jobUpdateEvent_status :: JobUpdateStatus
  , jobUpdateEvent_timestampMs :: I.Int64
  , jobUpdateEvent_user :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateEvent where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateEvent_status record   `H.hashWithSalt` jobUpdateEvent_timestampMs record   `H.hashWithSalt` jobUpdateEvent_user record  
instance QC.Arbitrary JobUpdateEvent where 
  arbitrary = M.liftM JobUpdateEvent (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_JobUpdateEvent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateEvent{jobUpdateEvent_status = jobUpdateEvent_status obj} then P.Nothing else P.Just $ default_JobUpdateEvent{jobUpdateEvent_status = jobUpdateEvent_status obj}
    , if obj == default_JobUpdateEvent{jobUpdateEvent_timestampMs = jobUpdateEvent_timestampMs obj} then P.Nothing else P.Just $ default_JobUpdateEvent{jobUpdateEvent_timestampMs = jobUpdateEvent_timestampMs obj}
    , if obj == default_JobUpdateEvent{jobUpdateEvent_user = jobUpdateEvent_user obj} then P.Nothing else P.Just $ default_JobUpdateEvent{jobUpdateEvent_user = jobUpdateEvent_user obj}
    ]
from_JobUpdateEvent :: JobUpdateEvent -> T.ThriftVal
from_JobUpdateEvent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v437 -> P.Just (1, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v437))) $ jobUpdateEvent_status record
  , (\_v437 -> P.Just (2, ("timestampMs",T.TI64 _v437))) $ jobUpdateEvent_timestampMs record
  , (\_v437 -> (3, ("user",T.TString $ E.encodeUtf8 _v437))) <$> jobUpdateEvent_user record
  ]
write_JobUpdateEvent :: (T.Protocol p, T.Transport t) => p t -> JobUpdateEvent -> P.IO ()
write_JobUpdateEvent oprot record = T.writeVal oprot $ from_JobUpdateEvent record
encode_JobUpdateEvent :: (T.Protocol p, T.Transport t) => p t -> JobUpdateEvent -> LBS.ByteString
encode_JobUpdateEvent oprot record = T.serializeVal oprot $ from_JobUpdateEvent record
to_JobUpdateEvent :: T.ThriftVal -> JobUpdateEvent
to_JobUpdateEvent (T.TStruct fields) = JobUpdateEvent{
  jobUpdateEvent_status = P.maybe (jobUpdateEvent_status default_JobUpdateEvent) (\(_,_val439) -> (case _val439 of {T.TI32 _val440 -> P.toEnum $ P.fromIntegral _val440; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateEvent_timestampMs = P.maybe (jobUpdateEvent_timestampMs default_JobUpdateEvent) (\(_,_val439) -> (case _val439 of {T.TI64 _val441 -> _val441; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateEvent_user = P.maybe (P.Nothing) (\(_,_val439) -> P.Just (case _val439 of {T.TString _val442 -> E.decodeUtf8 _val442; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobUpdateEvent _ = P.error "not a struct"
read_JobUpdateEvent :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateEvent
read_JobUpdateEvent iprot = to_JobUpdateEvent <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateEvent)
decode_JobUpdateEvent :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateEvent
decode_JobUpdateEvent iprot bs = to_JobUpdateEvent $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateEvent) bs
typemap_JobUpdateEvent :: T.TypeMap
typemap_JobUpdateEvent = Map.fromList [(1,("status",T.T_I32)),(2,("timestampMs",T.T_I64)),(3,("user",T.T_STRING))]
default_JobUpdateEvent :: JobUpdateEvent
default_JobUpdateEvent = JobUpdateEvent{
  jobUpdateEvent_status = (P.toEnum 0),
  jobUpdateEvent_timestampMs = 0,
  jobUpdateEvent_user = P.Nothing}
data JobInstanceUpdateEvent = JobInstanceUpdateEvent  { jobInstanceUpdateEvent_instanceId :: I.Int32
  , jobInstanceUpdateEvent_timestampMs :: I.Int64
  , jobInstanceUpdateEvent_action :: JobUpdateAction
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobInstanceUpdateEvent where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobInstanceUpdateEvent_instanceId record   `H.hashWithSalt` jobInstanceUpdateEvent_timestampMs record   `H.hashWithSalt` jobInstanceUpdateEvent_action record  
instance QC.Arbitrary JobInstanceUpdateEvent where 
  arbitrary = M.liftM JobInstanceUpdateEvent (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobInstanceUpdateEvent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobInstanceUpdateEvent{jobInstanceUpdateEvent_instanceId = jobInstanceUpdateEvent_instanceId obj} then P.Nothing else P.Just $ default_JobInstanceUpdateEvent{jobInstanceUpdateEvent_instanceId = jobInstanceUpdateEvent_instanceId obj}
    , if obj == default_JobInstanceUpdateEvent{jobInstanceUpdateEvent_timestampMs = jobInstanceUpdateEvent_timestampMs obj} then P.Nothing else P.Just $ default_JobInstanceUpdateEvent{jobInstanceUpdateEvent_timestampMs = jobInstanceUpdateEvent_timestampMs obj}
    , if obj == default_JobInstanceUpdateEvent{jobInstanceUpdateEvent_action = jobInstanceUpdateEvent_action obj} then P.Nothing else P.Just $ default_JobInstanceUpdateEvent{jobInstanceUpdateEvent_action = jobInstanceUpdateEvent_action obj}
    ]
from_JobInstanceUpdateEvent :: JobInstanceUpdateEvent -> T.ThriftVal
from_JobInstanceUpdateEvent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v445 -> P.Just (1, ("instanceId",T.TI32 _v445))) $ jobInstanceUpdateEvent_instanceId record
  , (\_v445 -> P.Just (2, ("timestampMs",T.TI64 _v445))) $ jobInstanceUpdateEvent_timestampMs record
  , (\_v445 -> P.Just (3, ("action",T.TI32 $ P.fromIntegral $ P.fromEnum _v445))) $ jobInstanceUpdateEvent_action record
  ]
write_JobInstanceUpdateEvent :: (T.Protocol p, T.Transport t) => p t -> JobInstanceUpdateEvent -> P.IO ()
write_JobInstanceUpdateEvent oprot record = T.writeVal oprot $ from_JobInstanceUpdateEvent record
encode_JobInstanceUpdateEvent :: (T.Protocol p, T.Transport t) => p t -> JobInstanceUpdateEvent -> LBS.ByteString
encode_JobInstanceUpdateEvent oprot record = T.serializeVal oprot $ from_JobInstanceUpdateEvent record
to_JobInstanceUpdateEvent :: T.ThriftVal -> JobInstanceUpdateEvent
to_JobInstanceUpdateEvent (T.TStruct fields) = JobInstanceUpdateEvent{
  jobInstanceUpdateEvent_instanceId = P.maybe (jobInstanceUpdateEvent_instanceId default_JobInstanceUpdateEvent) (\(_,_val447) -> (case _val447 of {T.TI32 _val448 -> _val448; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobInstanceUpdateEvent_timestampMs = P.maybe (jobInstanceUpdateEvent_timestampMs default_JobInstanceUpdateEvent) (\(_,_val447) -> (case _val447 of {T.TI64 _val449 -> _val449; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobInstanceUpdateEvent_action = P.maybe (jobInstanceUpdateEvent_action default_JobInstanceUpdateEvent) (\(_,_val447) -> (case _val447 of {T.TI32 _val450 -> P.toEnum $ P.fromIntegral _val450; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobInstanceUpdateEvent _ = P.error "not a struct"
read_JobInstanceUpdateEvent :: (T.Transport t, T.Protocol p) => p t -> P.IO JobInstanceUpdateEvent
read_JobInstanceUpdateEvent iprot = to_JobInstanceUpdateEvent <$> T.readVal iprot (T.T_STRUCT typemap_JobInstanceUpdateEvent)
decode_JobInstanceUpdateEvent :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobInstanceUpdateEvent
decode_JobInstanceUpdateEvent iprot bs = to_JobInstanceUpdateEvent $ T.deserializeVal iprot (T.T_STRUCT typemap_JobInstanceUpdateEvent) bs
typemap_JobInstanceUpdateEvent :: T.TypeMap
typemap_JobInstanceUpdateEvent = Map.fromList [(1,("instanceId",T.T_I32)),(2,("timestampMs",T.T_I64)),(3,("action",T.T_I32))]
default_JobInstanceUpdateEvent :: JobInstanceUpdateEvent
default_JobInstanceUpdateEvent = JobInstanceUpdateEvent{
  jobInstanceUpdateEvent_instanceId = 0,
  jobInstanceUpdateEvent_timestampMs = 0,
  jobInstanceUpdateEvent_action = (P.toEnum 0)}
data InstanceTaskConfig = InstanceTaskConfig  { instanceTaskConfig_task :: TaskConfig
  , instanceTaskConfig_instances :: (Set.HashSet Range)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable InstanceTaskConfig where
  hashWithSalt salt record = salt   `H.hashWithSalt` instanceTaskConfig_task record   `H.hashWithSalt` instanceTaskConfig_instances record  
instance QC.Arbitrary InstanceTaskConfig where 
  arbitrary = M.liftM InstanceTaskConfig (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InstanceTaskConfig = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InstanceTaskConfig{instanceTaskConfig_task = instanceTaskConfig_task obj} then P.Nothing else P.Just $ default_InstanceTaskConfig{instanceTaskConfig_task = instanceTaskConfig_task obj}
    , if obj == default_InstanceTaskConfig{instanceTaskConfig_instances = instanceTaskConfig_instances obj} then P.Nothing else P.Just $ default_InstanceTaskConfig{instanceTaskConfig_instances = instanceTaskConfig_instances obj}
    ]
from_InstanceTaskConfig :: InstanceTaskConfig -> T.ThriftVal
from_InstanceTaskConfig record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v453 -> P.Just (1, ("task",from_TaskConfig _v453))) $ instanceTaskConfig_task record
  , (\_v453 -> P.Just (2, ("instances",T.TSet (T.T_STRUCT typemap_Range) $ P.map (\_v455 -> from_Range _v455) $ Set.toList _v453))) $ instanceTaskConfig_instances record
  ]
write_InstanceTaskConfig :: (T.Protocol p, T.Transport t) => p t -> InstanceTaskConfig -> P.IO ()
write_InstanceTaskConfig oprot record = T.writeVal oprot $ from_InstanceTaskConfig record
encode_InstanceTaskConfig :: (T.Protocol p, T.Transport t) => p t -> InstanceTaskConfig -> LBS.ByteString
encode_InstanceTaskConfig oprot record = T.serializeVal oprot $ from_InstanceTaskConfig record
to_InstanceTaskConfig :: T.ThriftVal -> InstanceTaskConfig
to_InstanceTaskConfig (T.TStruct fields) = InstanceTaskConfig{
  instanceTaskConfig_task = P.maybe (instanceTaskConfig_task default_InstanceTaskConfig) (\(_,_val457) -> (case _val457 of {T.TStruct _val458 -> (to_TaskConfig (T.TStruct _val458)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  instanceTaskConfig_instances = P.maybe (instanceTaskConfig_instances default_InstanceTaskConfig) (\(_,_val457) -> (case _val457 of {T.TSet _ _val459 -> (Set.fromList $ P.map (\_v460 -> (case _v460 of {T.TStruct _val461 -> (to_Range (T.TStruct _val461)); _ -> P.error "wrong type"})) _val459); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InstanceTaskConfig _ = P.error "not a struct"
read_InstanceTaskConfig :: (T.Transport t, T.Protocol p) => p t -> P.IO InstanceTaskConfig
read_InstanceTaskConfig iprot = to_InstanceTaskConfig <$> T.readVal iprot (T.T_STRUCT typemap_InstanceTaskConfig)
decode_InstanceTaskConfig :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> InstanceTaskConfig
decode_InstanceTaskConfig iprot bs = to_InstanceTaskConfig $ T.deserializeVal iprot (T.T_STRUCT typemap_InstanceTaskConfig) bs
typemap_InstanceTaskConfig :: T.TypeMap
typemap_InstanceTaskConfig = Map.fromList [(1,("task",(T.T_STRUCT typemap_TaskConfig))),(2,("instances",(T.T_SET (T.T_STRUCT typemap_Range))))]
default_InstanceTaskConfig :: InstanceTaskConfig
default_InstanceTaskConfig = InstanceTaskConfig{
  instanceTaskConfig_task = default_TaskConfig,
  instanceTaskConfig_instances = Set.empty}
data JobUpdateState = JobUpdateState  { jobUpdateState_status :: JobUpdateStatus
  , jobUpdateState_createdTimestampMs :: I.Int64
  , jobUpdateState_lastModifiedTimestampMs :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateState where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateState_status record   `H.hashWithSalt` jobUpdateState_createdTimestampMs record   `H.hashWithSalt` jobUpdateState_lastModifiedTimestampMs record  
instance QC.Arbitrary JobUpdateState where 
  arbitrary = M.liftM JobUpdateState (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateState = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateState{jobUpdateState_status = jobUpdateState_status obj} then P.Nothing else P.Just $ default_JobUpdateState{jobUpdateState_status = jobUpdateState_status obj}
    , if obj == default_JobUpdateState{jobUpdateState_createdTimestampMs = jobUpdateState_createdTimestampMs obj} then P.Nothing else P.Just $ default_JobUpdateState{jobUpdateState_createdTimestampMs = jobUpdateState_createdTimestampMs obj}
    , if obj == default_JobUpdateState{jobUpdateState_lastModifiedTimestampMs = jobUpdateState_lastModifiedTimestampMs obj} then P.Nothing else P.Just $ default_JobUpdateState{jobUpdateState_lastModifiedTimestampMs = jobUpdateState_lastModifiedTimestampMs obj}
    ]
from_JobUpdateState :: JobUpdateState -> T.ThriftVal
from_JobUpdateState record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v464 -> P.Just (1, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v464))) $ jobUpdateState_status record
  , (\_v464 -> P.Just (2, ("createdTimestampMs",T.TI64 _v464))) $ jobUpdateState_createdTimestampMs record
  , (\_v464 -> P.Just (3, ("lastModifiedTimestampMs",T.TI64 _v464))) $ jobUpdateState_lastModifiedTimestampMs record
  ]
write_JobUpdateState :: (T.Protocol p, T.Transport t) => p t -> JobUpdateState -> P.IO ()
write_JobUpdateState oprot record = T.writeVal oprot $ from_JobUpdateState record
encode_JobUpdateState :: (T.Protocol p, T.Transport t) => p t -> JobUpdateState -> LBS.ByteString
encode_JobUpdateState oprot record = T.serializeVal oprot $ from_JobUpdateState record
to_JobUpdateState :: T.ThriftVal -> JobUpdateState
to_JobUpdateState (T.TStruct fields) = JobUpdateState{
  jobUpdateState_status = P.maybe (jobUpdateState_status default_JobUpdateState) (\(_,_val466) -> (case _val466 of {T.TI32 _val467 -> P.toEnum $ P.fromIntegral _val467; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateState_createdTimestampMs = P.maybe (jobUpdateState_createdTimestampMs default_JobUpdateState) (\(_,_val466) -> (case _val466 of {T.TI64 _val468 -> _val468; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateState_lastModifiedTimestampMs = P.maybe (jobUpdateState_lastModifiedTimestampMs default_JobUpdateState) (\(_,_val466) -> (case _val466 of {T.TI64 _val469 -> _val469; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobUpdateState _ = P.error "not a struct"
read_JobUpdateState :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateState
read_JobUpdateState iprot = to_JobUpdateState <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateState)
decode_JobUpdateState :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateState
decode_JobUpdateState iprot bs = to_JobUpdateState $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateState) bs
typemap_JobUpdateState :: T.TypeMap
typemap_JobUpdateState = Map.fromList [(1,("status",T.T_I32)),(2,("createdTimestampMs",T.T_I64)),(3,("lastModifiedTimestampMs",T.T_I64))]
default_JobUpdateState :: JobUpdateState
default_JobUpdateState = JobUpdateState{
  jobUpdateState_status = (P.toEnum 0),
  jobUpdateState_createdTimestampMs = 0,
  jobUpdateState_lastModifiedTimestampMs = 0}
data JobUpdateSummary = JobUpdateSummary  { jobUpdateSummary_updateId :: LT.Text
  , jobUpdateSummary_jobKey :: JobKey
  , jobUpdateSummary_user :: LT.Text
  , jobUpdateSummary_state :: JobUpdateState
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateSummary where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateSummary_updateId record   `H.hashWithSalt` jobUpdateSummary_jobKey record   `H.hashWithSalt` jobUpdateSummary_user record   `H.hashWithSalt` jobUpdateSummary_state record  
instance QC.Arbitrary JobUpdateSummary where 
  arbitrary = M.liftM JobUpdateSummary (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateSummary = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateSummary{jobUpdateSummary_updateId = jobUpdateSummary_updateId obj} then P.Nothing else P.Just $ default_JobUpdateSummary{jobUpdateSummary_updateId = jobUpdateSummary_updateId obj}
    , if obj == default_JobUpdateSummary{jobUpdateSummary_jobKey = jobUpdateSummary_jobKey obj} then P.Nothing else P.Just $ default_JobUpdateSummary{jobUpdateSummary_jobKey = jobUpdateSummary_jobKey obj}
    , if obj == default_JobUpdateSummary{jobUpdateSummary_user = jobUpdateSummary_user obj} then P.Nothing else P.Just $ default_JobUpdateSummary{jobUpdateSummary_user = jobUpdateSummary_user obj}
    , if obj == default_JobUpdateSummary{jobUpdateSummary_state = jobUpdateSummary_state obj} then P.Nothing else P.Just $ default_JobUpdateSummary{jobUpdateSummary_state = jobUpdateSummary_state obj}
    ]
from_JobUpdateSummary :: JobUpdateSummary -> T.ThriftVal
from_JobUpdateSummary record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v472 -> P.Just (1, ("updateId",T.TString $ E.encodeUtf8 _v472))) $ jobUpdateSummary_updateId record
  , (\_v472 -> P.Just (2, ("jobKey",from_JobKey _v472))) $ jobUpdateSummary_jobKey record
  , (\_v472 -> P.Just (3, ("user",T.TString $ E.encodeUtf8 _v472))) $ jobUpdateSummary_user record
  , (\_v472 -> P.Just (4, ("state",from_JobUpdateState _v472))) $ jobUpdateSummary_state record
  ]
write_JobUpdateSummary :: (T.Protocol p, T.Transport t) => p t -> JobUpdateSummary -> P.IO ()
write_JobUpdateSummary oprot record = T.writeVal oprot $ from_JobUpdateSummary record
encode_JobUpdateSummary :: (T.Protocol p, T.Transport t) => p t -> JobUpdateSummary -> LBS.ByteString
encode_JobUpdateSummary oprot record = T.serializeVal oprot $ from_JobUpdateSummary record
to_JobUpdateSummary :: T.ThriftVal -> JobUpdateSummary
to_JobUpdateSummary (T.TStruct fields) = JobUpdateSummary{
  jobUpdateSummary_updateId = P.maybe (jobUpdateSummary_updateId default_JobUpdateSummary) (\(_,_val474) -> (case _val474 of {T.TString _val475 -> E.decodeUtf8 _val475; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateSummary_jobKey = P.maybe (jobUpdateSummary_jobKey default_JobUpdateSummary) (\(_,_val474) -> (case _val474 of {T.TStruct _val476 -> (to_JobKey (T.TStruct _val476)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateSummary_user = P.maybe (jobUpdateSummary_user default_JobUpdateSummary) (\(_,_val474) -> (case _val474 of {T.TString _val477 -> E.decodeUtf8 _val477; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  jobUpdateSummary_state = P.maybe (jobUpdateSummary_state default_JobUpdateSummary) (\(_,_val474) -> (case _val474 of {T.TStruct _val478 -> (to_JobUpdateState (T.TStruct _val478)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_JobUpdateSummary _ = P.error "not a struct"
read_JobUpdateSummary :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateSummary
read_JobUpdateSummary iprot = to_JobUpdateSummary <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateSummary)
decode_JobUpdateSummary :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateSummary
decode_JobUpdateSummary iprot bs = to_JobUpdateSummary $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateSummary) bs
typemap_JobUpdateSummary :: T.TypeMap
typemap_JobUpdateSummary = Map.fromList [(1,("updateId",T.T_STRING)),(2,("jobKey",(T.T_STRUCT typemap_JobKey))),(3,("user",T.T_STRING)),(4,("state",(T.T_STRUCT typemap_JobUpdateState)))]
default_JobUpdateSummary :: JobUpdateSummary
default_JobUpdateSummary = JobUpdateSummary{
  jobUpdateSummary_updateId = "",
  jobUpdateSummary_jobKey = default_JobKey,
  jobUpdateSummary_user = "",
  jobUpdateSummary_state = default_JobUpdateState}
data JobUpdateInstructions = JobUpdateInstructions  { jobUpdateInstructions_initialState :: (Set.HashSet InstanceTaskConfig)
  , jobUpdateInstructions_desiredState :: InstanceTaskConfig
  , jobUpdateInstructions_settings :: JobUpdateSettings
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateInstructions where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateInstructions_initialState record   `H.hashWithSalt` jobUpdateInstructions_desiredState record   `H.hashWithSalt` jobUpdateInstructions_settings record  
instance QC.Arbitrary JobUpdateInstructions where 
  arbitrary = M.liftM JobUpdateInstructions (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateInstructions = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateInstructions{jobUpdateInstructions_initialState = jobUpdateInstructions_initialState obj} then P.Nothing else P.Just $ default_JobUpdateInstructions{jobUpdateInstructions_initialState = jobUpdateInstructions_initialState obj}
    , if obj == default_JobUpdateInstructions{jobUpdateInstructions_desiredState = jobUpdateInstructions_desiredState obj} then P.Nothing else P.Just $ default_JobUpdateInstructions{jobUpdateInstructions_desiredState = jobUpdateInstructions_desiredState obj}
    , if obj == default_JobUpdateInstructions{jobUpdateInstructions_settings = jobUpdateInstructions_settings obj} then P.Nothing else P.Just $ default_JobUpdateInstructions{jobUpdateInstructions_settings = jobUpdateInstructions_settings obj}
    ]
from_JobUpdateInstructions :: JobUpdateInstructions -> T.ThriftVal
from_JobUpdateInstructions record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v481 -> P.Just (1, ("initialState",T.TSet (T.T_STRUCT typemap_InstanceTaskConfig) $ P.map (\_v483 -> from_InstanceTaskConfig _v483) $ Set.toList _v481))) $ jobUpdateInstructions_initialState record
  , (\_v481 -> P.Just (2, ("desiredState",from_InstanceTaskConfig _v481))) $ jobUpdateInstructions_desiredState record
  , (\_v481 -> P.Just (3, ("settings",from_JobUpdateSettings _v481))) $ jobUpdateInstructions_settings record
  ]
write_JobUpdateInstructions :: (T.Protocol p, T.Transport t) => p t -> JobUpdateInstructions -> P.IO ()
write_JobUpdateInstructions oprot record = T.writeVal oprot $ from_JobUpdateInstructions record
encode_JobUpdateInstructions :: (T.Protocol p, T.Transport t) => p t -> JobUpdateInstructions -> LBS.ByteString
encode_JobUpdateInstructions oprot record = T.serializeVal oprot $ from_JobUpdateInstructions record
to_JobUpdateInstructions :: T.ThriftVal -> JobUpdateInstructions
to_JobUpdateInstructions (T.TStruct fields) = JobUpdateInstructions{
  jobUpdateInstructions_initialState = P.maybe (jobUpdateInstructions_initialState default_JobUpdateInstructions) (\(_,_val485) -> (case _val485 of {T.TSet _ _val486 -> (Set.fromList $ P.map (\_v487 -> (case _v487 of {T.TStruct _val488 -> (to_InstanceTaskConfig (T.TStruct _val488)); _ -> P.error "wrong type"})) _val486); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateInstructions_desiredState = P.maybe (jobUpdateInstructions_desiredState default_JobUpdateInstructions) (\(_,_val485) -> (case _val485 of {T.TStruct _val489 -> (to_InstanceTaskConfig (T.TStruct _val489)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateInstructions_settings = P.maybe (jobUpdateInstructions_settings default_JobUpdateInstructions) (\(_,_val485) -> (case _val485 of {T.TStruct _val490 -> (to_JobUpdateSettings (T.TStruct _val490)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobUpdateInstructions _ = P.error "not a struct"
read_JobUpdateInstructions :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateInstructions
read_JobUpdateInstructions iprot = to_JobUpdateInstructions <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateInstructions)
decode_JobUpdateInstructions :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateInstructions
decode_JobUpdateInstructions iprot bs = to_JobUpdateInstructions $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateInstructions) bs
typemap_JobUpdateInstructions :: T.TypeMap
typemap_JobUpdateInstructions = Map.fromList [(1,("initialState",(T.T_SET (T.T_STRUCT typemap_InstanceTaskConfig)))),(2,("desiredState",(T.T_STRUCT typemap_InstanceTaskConfig))),(3,("settings",(T.T_STRUCT typemap_JobUpdateSettings)))]
default_JobUpdateInstructions :: JobUpdateInstructions
default_JobUpdateInstructions = JobUpdateInstructions{
  jobUpdateInstructions_initialState = Set.empty,
  jobUpdateInstructions_desiredState = default_InstanceTaskConfig,
  jobUpdateInstructions_settings = default_JobUpdateSettings}
data JobUpdate = JobUpdate  { jobUpdate_summary :: JobUpdateSummary
  , jobUpdate_instructions :: JobUpdateInstructions
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdate where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdate_summary record   `H.hashWithSalt` jobUpdate_instructions record  
instance QC.Arbitrary JobUpdate where 
  arbitrary = M.liftM JobUpdate (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdate{jobUpdate_summary = jobUpdate_summary obj} then P.Nothing else P.Just $ default_JobUpdate{jobUpdate_summary = jobUpdate_summary obj}
    , if obj == default_JobUpdate{jobUpdate_instructions = jobUpdate_instructions obj} then P.Nothing else P.Just $ default_JobUpdate{jobUpdate_instructions = jobUpdate_instructions obj}
    ]
from_JobUpdate :: JobUpdate -> T.ThriftVal
from_JobUpdate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v493 -> P.Just (1, ("summary",from_JobUpdateSummary _v493))) $ jobUpdate_summary record
  , (\_v493 -> P.Just (2, ("instructions",from_JobUpdateInstructions _v493))) $ jobUpdate_instructions record
  ]
write_JobUpdate :: (T.Protocol p, T.Transport t) => p t -> JobUpdate -> P.IO ()
write_JobUpdate oprot record = T.writeVal oprot $ from_JobUpdate record
encode_JobUpdate :: (T.Protocol p, T.Transport t) => p t -> JobUpdate -> LBS.ByteString
encode_JobUpdate oprot record = T.serializeVal oprot $ from_JobUpdate record
to_JobUpdate :: T.ThriftVal -> JobUpdate
to_JobUpdate (T.TStruct fields) = JobUpdate{
  jobUpdate_summary = P.maybe (jobUpdate_summary default_JobUpdate) (\(_,_val495) -> (case _val495 of {T.TStruct _val496 -> (to_JobUpdateSummary (T.TStruct _val496)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdate_instructions = P.maybe (jobUpdate_instructions default_JobUpdate) (\(_,_val495) -> (case _val495 of {T.TStruct _val497 -> (to_JobUpdateInstructions (T.TStruct _val497)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_JobUpdate _ = P.error "not a struct"
read_JobUpdate :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdate
read_JobUpdate iprot = to_JobUpdate <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdate)
decode_JobUpdate :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdate
decode_JobUpdate iprot bs = to_JobUpdate $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdate) bs
typemap_JobUpdate :: T.TypeMap
typemap_JobUpdate = Map.fromList [(1,("summary",(T.T_STRUCT typemap_JobUpdateSummary))),(2,("instructions",(T.T_STRUCT typemap_JobUpdateInstructions)))]
default_JobUpdate :: JobUpdate
default_JobUpdate = JobUpdate{
  jobUpdate_summary = default_JobUpdateSummary,
  jobUpdate_instructions = default_JobUpdateInstructions}
data JobUpdateDetails = JobUpdateDetails  { jobUpdateDetails_update :: JobUpdate
  , jobUpdateDetails_updateEvents :: (Vector.Vector JobUpdateEvent)
  , jobUpdateDetails_instanceEvents :: (Vector.Vector JobInstanceUpdateEvent)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateDetails where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateDetails_update record   `H.hashWithSalt` jobUpdateDetails_updateEvents record   `H.hashWithSalt` jobUpdateDetails_instanceEvents record  
instance QC.Arbitrary JobUpdateDetails where 
  arbitrary = M.liftM JobUpdateDetails (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateDetails = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateDetails{jobUpdateDetails_update = jobUpdateDetails_update obj} then P.Nothing else P.Just $ default_JobUpdateDetails{jobUpdateDetails_update = jobUpdateDetails_update obj}
    , if obj == default_JobUpdateDetails{jobUpdateDetails_updateEvents = jobUpdateDetails_updateEvents obj} then P.Nothing else P.Just $ default_JobUpdateDetails{jobUpdateDetails_updateEvents = jobUpdateDetails_updateEvents obj}
    , if obj == default_JobUpdateDetails{jobUpdateDetails_instanceEvents = jobUpdateDetails_instanceEvents obj} then P.Nothing else P.Just $ default_JobUpdateDetails{jobUpdateDetails_instanceEvents = jobUpdateDetails_instanceEvents obj}
    ]
from_JobUpdateDetails :: JobUpdateDetails -> T.ThriftVal
from_JobUpdateDetails record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v500 -> P.Just (1, ("update",from_JobUpdate _v500))) $ jobUpdateDetails_update record
  , (\_v500 -> P.Just (2, ("updateEvents",T.TList (T.T_STRUCT typemap_JobUpdateEvent) $ P.map (\_v502 -> from_JobUpdateEvent _v502) $ Vector.toList _v500))) $ jobUpdateDetails_updateEvents record
  , (\_v500 -> P.Just (3, ("instanceEvents",T.TList (T.T_STRUCT typemap_JobInstanceUpdateEvent) $ P.map (\_v504 -> from_JobInstanceUpdateEvent _v504) $ Vector.toList _v500))) $ jobUpdateDetails_instanceEvents record
  ]
write_JobUpdateDetails :: (T.Protocol p, T.Transport t) => p t -> JobUpdateDetails -> P.IO ()
write_JobUpdateDetails oprot record = T.writeVal oprot $ from_JobUpdateDetails record
encode_JobUpdateDetails :: (T.Protocol p, T.Transport t) => p t -> JobUpdateDetails -> LBS.ByteString
encode_JobUpdateDetails oprot record = T.serializeVal oprot $ from_JobUpdateDetails record
to_JobUpdateDetails :: T.ThriftVal -> JobUpdateDetails
to_JobUpdateDetails (T.TStruct fields) = JobUpdateDetails{
  jobUpdateDetails_update = P.maybe (jobUpdateDetails_update default_JobUpdateDetails) (\(_,_val506) -> (case _val506 of {T.TStruct _val507 -> (to_JobUpdate (T.TStruct _val507)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateDetails_updateEvents = P.maybe (jobUpdateDetails_updateEvents default_JobUpdateDetails) (\(_,_val506) -> (case _val506 of {T.TList _ _val508 -> (Vector.fromList $ P.map (\_v509 -> (case _v509 of {T.TStruct _val510 -> (to_JobUpdateEvent (T.TStruct _val510)); _ -> P.error "wrong type"})) _val508); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateDetails_instanceEvents = P.maybe (jobUpdateDetails_instanceEvents default_JobUpdateDetails) (\(_,_val506) -> (case _val506 of {T.TList _ _val511 -> (Vector.fromList $ P.map (\_v512 -> (case _v512 of {T.TStruct _val513 -> (to_JobInstanceUpdateEvent (T.TStruct _val513)); _ -> P.error "wrong type"})) _val511); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobUpdateDetails _ = P.error "not a struct"
read_JobUpdateDetails :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateDetails
read_JobUpdateDetails iprot = to_JobUpdateDetails <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateDetails)
decode_JobUpdateDetails :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateDetails
decode_JobUpdateDetails iprot bs = to_JobUpdateDetails $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateDetails) bs
typemap_JobUpdateDetails :: T.TypeMap
typemap_JobUpdateDetails = Map.fromList [(1,("update",(T.T_STRUCT typemap_JobUpdate))),(2,("updateEvents",(T.T_LIST (T.T_STRUCT typemap_JobUpdateEvent)))),(3,("instanceEvents",(T.T_LIST (T.T_STRUCT typemap_JobInstanceUpdateEvent))))]
default_JobUpdateDetails :: JobUpdateDetails
default_JobUpdateDetails = JobUpdateDetails{
  jobUpdateDetails_update = default_JobUpdate,
  jobUpdateDetails_updateEvents = Vector.empty,
  jobUpdateDetails_instanceEvents = Vector.empty}
data JobUpdateRequest = JobUpdateRequest  { jobUpdateRequest_taskConfig :: TaskConfig
  , jobUpdateRequest_instanceCount :: I.Int32
  , jobUpdateRequest_settings :: JobUpdateSettings
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateRequest_taskConfig record   `H.hashWithSalt` jobUpdateRequest_instanceCount record   `H.hashWithSalt` jobUpdateRequest_settings record  
instance QC.Arbitrary JobUpdateRequest where 
  arbitrary = M.liftM JobUpdateRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateRequest{jobUpdateRequest_taskConfig = jobUpdateRequest_taskConfig obj} then P.Nothing else P.Just $ default_JobUpdateRequest{jobUpdateRequest_taskConfig = jobUpdateRequest_taskConfig obj}
    , if obj == default_JobUpdateRequest{jobUpdateRequest_instanceCount = jobUpdateRequest_instanceCount obj} then P.Nothing else P.Just $ default_JobUpdateRequest{jobUpdateRequest_instanceCount = jobUpdateRequest_instanceCount obj}
    , if obj == default_JobUpdateRequest{jobUpdateRequest_settings = jobUpdateRequest_settings obj} then P.Nothing else P.Just $ default_JobUpdateRequest{jobUpdateRequest_settings = jobUpdateRequest_settings obj}
    ]
from_JobUpdateRequest :: JobUpdateRequest -> T.ThriftVal
from_JobUpdateRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v516 -> P.Just (1, ("taskConfig",from_TaskConfig _v516))) $ jobUpdateRequest_taskConfig record
  , (\_v516 -> P.Just (2, ("instanceCount",T.TI32 _v516))) $ jobUpdateRequest_instanceCount record
  , (\_v516 -> P.Just (3, ("settings",from_JobUpdateSettings _v516))) $ jobUpdateRequest_settings record
  ]
write_JobUpdateRequest :: (T.Protocol p, T.Transport t) => p t -> JobUpdateRequest -> P.IO ()
write_JobUpdateRequest oprot record = T.writeVal oprot $ from_JobUpdateRequest record
encode_JobUpdateRequest :: (T.Protocol p, T.Transport t) => p t -> JobUpdateRequest -> LBS.ByteString
encode_JobUpdateRequest oprot record = T.serializeVal oprot $ from_JobUpdateRequest record
to_JobUpdateRequest :: T.ThriftVal -> JobUpdateRequest
to_JobUpdateRequest (T.TStruct fields) = JobUpdateRequest{
  jobUpdateRequest_taskConfig = P.maybe (jobUpdateRequest_taskConfig default_JobUpdateRequest) (\(_,_val518) -> (case _val518 of {T.TStruct _val519 -> (to_TaskConfig (T.TStruct _val519)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateRequest_instanceCount = P.maybe (jobUpdateRequest_instanceCount default_JobUpdateRequest) (\(_,_val518) -> (case _val518 of {T.TI32 _val520 -> _val520; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateRequest_settings = P.maybe (jobUpdateRequest_settings default_JobUpdateRequest) (\(_,_val518) -> (case _val518 of {T.TStruct _val521 -> (to_JobUpdateSettings (T.TStruct _val521)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JobUpdateRequest _ = P.error "not a struct"
read_JobUpdateRequest :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateRequest
read_JobUpdateRequest iprot = to_JobUpdateRequest <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateRequest)
decode_JobUpdateRequest :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateRequest
decode_JobUpdateRequest iprot bs = to_JobUpdateRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateRequest) bs
typemap_JobUpdateRequest :: T.TypeMap
typemap_JobUpdateRequest = Map.fromList [(1,("taskConfig",(T.T_STRUCT typemap_TaskConfig))),(2,("instanceCount",T.T_I32)),(3,("settings",(T.T_STRUCT typemap_JobUpdateSettings)))]
default_JobUpdateRequest :: JobUpdateRequest
default_JobUpdateRequest = JobUpdateRequest{
  jobUpdateRequest_taskConfig = default_TaskConfig,
  jobUpdateRequest_instanceCount = 0,
  jobUpdateRequest_settings = default_JobUpdateSettings}
data JobUpdateQuery = JobUpdateQuery  { jobUpdateQuery_updateId :: LT.Text
  , jobUpdateQuery_role :: LT.Text
  , jobUpdateQuery_jobKey :: JobKey
  , jobUpdateQuery_user :: LT.Text
  , jobUpdateQuery_updateStatuses :: (Set.HashSet JobUpdateStatus)
  , jobUpdateQuery_offset :: I.Int32
  , jobUpdateQuery_limit :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobUpdateQuery where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobUpdateQuery_updateId record   `H.hashWithSalt` jobUpdateQuery_role record   `H.hashWithSalt` jobUpdateQuery_jobKey record   `H.hashWithSalt` jobUpdateQuery_user record   `H.hashWithSalt` jobUpdateQuery_updateStatuses record   `H.hashWithSalt` jobUpdateQuery_offset record   `H.hashWithSalt` jobUpdateQuery_limit record  
instance QC.Arbitrary JobUpdateQuery where 
  arbitrary = M.liftM JobUpdateQuery (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobUpdateQuery = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobUpdateQuery{jobUpdateQuery_updateId = jobUpdateQuery_updateId obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_updateId = jobUpdateQuery_updateId obj}
    , if obj == default_JobUpdateQuery{jobUpdateQuery_role = jobUpdateQuery_role obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_role = jobUpdateQuery_role obj}
    , if obj == default_JobUpdateQuery{jobUpdateQuery_jobKey = jobUpdateQuery_jobKey obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_jobKey = jobUpdateQuery_jobKey obj}
    , if obj == default_JobUpdateQuery{jobUpdateQuery_user = jobUpdateQuery_user obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_user = jobUpdateQuery_user obj}
    , if obj == default_JobUpdateQuery{jobUpdateQuery_updateStatuses = jobUpdateQuery_updateStatuses obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_updateStatuses = jobUpdateQuery_updateStatuses obj}
    , if obj == default_JobUpdateQuery{jobUpdateQuery_offset = jobUpdateQuery_offset obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_offset = jobUpdateQuery_offset obj}
    , if obj == default_JobUpdateQuery{jobUpdateQuery_limit = jobUpdateQuery_limit obj} then P.Nothing else P.Just $ default_JobUpdateQuery{jobUpdateQuery_limit = jobUpdateQuery_limit obj}
    ]
from_JobUpdateQuery :: JobUpdateQuery -> T.ThriftVal
from_JobUpdateQuery record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v524 -> P.Just (1, ("updateId",T.TString $ E.encodeUtf8 _v524))) $ jobUpdateQuery_updateId record
  , (\_v524 -> P.Just (2, ("role",T.TString $ E.encodeUtf8 _v524))) $ jobUpdateQuery_role record
  , (\_v524 -> P.Just (3, ("jobKey",from_JobKey _v524))) $ jobUpdateQuery_jobKey record
  , (\_v524 -> P.Just (4, ("user",T.TString $ E.encodeUtf8 _v524))) $ jobUpdateQuery_user record
  , (\_v524 -> P.Just (5, ("updateStatuses",T.TSet T.T_I32 $ P.map (\_v526 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v526) $ Set.toList _v524))) $ jobUpdateQuery_updateStatuses record
  , (\_v524 -> P.Just (6, ("offset",T.TI32 _v524))) $ jobUpdateQuery_offset record
  , (\_v524 -> P.Just (7, ("limit",T.TI32 _v524))) $ jobUpdateQuery_limit record
  ]
write_JobUpdateQuery :: (T.Protocol p, T.Transport t) => p t -> JobUpdateQuery -> P.IO ()
write_JobUpdateQuery oprot record = T.writeVal oprot $ from_JobUpdateQuery record
encode_JobUpdateQuery :: (T.Protocol p, T.Transport t) => p t -> JobUpdateQuery -> LBS.ByteString
encode_JobUpdateQuery oprot record = T.serializeVal oprot $ from_JobUpdateQuery record
to_JobUpdateQuery :: T.ThriftVal -> JobUpdateQuery
to_JobUpdateQuery (T.TStruct fields) = JobUpdateQuery{
  jobUpdateQuery_updateId = P.maybe (jobUpdateQuery_updateId default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TString _val529 -> E.decodeUtf8 _val529; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobUpdateQuery_role = P.maybe (jobUpdateQuery_role default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TString _val530 -> E.decodeUtf8 _val530; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  jobUpdateQuery_jobKey = P.maybe (jobUpdateQuery_jobKey default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TStruct _val531 -> (to_JobKey (T.TStruct _val531)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  jobUpdateQuery_user = P.maybe (jobUpdateQuery_user default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TString _val532 -> E.decodeUtf8 _val532; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  jobUpdateQuery_updateStatuses = P.maybe (jobUpdateQuery_updateStatuses default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TSet _ _val533 -> (Set.fromList $ P.map (\_v534 -> (case _v534 of {T.TI32 _val535 -> P.toEnum $ P.fromIntegral _val535; _ -> P.error "wrong type"})) _val533); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  jobUpdateQuery_offset = P.maybe (jobUpdateQuery_offset default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TI32 _val536 -> _val536; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  jobUpdateQuery_limit = P.maybe (jobUpdateQuery_limit default_JobUpdateQuery) (\(_,_val528) -> (case _val528 of {T.TI32 _val537 -> _val537; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_JobUpdateQuery _ = P.error "not a struct"
read_JobUpdateQuery :: (T.Transport t, T.Protocol p) => p t -> P.IO JobUpdateQuery
read_JobUpdateQuery iprot = to_JobUpdateQuery <$> T.readVal iprot (T.T_STRUCT typemap_JobUpdateQuery)
decode_JobUpdateQuery :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobUpdateQuery
decode_JobUpdateQuery iprot bs = to_JobUpdateQuery $ T.deserializeVal iprot (T.T_STRUCT typemap_JobUpdateQuery) bs
typemap_JobUpdateQuery :: T.TypeMap
typemap_JobUpdateQuery = Map.fromList [(1,("updateId",T.T_STRING)),(2,("role",T.T_STRING)),(3,("jobKey",(T.T_STRUCT typemap_JobKey))),(4,("user",T.T_STRING)),(5,("updateStatuses",(T.T_SET T.T_I32))),(6,("offset",T.T_I32)),(7,("limit",T.T_I32))]
default_JobUpdateQuery :: JobUpdateQuery
default_JobUpdateQuery = JobUpdateQuery{
  jobUpdateQuery_updateId = "",
  jobUpdateQuery_role = "",
  jobUpdateQuery_jobKey = default_JobKey,
  jobUpdateQuery_user = "",
  jobUpdateQuery_updateStatuses = Set.empty,
  jobUpdateQuery_offset = 0,
  jobUpdateQuery_limit = 0}
data ListBackupsResult = ListBackupsResult  { listBackupsResult_backups :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ListBackupsResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBackupsResult_backups record  
instance QC.Arbitrary ListBackupsResult where 
  arbitrary = M.liftM ListBackupsResult (QC.arbitrary)
  shrink obj | obj == default_ListBackupsResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBackupsResult{listBackupsResult_backups = listBackupsResult_backups obj} then P.Nothing else P.Just $ default_ListBackupsResult{listBackupsResult_backups = listBackupsResult_backups obj}
    ]
from_ListBackupsResult :: ListBackupsResult -> T.ThriftVal
from_ListBackupsResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v540 -> P.Just (1, ("backups",T.TSet T.T_STRING $ P.map (\_v542 -> T.TString $ E.encodeUtf8 _v542) $ Set.toList _v540))) $ listBackupsResult_backups record
  ]
write_ListBackupsResult :: (T.Protocol p, T.Transport t) => p t -> ListBackupsResult -> P.IO ()
write_ListBackupsResult oprot record = T.writeVal oprot $ from_ListBackupsResult record
encode_ListBackupsResult :: (T.Protocol p, T.Transport t) => p t -> ListBackupsResult -> LBS.ByteString
encode_ListBackupsResult oprot record = T.serializeVal oprot $ from_ListBackupsResult record
to_ListBackupsResult :: T.ThriftVal -> ListBackupsResult
to_ListBackupsResult (T.TStruct fields) = ListBackupsResult{
  listBackupsResult_backups = P.maybe (listBackupsResult_backups default_ListBackupsResult) (\(_,_val544) -> (case _val544 of {T.TSet _ _val545 -> (Set.fromList $ P.map (\_v546 -> (case _v546 of {T.TString _val547 -> E.decodeUtf8 _val547; _ -> P.error "wrong type"})) _val545); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListBackupsResult _ = P.error "not a struct"
read_ListBackupsResult :: (T.Transport t, T.Protocol p) => p t -> P.IO ListBackupsResult
read_ListBackupsResult iprot = to_ListBackupsResult <$> T.readVal iprot (T.T_STRUCT typemap_ListBackupsResult)
decode_ListBackupsResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ListBackupsResult
decode_ListBackupsResult iprot bs = to_ListBackupsResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBackupsResult) bs
typemap_ListBackupsResult :: T.TypeMap
typemap_ListBackupsResult = Map.fromList [(1,("backups",(T.T_SET T.T_STRING)))]
default_ListBackupsResult :: ListBackupsResult
default_ListBackupsResult = ListBackupsResult{
  listBackupsResult_backups = Set.empty}
data StartMaintenanceResult = StartMaintenanceResult  { startMaintenanceResult_statuses :: (Set.HashSet HostStatus)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartMaintenanceResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` startMaintenanceResult_statuses record  
instance QC.Arbitrary StartMaintenanceResult where 
  arbitrary = M.liftM StartMaintenanceResult (QC.arbitrary)
  shrink obj | obj == default_StartMaintenanceResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartMaintenanceResult{startMaintenanceResult_statuses = startMaintenanceResult_statuses obj} then P.Nothing else P.Just $ default_StartMaintenanceResult{startMaintenanceResult_statuses = startMaintenanceResult_statuses obj}
    ]
from_StartMaintenanceResult :: StartMaintenanceResult -> T.ThriftVal
from_StartMaintenanceResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v550 -> P.Just (1, ("statuses",T.TSet (T.T_STRUCT typemap_HostStatus) $ P.map (\_v552 -> from_HostStatus _v552) $ Set.toList _v550))) $ startMaintenanceResult_statuses record
  ]
write_StartMaintenanceResult :: (T.Protocol p, T.Transport t) => p t -> StartMaintenanceResult -> P.IO ()
write_StartMaintenanceResult oprot record = T.writeVal oprot $ from_StartMaintenanceResult record
encode_StartMaintenanceResult :: (T.Protocol p, T.Transport t) => p t -> StartMaintenanceResult -> LBS.ByteString
encode_StartMaintenanceResult oprot record = T.serializeVal oprot $ from_StartMaintenanceResult record
to_StartMaintenanceResult :: T.ThriftVal -> StartMaintenanceResult
to_StartMaintenanceResult (T.TStruct fields) = StartMaintenanceResult{
  startMaintenanceResult_statuses = P.maybe (startMaintenanceResult_statuses default_StartMaintenanceResult) (\(_,_val554) -> (case _val554 of {T.TSet _ _val555 -> (Set.fromList $ P.map (\_v556 -> (case _v556 of {T.TStruct _val557 -> (to_HostStatus (T.TStruct _val557)); _ -> P.error "wrong type"})) _val555); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartMaintenanceResult _ = P.error "not a struct"
read_StartMaintenanceResult :: (T.Transport t, T.Protocol p) => p t -> P.IO StartMaintenanceResult
read_StartMaintenanceResult iprot = to_StartMaintenanceResult <$> T.readVal iprot (T.T_STRUCT typemap_StartMaintenanceResult)
decode_StartMaintenanceResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartMaintenanceResult
decode_StartMaintenanceResult iprot bs = to_StartMaintenanceResult $ T.deserializeVal iprot (T.T_STRUCT typemap_StartMaintenanceResult) bs
typemap_StartMaintenanceResult :: T.TypeMap
typemap_StartMaintenanceResult = Map.fromList [(1,("statuses",(T.T_SET (T.T_STRUCT typemap_HostStatus))))]
default_StartMaintenanceResult :: StartMaintenanceResult
default_StartMaintenanceResult = StartMaintenanceResult{
  startMaintenanceResult_statuses = Set.empty}
data DrainHostsResult = DrainHostsResult  { drainHostsResult_statuses :: (Set.HashSet HostStatus)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DrainHostsResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` drainHostsResult_statuses record  
instance QC.Arbitrary DrainHostsResult where 
  arbitrary = M.liftM DrainHostsResult (QC.arbitrary)
  shrink obj | obj == default_DrainHostsResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DrainHostsResult{drainHostsResult_statuses = drainHostsResult_statuses obj} then P.Nothing else P.Just $ default_DrainHostsResult{drainHostsResult_statuses = drainHostsResult_statuses obj}
    ]
from_DrainHostsResult :: DrainHostsResult -> T.ThriftVal
from_DrainHostsResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v560 -> P.Just (1, ("statuses",T.TSet (T.T_STRUCT typemap_HostStatus) $ P.map (\_v562 -> from_HostStatus _v562) $ Set.toList _v560))) $ drainHostsResult_statuses record
  ]
write_DrainHostsResult :: (T.Protocol p, T.Transport t) => p t -> DrainHostsResult -> P.IO ()
write_DrainHostsResult oprot record = T.writeVal oprot $ from_DrainHostsResult record
encode_DrainHostsResult :: (T.Protocol p, T.Transport t) => p t -> DrainHostsResult -> LBS.ByteString
encode_DrainHostsResult oprot record = T.serializeVal oprot $ from_DrainHostsResult record
to_DrainHostsResult :: T.ThriftVal -> DrainHostsResult
to_DrainHostsResult (T.TStruct fields) = DrainHostsResult{
  drainHostsResult_statuses = P.maybe (drainHostsResult_statuses default_DrainHostsResult) (\(_,_val564) -> (case _val564 of {T.TSet _ _val565 -> (Set.fromList $ P.map (\_v566 -> (case _v566 of {T.TStruct _val567 -> (to_HostStatus (T.TStruct _val567)); _ -> P.error "wrong type"})) _val565); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DrainHostsResult _ = P.error "not a struct"
read_DrainHostsResult :: (T.Transport t, T.Protocol p) => p t -> P.IO DrainHostsResult
read_DrainHostsResult iprot = to_DrainHostsResult <$> T.readVal iprot (T.T_STRUCT typemap_DrainHostsResult)
decode_DrainHostsResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DrainHostsResult
decode_DrainHostsResult iprot bs = to_DrainHostsResult $ T.deserializeVal iprot (T.T_STRUCT typemap_DrainHostsResult) bs
typemap_DrainHostsResult :: T.TypeMap
typemap_DrainHostsResult = Map.fromList [(1,("statuses",(T.T_SET (T.T_STRUCT typemap_HostStatus))))]
default_DrainHostsResult :: DrainHostsResult
default_DrainHostsResult = DrainHostsResult{
  drainHostsResult_statuses = Set.empty}
data QueryRecoveryResult = QueryRecoveryResult  { queryRecoveryResult_tasks :: (Set.HashSet ScheduledTask)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable QueryRecoveryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` queryRecoveryResult_tasks record  
instance QC.Arbitrary QueryRecoveryResult where 
  arbitrary = M.liftM QueryRecoveryResult (QC.arbitrary)
  shrink obj | obj == default_QueryRecoveryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_QueryRecoveryResult{queryRecoveryResult_tasks = queryRecoveryResult_tasks obj} then P.Nothing else P.Just $ default_QueryRecoveryResult{queryRecoveryResult_tasks = queryRecoveryResult_tasks obj}
    ]
from_QueryRecoveryResult :: QueryRecoveryResult -> T.ThriftVal
from_QueryRecoveryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v570 -> P.Just (1, ("tasks",T.TSet (T.T_STRUCT typemap_ScheduledTask) $ P.map (\_v572 -> from_ScheduledTask _v572) $ Set.toList _v570))) $ queryRecoveryResult_tasks record
  ]
write_QueryRecoveryResult :: (T.Protocol p, T.Transport t) => p t -> QueryRecoveryResult -> P.IO ()
write_QueryRecoveryResult oprot record = T.writeVal oprot $ from_QueryRecoveryResult record
encode_QueryRecoveryResult :: (T.Protocol p, T.Transport t) => p t -> QueryRecoveryResult -> LBS.ByteString
encode_QueryRecoveryResult oprot record = T.serializeVal oprot $ from_QueryRecoveryResult record
to_QueryRecoveryResult :: T.ThriftVal -> QueryRecoveryResult
to_QueryRecoveryResult (T.TStruct fields) = QueryRecoveryResult{
  queryRecoveryResult_tasks = P.maybe (queryRecoveryResult_tasks default_QueryRecoveryResult) (\(_,_val574) -> (case _val574 of {T.TSet _ _val575 -> (Set.fromList $ P.map (\_v576 -> (case _v576 of {T.TStruct _val577 -> (to_ScheduledTask (T.TStruct _val577)); _ -> P.error "wrong type"})) _val575); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_QueryRecoveryResult _ = P.error "not a struct"
read_QueryRecoveryResult :: (T.Transport t, T.Protocol p) => p t -> P.IO QueryRecoveryResult
read_QueryRecoveryResult iprot = to_QueryRecoveryResult <$> T.readVal iprot (T.T_STRUCT typemap_QueryRecoveryResult)
decode_QueryRecoveryResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> QueryRecoveryResult
decode_QueryRecoveryResult iprot bs = to_QueryRecoveryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_QueryRecoveryResult) bs
typemap_QueryRecoveryResult :: T.TypeMap
typemap_QueryRecoveryResult = Map.fromList [(1,("tasks",(T.T_SET (T.T_STRUCT typemap_ScheduledTask))))]
default_QueryRecoveryResult :: QueryRecoveryResult
default_QueryRecoveryResult = QueryRecoveryResult{
  queryRecoveryResult_tasks = Set.empty}
data MaintenanceStatusResult = MaintenanceStatusResult  { maintenanceStatusResult_statuses :: (Set.HashSet HostStatus)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable MaintenanceStatusResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` maintenanceStatusResult_statuses record  
instance QC.Arbitrary MaintenanceStatusResult where 
  arbitrary = M.liftM MaintenanceStatusResult (QC.arbitrary)
  shrink obj | obj == default_MaintenanceStatusResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MaintenanceStatusResult{maintenanceStatusResult_statuses = maintenanceStatusResult_statuses obj} then P.Nothing else P.Just $ default_MaintenanceStatusResult{maintenanceStatusResult_statuses = maintenanceStatusResult_statuses obj}
    ]
from_MaintenanceStatusResult :: MaintenanceStatusResult -> T.ThriftVal
from_MaintenanceStatusResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v580 -> P.Just (1, ("statuses",T.TSet (T.T_STRUCT typemap_HostStatus) $ P.map (\_v582 -> from_HostStatus _v582) $ Set.toList _v580))) $ maintenanceStatusResult_statuses record
  ]
write_MaintenanceStatusResult :: (T.Protocol p, T.Transport t) => p t -> MaintenanceStatusResult -> P.IO ()
write_MaintenanceStatusResult oprot record = T.writeVal oprot $ from_MaintenanceStatusResult record
encode_MaintenanceStatusResult :: (T.Protocol p, T.Transport t) => p t -> MaintenanceStatusResult -> LBS.ByteString
encode_MaintenanceStatusResult oprot record = T.serializeVal oprot $ from_MaintenanceStatusResult record
to_MaintenanceStatusResult :: T.ThriftVal -> MaintenanceStatusResult
to_MaintenanceStatusResult (T.TStruct fields) = MaintenanceStatusResult{
  maintenanceStatusResult_statuses = P.maybe (maintenanceStatusResult_statuses default_MaintenanceStatusResult) (\(_,_val584) -> (case _val584 of {T.TSet _ _val585 -> (Set.fromList $ P.map (\_v586 -> (case _v586 of {T.TStruct _val587 -> (to_HostStatus (T.TStruct _val587)); _ -> P.error "wrong type"})) _val585); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MaintenanceStatusResult _ = P.error "not a struct"
read_MaintenanceStatusResult :: (T.Transport t, T.Protocol p) => p t -> P.IO MaintenanceStatusResult
read_MaintenanceStatusResult iprot = to_MaintenanceStatusResult <$> T.readVal iprot (T.T_STRUCT typemap_MaintenanceStatusResult)
decode_MaintenanceStatusResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> MaintenanceStatusResult
decode_MaintenanceStatusResult iprot bs = to_MaintenanceStatusResult $ T.deserializeVal iprot (T.T_STRUCT typemap_MaintenanceStatusResult) bs
typemap_MaintenanceStatusResult :: T.TypeMap
typemap_MaintenanceStatusResult = Map.fromList [(1,("statuses",(T.T_SET (T.T_STRUCT typemap_HostStatus))))]
default_MaintenanceStatusResult :: MaintenanceStatusResult
default_MaintenanceStatusResult = MaintenanceStatusResult{
  maintenanceStatusResult_statuses = Set.empty}
data EndMaintenanceResult = EndMaintenanceResult  { endMaintenanceResult_statuses :: (Set.HashSet HostStatus)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable EndMaintenanceResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` endMaintenanceResult_statuses record  
instance QC.Arbitrary EndMaintenanceResult where 
  arbitrary = M.liftM EndMaintenanceResult (QC.arbitrary)
  shrink obj | obj == default_EndMaintenanceResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EndMaintenanceResult{endMaintenanceResult_statuses = endMaintenanceResult_statuses obj} then P.Nothing else P.Just $ default_EndMaintenanceResult{endMaintenanceResult_statuses = endMaintenanceResult_statuses obj}
    ]
from_EndMaintenanceResult :: EndMaintenanceResult -> T.ThriftVal
from_EndMaintenanceResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v590 -> P.Just (1, ("statuses",T.TSet (T.T_STRUCT typemap_HostStatus) $ P.map (\_v592 -> from_HostStatus _v592) $ Set.toList _v590))) $ endMaintenanceResult_statuses record
  ]
write_EndMaintenanceResult :: (T.Protocol p, T.Transport t) => p t -> EndMaintenanceResult -> P.IO ()
write_EndMaintenanceResult oprot record = T.writeVal oprot $ from_EndMaintenanceResult record
encode_EndMaintenanceResult :: (T.Protocol p, T.Transport t) => p t -> EndMaintenanceResult -> LBS.ByteString
encode_EndMaintenanceResult oprot record = T.serializeVal oprot $ from_EndMaintenanceResult record
to_EndMaintenanceResult :: T.ThriftVal -> EndMaintenanceResult
to_EndMaintenanceResult (T.TStruct fields) = EndMaintenanceResult{
  endMaintenanceResult_statuses = P.maybe (endMaintenanceResult_statuses default_EndMaintenanceResult) (\(_,_val594) -> (case _val594 of {T.TSet _ _val595 -> (Set.fromList $ P.map (\_v596 -> (case _v596 of {T.TStruct _val597 -> (to_HostStatus (T.TStruct _val597)); _ -> P.error "wrong type"})) _val595); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_EndMaintenanceResult _ = P.error "not a struct"
read_EndMaintenanceResult :: (T.Transport t, T.Protocol p) => p t -> P.IO EndMaintenanceResult
read_EndMaintenanceResult iprot = to_EndMaintenanceResult <$> T.readVal iprot (T.T_STRUCT typemap_EndMaintenanceResult)
decode_EndMaintenanceResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EndMaintenanceResult
decode_EndMaintenanceResult iprot bs = to_EndMaintenanceResult $ T.deserializeVal iprot (T.T_STRUCT typemap_EndMaintenanceResult) bs
typemap_EndMaintenanceResult :: T.TypeMap
typemap_EndMaintenanceResult = Map.fromList [(1,("statuses",(T.T_SET (T.T_STRUCT typemap_HostStatus))))]
default_EndMaintenanceResult :: EndMaintenanceResult
default_EndMaintenanceResult = EndMaintenanceResult{
  endMaintenanceResult_statuses = Set.empty}
data RoleSummaryResult = RoleSummaryResult  { roleSummaryResult_summaries :: (Set.HashSet RoleSummary)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RoleSummaryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` roleSummaryResult_summaries record  
instance QC.Arbitrary RoleSummaryResult where 
  arbitrary = M.liftM RoleSummaryResult (QC.arbitrary)
  shrink obj | obj == default_RoleSummaryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RoleSummaryResult{roleSummaryResult_summaries = roleSummaryResult_summaries obj} then P.Nothing else P.Just $ default_RoleSummaryResult{roleSummaryResult_summaries = roleSummaryResult_summaries obj}
    ]
from_RoleSummaryResult :: RoleSummaryResult -> T.ThriftVal
from_RoleSummaryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v600 -> P.Just (1, ("summaries",T.TSet (T.T_STRUCT typemap_RoleSummary) $ P.map (\_v602 -> from_RoleSummary _v602) $ Set.toList _v600))) $ roleSummaryResult_summaries record
  ]
write_RoleSummaryResult :: (T.Protocol p, T.Transport t) => p t -> RoleSummaryResult -> P.IO ()
write_RoleSummaryResult oprot record = T.writeVal oprot $ from_RoleSummaryResult record
encode_RoleSummaryResult :: (T.Protocol p, T.Transport t) => p t -> RoleSummaryResult -> LBS.ByteString
encode_RoleSummaryResult oprot record = T.serializeVal oprot $ from_RoleSummaryResult record
to_RoleSummaryResult :: T.ThriftVal -> RoleSummaryResult
to_RoleSummaryResult (T.TStruct fields) = RoleSummaryResult{
  roleSummaryResult_summaries = P.maybe (roleSummaryResult_summaries default_RoleSummaryResult) (\(_,_val604) -> (case _val604 of {T.TSet _ _val605 -> (Set.fromList $ P.map (\_v606 -> (case _v606 of {T.TStruct _val607 -> (to_RoleSummary (T.TStruct _val607)); _ -> P.error "wrong type"})) _val605); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RoleSummaryResult _ = P.error "not a struct"
read_RoleSummaryResult :: (T.Transport t, T.Protocol p) => p t -> P.IO RoleSummaryResult
read_RoleSummaryResult iprot = to_RoleSummaryResult <$> T.readVal iprot (T.T_STRUCT typemap_RoleSummaryResult)
decode_RoleSummaryResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RoleSummaryResult
decode_RoleSummaryResult iprot bs = to_RoleSummaryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_RoleSummaryResult) bs
typemap_RoleSummaryResult :: T.TypeMap
typemap_RoleSummaryResult = Map.fromList [(1,("summaries",(T.T_SET (T.T_STRUCT typemap_RoleSummary))))]
default_RoleSummaryResult :: RoleSummaryResult
default_RoleSummaryResult = RoleSummaryResult{
  roleSummaryResult_summaries = Set.empty}
data JobSummaryResult = JobSummaryResult  { jobSummaryResult_summaries :: (Set.HashSet JobSummary)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobSummaryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobSummaryResult_summaries record  
instance QC.Arbitrary JobSummaryResult where 
  arbitrary = M.liftM JobSummaryResult (QC.arbitrary)
  shrink obj | obj == default_JobSummaryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobSummaryResult{jobSummaryResult_summaries = jobSummaryResult_summaries obj} then P.Nothing else P.Just $ default_JobSummaryResult{jobSummaryResult_summaries = jobSummaryResult_summaries obj}
    ]
from_JobSummaryResult :: JobSummaryResult -> T.ThriftVal
from_JobSummaryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v610 -> P.Just (1, ("summaries",T.TSet (T.T_STRUCT typemap_JobSummary) $ P.map (\_v612 -> from_JobSummary _v612) $ Set.toList _v610))) $ jobSummaryResult_summaries record
  ]
write_JobSummaryResult :: (T.Protocol p, T.Transport t) => p t -> JobSummaryResult -> P.IO ()
write_JobSummaryResult oprot record = T.writeVal oprot $ from_JobSummaryResult record
encode_JobSummaryResult :: (T.Protocol p, T.Transport t) => p t -> JobSummaryResult -> LBS.ByteString
encode_JobSummaryResult oprot record = T.serializeVal oprot $ from_JobSummaryResult record
to_JobSummaryResult :: T.ThriftVal -> JobSummaryResult
to_JobSummaryResult (T.TStruct fields) = JobSummaryResult{
  jobSummaryResult_summaries = P.maybe (jobSummaryResult_summaries default_JobSummaryResult) (\(_,_val614) -> (case _val614 of {T.TSet _ _val615 -> (Set.fromList $ P.map (\_v616 -> (case _v616 of {T.TStruct _val617 -> (to_JobSummary (T.TStruct _val617)); _ -> P.error "wrong type"})) _val615); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JobSummaryResult _ = P.error "not a struct"
read_JobSummaryResult :: (T.Transport t, T.Protocol p) => p t -> P.IO JobSummaryResult
read_JobSummaryResult iprot = to_JobSummaryResult <$> T.readVal iprot (T.T_STRUCT typemap_JobSummaryResult)
decode_JobSummaryResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobSummaryResult
decode_JobSummaryResult iprot bs = to_JobSummaryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_JobSummaryResult) bs
typemap_JobSummaryResult :: T.TypeMap
typemap_JobSummaryResult = Map.fromList [(1,("summaries",(T.T_SET (T.T_STRUCT typemap_JobSummary))))]
default_JobSummaryResult :: JobSummaryResult
default_JobSummaryResult = JobSummaryResult{
  jobSummaryResult_summaries = Set.empty}
data GetLocksResult = GetLocksResult  { getLocksResult_locks :: (Set.HashSet Lock)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetLocksResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLocksResult_locks record  
instance QC.Arbitrary GetLocksResult where 
  arbitrary = M.liftM GetLocksResult (QC.arbitrary)
  shrink obj | obj == default_GetLocksResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLocksResult{getLocksResult_locks = getLocksResult_locks obj} then P.Nothing else P.Just $ default_GetLocksResult{getLocksResult_locks = getLocksResult_locks obj}
    ]
from_GetLocksResult :: GetLocksResult -> T.ThriftVal
from_GetLocksResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v620 -> P.Just (1, ("locks",T.TSet (T.T_STRUCT typemap_Lock) $ P.map (\_v622 -> from_Lock _v622) $ Set.toList _v620))) $ getLocksResult_locks record
  ]
write_GetLocksResult :: (T.Protocol p, T.Transport t) => p t -> GetLocksResult -> P.IO ()
write_GetLocksResult oprot record = T.writeVal oprot $ from_GetLocksResult record
encode_GetLocksResult :: (T.Protocol p, T.Transport t) => p t -> GetLocksResult -> LBS.ByteString
encode_GetLocksResult oprot record = T.serializeVal oprot $ from_GetLocksResult record
to_GetLocksResult :: T.ThriftVal -> GetLocksResult
to_GetLocksResult (T.TStruct fields) = GetLocksResult{
  getLocksResult_locks = P.maybe (getLocksResult_locks default_GetLocksResult) (\(_,_val624) -> (case _val624 of {T.TSet _ _val625 -> (Set.fromList $ P.map (\_v626 -> (case _v626 of {T.TStruct _val627 -> (to_Lock (T.TStruct _val627)); _ -> P.error "wrong type"})) _val625); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLocksResult _ = P.error "not a struct"
read_GetLocksResult :: (T.Transport t, T.Protocol p) => p t -> P.IO GetLocksResult
read_GetLocksResult iprot = to_GetLocksResult <$> T.readVal iprot (T.T_STRUCT typemap_GetLocksResult)
decode_GetLocksResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetLocksResult
decode_GetLocksResult iprot bs = to_GetLocksResult $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLocksResult) bs
typemap_GetLocksResult :: T.TypeMap
typemap_GetLocksResult = Map.fromList [(1,("locks",(T.T_SET (T.T_STRUCT typemap_Lock))))]
default_GetLocksResult :: GetLocksResult
default_GetLocksResult = GetLocksResult{
  getLocksResult_locks = Set.empty}
data ConfigSummaryResult = ConfigSummaryResult  { configSummaryResult_summary :: ConfigSummary
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ConfigSummaryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` configSummaryResult_summary record  
instance QC.Arbitrary ConfigSummaryResult where 
  arbitrary = M.liftM ConfigSummaryResult (QC.arbitrary)
  shrink obj | obj == default_ConfigSummaryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfigSummaryResult{configSummaryResult_summary = configSummaryResult_summary obj} then P.Nothing else P.Just $ default_ConfigSummaryResult{configSummaryResult_summary = configSummaryResult_summary obj}
    ]
from_ConfigSummaryResult :: ConfigSummaryResult -> T.ThriftVal
from_ConfigSummaryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v630 -> P.Just (1, ("summary",from_ConfigSummary _v630))) $ configSummaryResult_summary record
  ]
write_ConfigSummaryResult :: (T.Protocol p, T.Transport t) => p t -> ConfigSummaryResult -> P.IO ()
write_ConfigSummaryResult oprot record = T.writeVal oprot $ from_ConfigSummaryResult record
encode_ConfigSummaryResult :: (T.Protocol p, T.Transport t) => p t -> ConfigSummaryResult -> LBS.ByteString
encode_ConfigSummaryResult oprot record = T.serializeVal oprot $ from_ConfigSummaryResult record
to_ConfigSummaryResult :: T.ThriftVal -> ConfigSummaryResult
to_ConfigSummaryResult (T.TStruct fields) = ConfigSummaryResult{
  configSummaryResult_summary = P.maybe (configSummaryResult_summary default_ConfigSummaryResult) (\(_,_val632) -> (case _val632 of {T.TStruct _val633 -> (to_ConfigSummary (T.TStruct _val633)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ConfigSummaryResult _ = P.error "not a struct"
read_ConfigSummaryResult :: (T.Transport t, T.Protocol p) => p t -> P.IO ConfigSummaryResult
read_ConfigSummaryResult iprot = to_ConfigSummaryResult <$> T.readVal iprot (T.T_STRUCT typemap_ConfigSummaryResult)
decode_ConfigSummaryResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ConfigSummaryResult
decode_ConfigSummaryResult iprot bs = to_ConfigSummaryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfigSummaryResult) bs
typemap_ConfigSummaryResult :: T.TypeMap
typemap_ConfigSummaryResult = Map.fromList [(1,("summary",(T.T_STRUCT typemap_ConfigSummary)))]
default_ConfigSummaryResult :: ConfigSummaryResult
default_ConfigSummaryResult = ConfigSummaryResult{
  configSummaryResult_summary = default_ConfigSummary}
data GetPendingReasonResult = GetPendingReasonResult  { getPendingReasonResult_reasons :: (Set.HashSet PendingReason)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetPendingReasonResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPendingReasonResult_reasons record  
instance QC.Arbitrary GetPendingReasonResult where 
  arbitrary = M.liftM GetPendingReasonResult (QC.arbitrary)
  shrink obj | obj == default_GetPendingReasonResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPendingReasonResult{getPendingReasonResult_reasons = getPendingReasonResult_reasons obj} then P.Nothing else P.Just $ default_GetPendingReasonResult{getPendingReasonResult_reasons = getPendingReasonResult_reasons obj}
    ]
from_GetPendingReasonResult :: GetPendingReasonResult -> T.ThriftVal
from_GetPendingReasonResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v636 -> P.Just (1, ("reasons",T.TSet (T.T_STRUCT typemap_PendingReason) $ P.map (\_v638 -> from_PendingReason _v638) $ Set.toList _v636))) $ getPendingReasonResult_reasons record
  ]
write_GetPendingReasonResult :: (T.Protocol p, T.Transport t) => p t -> GetPendingReasonResult -> P.IO ()
write_GetPendingReasonResult oprot record = T.writeVal oprot $ from_GetPendingReasonResult record
encode_GetPendingReasonResult :: (T.Protocol p, T.Transport t) => p t -> GetPendingReasonResult -> LBS.ByteString
encode_GetPendingReasonResult oprot record = T.serializeVal oprot $ from_GetPendingReasonResult record
to_GetPendingReasonResult :: T.ThriftVal -> GetPendingReasonResult
to_GetPendingReasonResult (T.TStruct fields) = GetPendingReasonResult{
  getPendingReasonResult_reasons = P.maybe (getPendingReasonResult_reasons default_GetPendingReasonResult) (\(_,_val640) -> (case _val640 of {T.TSet _ _val641 -> (Set.fromList $ P.map (\_v642 -> (case _v642 of {T.TStruct _val643 -> (to_PendingReason (T.TStruct _val643)); _ -> P.error "wrong type"})) _val641); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPendingReasonResult _ = P.error "not a struct"
read_GetPendingReasonResult :: (T.Transport t, T.Protocol p) => p t -> P.IO GetPendingReasonResult
read_GetPendingReasonResult iprot = to_GetPendingReasonResult <$> T.readVal iprot (T.T_STRUCT typemap_GetPendingReasonResult)
decode_GetPendingReasonResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetPendingReasonResult
decode_GetPendingReasonResult iprot bs = to_GetPendingReasonResult $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPendingReasonResult) bs
typemap_GetPendingReasonResult :: T.TypeMap
typemap_GetPendingReasonResult = Map.fromList [(1,("reasons",(T.T_SET (T.T_STRUCT typemap_PendingReason))))]
default_GetPendingReasonResult :: GetPendingReasonResult
default_GetPendingReasonResult = GetPendingReasonResult{
  getPendingReasonResult_reasons = Set.empty}
data StartJobUpdateResult = StartJobUpdateResult  { startJobUpdateResult_updateId :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartJobUpdateResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` startJobUpdateResult_updateId record  
instance QC.Arbitrary StartJobUpdateResult where 
  arbitrary = M.liftM StartJobUpdateResult (QC.arbitrary)
  shrink obj | obj == default_StartJobUpdateResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartJobUpdateResult{startJobUpdateResult_updateId = startJobUpdateResult_updateId obj} then P.Nothing else P.Just $ default_StartJobUpdateResult{startJobUpdateResult_updateId = startJobUpdateResult_updateId obj}
    ]
from_StartJobUpdateResult :: StartJobUpdateResult -> T.ThriftVal
from_StartJobUpdateResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v646 -> P.Just (1, ("updateId",T.TString $ E.encodeUtf8 _v646))) $ startJobUpdateResult_updateId record
  ]
write_StartJobUpdateResult :: (T.Protocol p, T.Transport t) => p t -> StartJobUpdateResult -> P.IO ()
write_StartJobUpdateResult oprot record = T.writeVal oprot $ from_StartJobUpdateResult record
encode_StartJobUpdateResult :: (T.Protocol p, T.Transport t) => p t -> StartJobUpdateResult -> LBS.ByteString
encode_StartJobUpdateResult oprot record = T.serializeVal oprot $ from_StartJobUpdateResult record
to_StartJobUpdateResult :: T.ThriftVal -> StartJobUpdateResult
to_StartJobUpdateResult (T.TStruct fields) = StartJobUpdateResult{
  startJobUpdateResult_updateId = P.maybe (startJobUpdateResult_updateId default_StartJobUpdateResult) (\(_,_val648) -> (case _val648 of {T.TString _val649 -> E.decodeUtf8 _val649; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartJobUpdateResult _ = P.error "not a struct"
read_StartJobUpdateResult :: (T.Transport t, T.Protocol p) => p t -> P.IO StartJobUpdateResult
read_StartJobUpdateResult iprot = to_StartJobUpdateResult <$> T.readVal iprot (T.T_STRUCT typemap_StartJobUpdateResult)
decode_StartJobUpdateResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartJobUpdateResult
decode_StartJobUpdateResult iprot bs = to_StartJobUpdateResult $ T.deserializeVal iprot (T.T_STRUCT typemap_StartJobUpdateResult) bs
typemap_StartJobUpdateResult :: T.TypeMap
typemap_StartJobUpdateResult = Map.fromList [(1,("updateId",T.T_STRING))]
default_StartJobUpdateResult :: StartJobUpdateResult
default_StartJobUpdateResult = StartJobUpdateResult{
  startJobUpdateResult_updateId = ""}
data GetJobUpdateSummariesResult = GetJobUpdateSummariesResult  { getJobUpdateSummariesResult_updateSummaries :: (Vector.Vector JobUpdateSummary)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobUpdateSummariesResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobUpdateSummariesResult_updateSummaries record  
instance QC.Arbitrary GetJobUpdateSummariesResult where 
  arbitrary = M.liftM GetJobUpdateSummariesResult (QC.arbitrary)
  shrink obj | obj == default_GetJobUpdateSummariesResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobUpdateSummariesResult{getJobUpdateSummariesResult_updateSummaries = getJobUpdateSummariesResult_updateSummaries obj} then P.Nothing else P.Just $ default_GetJobUpdateSummariesResult{getJobUpdateSummariesResult_updateSummaries = getJobUpdateSummariesResult_updateSummaries obj}
    ]
from_GetJobUpdateSummariesResult :: GetJobUpdateSummariesResult -> T.ThriftVal
from_GetJobUpdateSummariesResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v652 -> P.Just (1, ("updateSummaries",T.TList (T.T_STRUCT typemap_JobUpdateSummary) $ P.map (\_v654 -> from_JobUpdateSummary _v654) $ Vector.toList _v652))) $ getJobUpdateSummariesResult_updateSummaries record
  ]
write_GetJobUpdateSummariesResult :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateSummariesResult -> P.IO ()
write_GetJobUpdateSummariesResult oprot record = T.writeVal oprot $ from_GetJobUpdateSummariesResult record
encode_GetJobUpdateSummariesResult :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateSummariesResult -> LBS.ByteString
encode_GetJobUpdateSummariesResult oprot record = T.serializeVal oprot $ from_GetJobUpdateSummariesResult record
to_GetJobUpdateSummariesResult :: T.ThriftVal -> GetJobUpdateSummariesResult
to_GetJobUpdateSummariesResult (T.TStruct fields) = GetJobUpdateSummariesResult{
  getJobUpdateSummariesResult_updateSummaries = P.maybe (getJobUpdateSummariesResult_updateSummaries default_GetJobUpdateSummariesResult) (\(_,_val656) -> (case _val656 of {T.TList _ _val657 -> (Vector.fromList $ P.map (\_v658 -> (case _v658 of {T.TStruct _val659 -> (to_JobUpdateSummary (T.TStruct _val659)); _ -> P.error "wrong type"})) _val657); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobUpdateSummariesResult _ = P.error "not a struct"
read_GetJobUpdateSummariesResult :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobUpdateSummariesResult
read_GetJobUpdateSummariesResult iprot = to_GetJobUpdateSummariesResult <$> T.readVal iprot (T.T_STRUCT typemap_GetJobUpdateSummariesResult)
decode_GetJobUpdateSummariesResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobUpdateSummariesResult
decode_GetJobUpdateSummariesResult iprot bs = to_GetJobUpdateSummariesResult $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobUpdateSummariesResult) bs
typemap_GetJobUpdateSummariesResult :: T.TypeMap
typemap_GetJobUpdateSummariesResult = Map.fromList [(1,("updateSummaries",(T.T_LIST (T.T_STRUCT typemap_JobUpdateSummary))))]
default_GetJobUpdateSummariesResult :: GetJobUpdateSummariesResult
default_GetJobUpdateSummariesResult = GetJobUpdateSummariesResult{
  getJobUpdateSummariesResult_updateSummaries = Vector.empty}
data GetJobUpdateDetailsResult = GetJobUpdateDetailsResult  { getJobUpdateDetailsResult_details :: JobUpdateDetails
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobUpdateDetailsResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobUpdateDetailsResult_details record  
instance QC.Arbitrary GetJobUpdateDetailsResult where 
  arbitrary = M.liftM GetJobUpdateDetailsResult (QC.arbitrary)
  shrink obj | obj == default_GetJobUpdateDetailsResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobUpdateDetailsResult{getJobUpdateDetailsResult_details = getJobUpdateDetailsResult_details obj} then P.Nothing else P.Just $ default_GetJobUpdateDetailsResult{getJobUpdateDetailsResult_details = getJobUpdateDetailsResult_details obj}
    ]
from_GetJobUpdateDetailsResult :: GetJobUpdateDetailsResult -> T.ThriftVal
from_GetJobUpdateDetailsResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v662 -> P.Just (1, ("details",from_JobUpdateDetails _v662))) $ getJobUpdateDetailsResult_details record
  ]
write_GetJobUpdateDetailsResult :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateDetailsResult -> P.IO ()
write_GetJobUpdateDetailsResult oprot record = T.writeVal oprot $ from_GetJobUpdateDetailsResult record
encode_GetJobUpdateDetailsResult :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateDetailsResult -> LBS.ByteString
encode_GetJobUpdateDetailsResult oprot record = T.serializeVal oprot $ from_GetJobUpdateDetailsResult record
to_GetJobUpdateDetailsResult :: T.ThriftVal -> GetJobUpdateDetailsResult
to_GetJobUpdateDetailsResult (T.TStruct fields) = GetJobUpdateDetailsResult{
  getJobUpdateDetailsResult_details = P.maybe (getJobUpdateDetailsResult_details default_GetJobUpdateDetailsResult) (\(_,_val664) -> (case _val664 of {T.TStruct _val665 -> (to_JobUpdateDetails (T.TStruct _val665)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobUpdateDetailsResult _ = P.error "not a struct"
read_GetJobUpdateDetailsResult :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobUpdateDetailsResult
read_GetJobUpdateDetailsResult iprot = to_GetJobUpdateDetailsResult <$> T.readVal iprot (T.T_STRUCT typemap_GetJobUpdateDetailsResult)
decode_GetJobUpdateDetailsResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobUpdateDetailsResult
decode_GetJobUpdateDetailsResult iprot bs = to_GetJobUpdateDetailsResult $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobUpdateDetailsResult) bs
typemap_GetJobUpdateDetailsResult :: T.TypeMap
typemap_GetJobUpdateDetailsResult = Map.fromList [(1,("details",(T.T_STRUCT typemap_JobUpdateDetails)))]
default_GetJobUpdateDetailsResult :: GetJobUpdateDetailsResult
default_GetJobUpdateDetailsResult = GetJobUpdateDetailsResult{
  getJobUpdateDetailsResult_details = default_JobUpdateDetails}
data PulseJobUpdateResult = PulseJobUpdateResult  { pulseJobUpdateResult_status :: JobUpdatePulseStatus
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PulseJobUpdateResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` pulseJobUpdateResult_status record  
instance QC.Arbitrary PulseJobUpdateResult where 
  arbitrary = M.liftM PulseJobUpdateResult (QC.arbitrary)
  shrink obj | obj == default_PulseJobUpdateResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PulseJobUpdateResult{pulseJobUpdateResult_status = pulseJobUpdateResult_status obj} then P.Nothing else P.Just $ default_PulseJobUpdateResult{pulseJobUpdateResult_status = pulseJobUpdateResult_status obj}
    ]
from_PulseJobUpdateResult :: PulseJobUpdateResult -> T.ThriftVal
from_PulseJobUpdateResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v668 -> P.Just (1, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v668))) $ pulseJobUpdateResult_status record
  ]
write_PulseJobUpdateResult :: (T.Protocol p, T.Transport t) => p t -> PulseJobUpdateResult -> P.IO ()
write_PulseJobUpdateResult oprot record = T.writeVal oprot $ from_PulseJobUpdateResult record
encode_PulseJobUpdateResult :: (T.Protocol p, T.Transport t) => p t -> PulseJobUpdateResult -> LBS.ByteString
encode_PulseJobUpdateResult oprot record = T.serializeVal oprot $ from_PulseJobUpdateResult record
to_PulseJobUpdateResult :: T.ThriftVal -> PulseJobUpdateResult
to_PulseJobUpdateResult (T.TStruct fields) = PulseJobUpdateResult{
  pulseJobUpdateResult_status = P.maybe (pulseJobUpdateResult_status default_PulseJobUpdateResult) (\(_,_val670) -> (case _val670 of {T.TI32 _val671 -> P.toEnum $ P.fromIntegral _val671; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_PulseJobUpdateResult _ = P.error "not a struct"
read_PulseJobUpdateResult :: (T.Transport t, T.Protocol p) => p t -> P.IO PulseJobUpdateResult
read_PulseJobUpdateResult iprot = to_PulseJobUpdateResult <$> T.readVal iprot (T.T_STRUCT typemap_PulseJobUpdateResult)
decode_PulseJobUpdateResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PulseJobUpdateResult
decode_PulseJobUpdateResult iprot bs = to_PulseJobUpdateResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PulseJobUpdateResult) bs
typemap_PulseJobUpdateResult :: T.TypeMap
typemap_PulseJobUpdateResult = Map.fromList [(1,("status",T.T_I32))]
default_PulseJobUpdateResult :: PulseJobUpdateResult
default_PulseJobUpdateResult = PulseJobUpdateResult{
  pulseJobUpdateResult_status = (P.toEnum 0)}
data ServerInfo = ServerInfo  { serverInfo_clusterName :: LT.Text
  , serverInfo_thriftAPIVersion :: I.Int32
  , serverInfo_statsUrlPrefix :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ServerInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` serverInfo_clusterName record   `H.hashWithSalt` serverInfo_thriftAPIVersion record   `H.hashWithSalt` serverInfo_statsUrlPrefix record  
instance QC.Arbitrary ServerInfo where 
  arbitrary = M.liftM ServerInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ServerInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ServerInfo{serverInfo_clusterName = serverInfo_clusterName obj} then P.Nothing else P.Just $ default_ServerInfo{serverInfo_clusterName = serverInfo_clusterName obj}
    , if obj == default_ServerInfo{serverInfo_thriftAPIVersion = serverInfo_thriftAPIVersion obj} then P.Nothing else P.Just $ default_ServerInfo{serverInfo_thriftAPIVersion = serverInfo_thriftAPIVersion obj}
    , if obj == default_ServerInfo{serverInfo_statsUrlPrefix = serverInfo_statsUrlPrefix obj} then P.Nothing else P.Just $ default_ServerInfo{serverInfo_statsUrlPrefix = serverInfo_statsUrlPrefix obj}
    ]
from_ServerInfo :: ServerInfo -> T.ThriftVal
from_ServerInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v674 -> P.Just (1, ("clusterName",T.TString $ E.encodeUtf8 _v674))) $ serverInfo_clusterName record
  , (\_v674 -> P.Just (2, ("thriftAPIVersion",T.TI32 _v674))) $ serverInfo_thriftAPIVersion record
  , (\_v674 -> P.Just (3, ("statsUrlPrefix",T.TString $ E.encodeUtf8 _v674))) $ serverInfo_statsUrlPrefix record
  ]
write_ServerInfo :: (T.Protocol p, T.Transport t) => p t -> ServerInfo -> P.IO ()
write_ServerInfo oprot record = T.writeVal oprot $ from_ServerInfo record
encode_ServerInfo :: (T.Protocol p, T.Transport t) => p t -> ServerInfo -> LBS.ByteString
encode_ServerInfo oprot record = T.serializeVal oprot $ from_ServerInfo record
to_ServerInfo :: T.ThriftVal -> ServerInfo
to_ServerInfo (T.TStruct fields) = ServerInfo{
  serverInfo_clusterName = P.maybe (serverInfo_clusterName default_ServerInfo) (\(_,_val676) -> (case _val676 of {T.TString _val677 -> E.decodeUtf8 _val677; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  serverInfo_thriftAPIVersion = P.maybe (serverInfo_thriftAPIVersion default_ServerInfo) (\(_,_val676) -> (case _val676 of {T.TI32 _val678 -> _val678; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  serverInfo_statsUrlPrefix = P.maybe (serverInfo_statsUrlPrefix default_ServerInfo) (\(_,_val676) -> (case _val676 of {T.TString _val679 -> E.decodeUtf8 _val679; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ServerInfo _ = P.error "not a struct"
read_ServerInfo :: (T.Transport t, T.Protocol p) => p t -> P.IO ServerInfo
read_ServerInfo iprot = to_ServerInfo <$> T.readVal iprot (T.T_STRUCT typemap_ServerInfo)
decode_ServerInfo :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ServerInfo
decode_ServerInfo iprot bs = to_ServerInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_ServerInfo) bs
typemap_ServerInfo :: T.TypeMap
typemap_ServerInfo = Map.fromList [(1,("clusterName",T.T_STRING)),(2,("thriftAPIVersion",T.T_I32)),(3,("statsUrlPrefix",T.T_STRING))]
default_ServerInfo :: ServerInfo
default_ServerInfo = ServerInfo{
  serverInfo_clusterName = "",
  serverInfo_thriftAPIVersion = 0,
  serverInfo_statsUrlPrefix = ""}
data Result = Result  { result_populateJobResult :: PopulateJobResult
  , result_scheduleStatusResult :: ScheduleStatusResult
  , result_getJobsResult :: GetJobsResult
  , result_getQuotaResult :: GetQuotaResult
  , result_listBackupsResult :: ListBackupsResult
  , result_startMaintenanceResult :: StartMaintenanceResult
  , result_drainHostsResult :: DrainHostsResult
  , result_queryRecoveryResult :: QueryRecoveryResult
  , result_maintenanceStatusResult :: MaintenanceStatusResult
  , result_endMaintenanceResult :: EndMaintenanceResult
  , result_getVersionResult :: APIVersion
  , result_acquireLockResult :: AcquireLockResult
  , result_roleSummaryResult :: RoleSummaryResult
  , result_jobSummaryResult :: JobSummaryResult
  , result_getLocksResult :: GetLocksResult
  , result_configSummaryResult :: ConfigSummaryResult
  , result_getPendingReasonResult :: GetPendingReasonResult
  , result_startJobUpdateResult :: StartJobUpdateResult
  , result_getJobUpdateSummariesResult :: GetJobUpdateSummariesResult
  , result_getJobUpdateDetailsResult :: GetJobUpdateDetailsResult
  , result_pulseJobUpdateResult :: PulseJobUpdateResult
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Result where
  hashWithSalt salt record = salt   `H.hashWithSalt` result_populateJobResult record   `H.hashWithSalt` result_scheduleStatusResult record   `H.hashWithSalt` result_getJobsResult record   `H.hashWithSalt` result_getQuotaResult record   `H.hashWithSalt` result_listBackupsResult record   `H.hashWithSalt` result_startMaintenanceResult record   `H.hashWithSalt` result_drainHostsResult record   `H.hashWithSalt` result_queryRecoveryResult record   `H.hashWithSalt` result_maintenanceStatusResult record   `H.hashWithSalt` result_endMaintenanceResult record   `H.hashWithSalt` result_getVersionResult record   `H.hashWithSalt` result_acquireLockResult record   `H.hashWithSalt` result_roleSummaryResult record   `H.hashWithSalt` result_jobSummaryResult record   `H.hashWithSalt` result_getLocksResult record   `H.hashWithSalt` result_configSummaryResult record   `H.hashWithSalt` result_getPendingReasonResult record   `H.hashWithSalt` result_startJobUpdateResult record   `H.hashWithSalt` result_getJobUpdateSummariesResult record   `H.hashWithSalt` result_getJobUpdateDetailsResult record   `H.hashWithSalt` result_pulseJobUpdateResult record  
instance QC.Arbitrary Result where 
  arbitrary = M.liftM Result (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Result{result_populateJobResult = result_populateJobResult obj} then P.Nothing else P.Just $ default_Result{result_populateJobResult = result_populateJobResult obj}
    , if obj == default_Result{result_scheduleStatusResult = result_scheduleStatusResult obj} then P.Nothing else P.Just $ default_Result{result_scheduleStatusResult = result_scheduleStatusResult obj}
    , if obj == default_Result{result_getJobsResult = result_getJobsResult obj} then P.Nothing else P.Just $ default_Result{result_getJobsResult = result_getJobsResult obj}
    , if obj == default_Result{result_getQuotaResult = result_getQuotaResult obj} then P.Nothing else P.Just $ default_Result{result_getQuotaResult = result_getQuotaResult obj}
    , if obj == default_Result{result_listBackupsResult = result_listBackupsResult obj} then P.Nothing else P.Just $ default_Result{result_listBackupsResult = result_listBackupsResult obj}
    , if obj == default_Result{result_startMaintenanceResult = result_startMaintenanceResult obj} then P.Nothing else P.Just $ default_Result{result_startMaintenanceResult = result_startMaintenanceResult obj}
    , if obj == default_Result{result_drainHostsResult = result_drainHostsResult obj} then P.Nothing else P.Just $ default_Result{result_drainHostsResult = result_drainHostsResult obj}
    , if obj == default_Result{result_queryRecoveryResult = result_queryRecoveryResult obj} then P.Nothing else P.Just $ default_Result{result_queryRecoveryResult = result_queryRecoveryResult obj}
    , if obj == default_Result{result_maintenanceStatusResult = result_maintenanceStatusResult obj} then P.Nothing else P.Just $ default_Result{result_maintenanceStatusResult = result_maintenanceStatusResult obj}
    , if obj == default_Result{result_endMaintenanceResult = result_endMaintenanceResult obj} then P.Nothing else P.Just $ default_Result{result_endMaintenanceResult = result_endMaintenanceResult obj}
    , if obj == default_Result{result_getVersionResult = result_getVersionResult obj} then P.Nothing else P.Just $ default_Result{result_getVersionResult = result_getVersionResult obj}
    , if obj == default_Result{result_acquireLockResult = result_acquireLockResult obj} then P.Nothing else P.Just $ default_Result{result_acquireLockResult = result_acquireLockResult obj}
    , if obj == default_Result{result_roleSummaryResult = result_roleSummaryResult obj} then P.Nothing else P.Just $ default_Result{result_roleSummaryResult = result_roleSummaryResult obj}
    , if obj == default_Result{result_jobSummaryResult = result_jobSummaryResult obj} then P.Nothing else P.Just $ default_Result{result_jobSummaryResult = result_jobSummaryResult obj}
    , if obj == default_Result{result_getLocksResult = result_getLocksResult obj} then P.Nothing else P.Just $ default_Result{result_getLocksResult = result_getLocksResult obj}
    , if obj == default_Result{result_configSummaryResult = result_configSummaryResult obj} then P.Nothing else P.Just $ default_Result{result_configSummaryResult = result_configSummaryResult obj}
    , if obj == default_Result{result_getPendingReasonResult = result_getPendingReasonResult obj} then P.Nothing else P.Just $ default_Result{result_getPendingReasonResult = result_getPendingReasonResult obj}
    , if obj == default_Result{result_startJobUpdateResult = result_startJobUpdateResult obj} then P.Nothing else P.Just $ default_Result{result_startJobUpdateResult = result_startJobUpdateResult obj}
    , if obj == default_Result{result_getJobUpdateSummariesResult = result_getJobUpdateSummariesResult obj} then P.Nothing else P.Just $ default_Result{result_getJobUpdateSummariesResult = result_getJobUpdateSummariesResult obj}
    , if obj == default_Result{result_getJobUpdateDetailsResult = result_getJobUpdateDetailsResult obj} then P.Nothing else P.Just $ default_Result{result_getJobUpdateDetailsResult = result_getJobUpdateDetailsResult obj}
    , if obj == default_Result{result_pulseJobUpdateResult = result_pulseJobUpdateResult obj} then P.Nothing else P.Just $ default_Result{result_pulseJobUpdateResult = result_pulseJobUpdateResult obj}
    ]
from_Result :: Result -> T.ThriftVal
from_Result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v682 -> P.Just (1, ("populateJobResult",from_PopulateJobResult _v682))) $ result_populateJobResult record
  , (\_v682 -> P.Just (3, ("scheduleStatusResult",from_ScheduleStatusResult _v682))) $ result_scheduleStatusResult record
  , (\_v682 -> P.Just (4, ("getJobsResult",from_GetJobsResult _v682))) $ result_getJobsResult record
  , (\_v682 -> P.Just (5, ("getQuotaResult",from_GetQuotaResult _v682))) $ result_getQuotaResult record
  , (\_v682 -> P.Just (6, ("listBackupsResult",from_ListBackupsResult _v682))) $ result_listBackupsResult record
  , (\_v682 -> P.Just (7, ("startMaintenanceResult",from_StartMaintenanceResult _v682))) $ result_startMaintenanceResult record
  , (\_v682 -> P.Just (8, ("drainHostsResult",from_DrainHostsResult _v682))) $ result_drainHostsResult record
  , (\_v682 -> P.Just (9, ("queryRecoveryResult",from_QueryRecoveryResult _v682))) $ result_queryRecoveryResult record
  , (\_v682 -> P.Just (10, ("maintenanceStatusResult",from_MaintenanceStatusResult _v682))) $ result_maintenanceStatusResult record
  , (\_v682 -> P.Just (11, ("endMaintenanceResult",from_EndMaintenanceResult _v682))) $ result_endMaintenanceResult record
  , (\_v682 -> P.Just (15, ("getVersionResult",from_APIVersion _v682))) $ result_getVersionResult record
  , (\_v682 -> P.Just (16, ("acquireLockResult",from_AcquireLockResult _v682))) $ result_acquireLockResult record
  , (\_v682 -> P.Just (17, ("roleSummaryResult",from_RoleSummaryResult _v682))) $ result_roleSummaryResult record
  , (\_v682 -> P.Just (18, ("jobSummaryResult",from_JobSummaryResult _v682))) $ result_jobSummaryResult record
  , (\_v682 -> P.Just (19, ("getLocksResult",from_GetLocksResult _v682))) $ result_getLocksResult record
  , (\_v682 -> P.Just (20, ("configSummaryResult",from_ConfigSummaryResult _v682))) $ result_configSummaryResult record
  , (\_v682 -> P.Just (21, ("getPendingReasonResult",from_GetPendingReasonResult _v682))) $ result_getPendingReasonResult record
  , (\_v682 -> P.Just (22, ("startJobUpdateResult",from_StartJobUpdateResult _v682))) $ result_startJobUpdateResult record
  , (\_v682 -> P.Just (23, ("getJobUpdateSummariesResult",from_GetJobUpdateSummariesResult _v682))) $ result_getJobUpdateSummariesResult record
  , (\_v682 -> P.Just (24, ("getJobUpdateDetailsResult",from_GetJobUpdateDetailsResult _v682))) $ result_getJobUpdateDetailsResult record
  , (\_v682 -> P.Just (25, ("pulseJobUpdateResult",from_PulseJobUpdateResult _v682))) $ result_pulseJobUpdateResult record
  ]
write_Result :: (T.Protocol p, T.Transport t) => p t -> Result -> P.IO ()
write_Result oprot record = T.writeVal oprot $ from_Result record
encode_Result :: (T.Protocol p, T.Transport t) => p t -> Result -> LBS.ByteString
encode_Result oprot record = T.serializeVal oprot $ from_Result record
to_Result :: T.ThriftVal -> Result
to_Result (T.TStruct fields) = Result{
  result_populateJobResult = P.maybe (result_populateJobResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val685 -> (to_PopulateJobResult (T.TStruct _val685)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  result_scheduleStatusResult = P.maybe (result_scheduleStatusResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val686 -> (to_ScheduleStatusResult (T.TStruct _val686)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  result_getJobsResult = P.maybe (result_getJobsResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val687 -> (to_GetJobsResult (T.TStruct _val687)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  result_getQuotaResult = P.maybe (result_getQuotaResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val688 -> (to_GetQuotaResult (T.TStruct _val688)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  result_listBackupsResult = P.maybe (result_listBackupsResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val689 -> (to_ListBackupsResult (T.TStruct _val689)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  result_startMaintenanceResult = P.maybe (result_startMaintenanceResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val690 -> (to_StartMaintenanceResult (T.TStruct _val690)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  result_drainHostsResult = P.maybe (result_drainHostsResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val691 -> (to_DrainHostsResult (T.TStruct _val691)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  result_queryRecoveryResult = P.maybe (result_queryRecoveryResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val692 -> (to_QueryRecoveryResult (T.TStruct _val692)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  result_maintenanceStatusResult = P.maybe (result_maintenanceStatusResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val693 -> (to_MaintenanceStatusResult (T.TStruct _val693)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  result_endMaintenanceResult = P.maybe (result_endMaintenanceResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val694 -> (to_EndMaintenanceResult (T.TStruct _val694)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  result_getVersionResult = P.maybe (result_getVersionResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val695 -> (to_APIVersion (T.TStruct _val695)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  result_acquireLockResult = P.maybe (result_acquireLockResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val696 -> (to_AcquireLockResult (T.TStruct _val696)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  result_roleSummaryResult = P.maybe (result_roleSummaryResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val697 -> (to_RoleSummaryResult (T.TStruct _val697)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  result_jobSummaryResult = P.maybe (result_jobSummaryResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val698 -> (to_JobSummaryResult (T.TStruct _val698)); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  result_getLocksResult = P.maybe (result_getLocksResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val699 -> (to_GetLocksResult (T.TStruct _val699)); _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  result_configSummaryResult = P.maybe (result_configSummaryResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val700 -> (to_ConfigSummaryResult (T.TStruct _val700)); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  result_getPendingReasonResult = P.maybe (result_getPendingReasonResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val701 -> (to_GetPendingReasonResult (T.TStruct _val701)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  result_startJobUpdateResult = P.maybe (result_startJobUpdateResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val702 -> (to_StartJobUpdateResult (T.TStruct _val702)); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  result_getJobUpdateSummariesResult = P.maybe (result_getJobUpdateSummariesResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val703 -> (to_GetJobUpdateSummariesResult (T.TStruct _val703)); _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  result_getJobUpdateDetailsResult = P.maybe (result_getJobUpdateDetailsResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val704 -> (to_GetJobUpdateDetailsResult (T.TStruct _val704)); _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  result_pulseJobUpdateResult = P.maybe (result_pulseJobUpdateResult default_Result) (\(_,_val684) -> (case _val684 of {T.TStruct _val705 -> (to_PulseJobUpdateResult (T.TStruct _val705)); _ -> P.error "wrong type"})) (Map.lookup (25) fields)
  }
to_Result _ = P.error "not a struct"
read_Result :: (T.Transport t, T.Protocol p) => p t -> P.IO Result
read_Result iprot = to_Result <$> T.readVal iprot (T.T_STRUCT typemap_Result)
decode_Result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Result
decode_Result iprot bs = to_Result $ T.deserializeVal iprot (T.T_STRUCT typemap_Result) bs
typemap_Result :: T.TypeMap
typemap_Result = Map.fromList [(1,("populateJobResult",(T.T_STRUCT typemap_PopulateJobResult))),(3,("scheduleStatusResult",(T.T_STRUCT typemap_ScheduleStatusResult))),(4,("getJobsResult",(T.T_STRUCT typemap_GetJobsResult))),(5,("getQuotaResult",(T.T_STRUCT typemap_GetQuotaResult))),(6,("listBackupsResult",(T.T_STRUCT typemap_ListBackupsResult))),(7,("startMaintenanceResult",(T.T_STRUCT typemap_StartMaintenanceResult))),(8,("drainHostsResult",(T.T_STRUCT typemap_DrainHostsResult))),(9,("queryRecoveryResult",(T.T_STRUCT typemap_QueryRecoveryResult))),(10,("maintenanceStatusResult",(T.T_STRUCT typemap_MaintenanceStatusResult))),(11,("endMaintenanceResult",(T.T_STRUCT typemap_EndMaintenanceResult))),(15,("getVersionResult",(T.T_STRUCT typemap_APIVersion))),(16,("acquireLockResult",(T.T_STRUCT typemap_AcquireLockResult))),(17,("roleSummaryResult",(T.T_STRUCT typemap_RoleSummaryResult))),(18,("jobSummaryResult",(T.T_STRUCT typemap_JobSummaryResult))),(19,("getLocksResult",(T.T_STRUCT typemap_GetLocksResult))),(20,("configSummaryResult",(T.T_STRUCT typemap_ConfigSummaryResult))),(21,("getPendingReasonResult",(T.T_STRUCT typemap_GetPendingReasonResult))),(22,("startJobUpdateResult",(T.T_STRUCT typemap_StartJobUpdateResult))),(23,("getJobUpdateSummariesResult",(T.T_STRUCT typemap_GetJobUpdateSummariesResult))),(24,("getJobUpdateDetailsResult",(T.T_STRUCT typemap_GetJobUpdateDetailsResult))),(25,("pulseJobUpdateResult",(T.T_STRUCT typemap_PulseJobUpdateResult)))]
default_Result :: Result
default_Result = Result{
  result_populateJobResult = default_PopulateJobResult,
  result_scheduleStatusResult = default_ScheduleStatusResult,
  result_getJobsResult = default_GetJobsResult,
  result_getQuotaResult = default_GetQuotaResult,
  result_listBackupsResult = default_ListBackupsResult,
  result_startMaintenanceResult = default_StartMaintenanceResult,
  result_drainHostsResult = default_DrainHostsResult,
  result_queryRecoveryResult = default_QueryRecoveryResult,
  result_maintenanceStatusResult = default_MaintenanceStatusResult,
  result_endMaintenanceResult = default_EndMaintenanceResult,
  result_getVersionResult = default_APIVersion,
  result_acquireLockResult = default_AcquireLockResult,
  result_roleSummaryResult = default_RoleSummaryResult,
  result_jobSummaryResult = default_JobSummaryResult,
  result_getLocksResult = default_GetLocksResult,
  result_configSummaryResult = default_ConfigSummaryResult,
  result_getPendingReasonResult = default_GetPendingReasonResult,
  result_startJobUpdateResult = default_StartJobUpdateResult,
  result_getJobUpdateSummariesResult = default_GetJobUpdateSummariesResult,
  result_getJobUpdateDetailsResult = default_GetJobUpdateDetailsResult,
  result_pulseJobUpdateResult = default_PulseJobUpdateResult}
data ResponseDetail = ResponseDetail  { responseDetail_message :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ResponseDetail where
  hashWithSalt salt record = salt   `H.hashWithSalt` responseDetail_message record  
instance QC.Arbitrary ResponseDetail where 
  arbitrary = M.liftM ResponseDetail (QC.arbitrary)
  shrink obj | obj == default_ResponseDetail = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResponseDetail{responseDetail_message = responseDetail_message obj} then P.Nothing else P.Just $ default_ResponseDetail{responseDetail_message = responseDetail_message obj}
    ]
from_ResponseDetail :: ResponseDetail -> T.ThriftVal
from_ResponseDetail record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v708 -> P.Just (1, ("message",T.TString $ E.encodeUtf8 _v708))) $ responseDetail_message record
  ]
write_ResponseDetail :: (T.Protocol p, T.Transport t) => p t -> ResponseDetail -> P.IO ()
write_ResponseDetail oprot record = T.writeVal oprot $ from_ResponseDetail record
encode_ResponseDetail :: (T.Protocol p, T.Transport t) => p t -> ResponseDetail -> LBS.ByteString
encode_ResponseDetail oprot record = T.serializeVal oprot $ from_ResponseDetail record
to_ResponseDetail :: T.ThriftVal -> ResponseDetail
to_ResponseDetail (T.TStruct fields) = ResponseDetail{
  responseDetail_message = P.maybe (responseDetail_message default_ResponseDetail) (\(_,_val710) -> (case _val710 of {T.TString _val711 -> E.decodeUtf8 _val711; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResponseDetail _ = P.error "not a struct"
read_ResponseDetail :: (T.Transport t, T.Protocol p) => p t -> P.IO ResponseDetail
read_ResponseDetail iprot = to_ResponseDetail <$> T.readVal iprot (T.T_STRUCT typemap_ResponseDetail)
decode_ResponseDetail :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ResponseDetail
decode_ResponseDetail iprot bs = to_ResponseDetail $ T.deserializeVal iprot (T.T_STRUCT typemap_ResponseDetail) bs
typemap_ResponseDetail :: T.TypeMap
typemap_ResponseDetail = Map.fromList [(1,("message",T.T_STRING))]
default_ResponseDetail :: ResponseDetail
default_ResponseDetail = ResponseDetail{
  responseDetail_message = ""}
data Response = Response  { response_responseCode :: ResponseCode
  , response_serverInfo :: ServerInfo
  , response_result :: P.Maybe Result
  , response_details :: (Vector.Vector ResponseDetail)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Response where
  hashWithSalt salt record = salt   `H.hashWithSalt` response_responseCode record   `H.hashWithSalt` response_serverInfo record   `H.hashWithSalt` response_result record   `H.hashWithSalt` response_details record  
instance QC.Arbitrary Response where 
  arbitrary = M.liftM Response (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Response = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Response{response_responseCode = response_responseCode obj} then P.Nothing else P.Just $ default_Response{response_responseCode = response_responseCode obj}
    , if obj == default_Response{response_serverInfo = response_serverInfo obj} then P.Nothing else P.Just $ default_Response{response_serverInfo = response_serverInfo obj}
    , if obj == default_Response{response_result = response_result obj} then P.Nothing else P.Just $ default_Response{response_result = response_result obj}
    , if obj == default_Response{response_details = response_details obj} then P.Nothing else P.Just $ default_Response{response_details = response_details obj}
    ]
from_Response :: Response -> T.ThriftVal
from_Response record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v714 -> P.Just (1, ("responseCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v714))) $ response_responseCode record
  , (\_v714 -> (3, ("result",from_Result _v714))) <$> response_result record
  , (\_v714 -> P.Just (5, ("serverInfo",from_ServerInfo _v714))) $ response_serverInfo record
  , (\_v714 -> P.Just (6, ("details",T.TList (T.T_STRUCT typemap_ResponseDetail) $ P.map (\_v716 -> from_ResponseDetail _v716) $ Vector.toList _v714))) $ response_details record
  ]
write_Response :: (T.Protocol p, T.Transport t) => p t -> Response -> P.IO ()
write_Response oprot record = T.writeVal oprot $ from_Response record
encode_Response :: (T.Protocol p, T.Transport t) => p t -> Response -> LBS.ByteString
encode_Response oprot record = T.serializeVal oprot $ from_Response record
to_Response :: T.ThriftVal -> Response
to_Response (T.TStruct fields) = Response{
  response_responseCode = P.maybe (response_responseCode default_Response) (\(_,_val718) -> (case _val718 of {T.TI32 _val719 -> P.toEnum $ P.fromIntegral _val719; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  response_serverInfo = P.maybe (response_serverInfo default_Response) (\(_,_val718) -> (case _val718 of {T.TStruct _val720 -> (to_ServerInfo (T.TStruct _val720)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  response_result = P.maybe (P.Nothing) (\(_,_val718) -> P.Just (case _val718 of {T.TStruct _val721 -> (to_Result (T.TStruct _val721)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  response_details = P.maybe (response_details default_Response) (\(_,_val718) -> (case _val718 of {T.TList _ _val722 -> (Vector.fromList $ P.map (\_v723 -> (case _v723 of {T.TStruct _val724 -> (to_ResponseDetail (T.TStruct _val724)); _ -> P.error "wrong type"})) _val722); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_Response _ = P.error "not a struct"
read_Response :: (T.Transport t, T.Protocol p) => p t -> P.IO Response
read_Response iprot = to_Response <$> T.readVal iprot (T.T_STRUCT typemap_Response)
decode_Response :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Response
decode_Response iprot bs = to_Response $ T.deserializeVal iprot (T.T_STRUCT typemap_Response) bs
typemap_Response :: T.TypeMap
typemap_Response = Map.fromList [(1,("responseCode",T.T_I32)),(3,("result",(T.T_STRUCT typemap_Result))),(5,("serverInfo",(T.T_STRUCT typemap_ServerInfo))),(6,("details",(T.T_LIST (T.T_STRUCT typemap_ResponseDetail))))]
default_Response :: Response
default_Response = Response{
  response_responseCode = (P.toEnum 0),
  response_result = P.Nothing,
  response_serverInfo = default_ServerInfo,
  response_details = Vector.empty}
data InstanceConfigRewrite = InstanceConfigRewrite  { instanceConfigRewrite_instanceKey :: InstanceKey
  , instanceConfigRewrite_oldTask :: TaskConfig
  , instanceConfigRewrite_rewrittenTask :: TaskConfig
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable InstanceConfigRewrite where
  hashWithSalt salt record = salt   `H.hashWithSalt` instanceConfigRewrite_instanceKey record   `H.hashWithSalt` instanceConfigRewrite_oldTask record   `H.hashWithSalt` instanceConfigRewrite_rewrittenTask record  
instance QC.Arbitrary InstanceConfigRewrite where 
  arbitrary = M.liftM InstanceConfigRewrite (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InstanceConfigRewrite = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InstanceConfigRewrite{instanceConfigRewrite_instanceKey = instanceConfigRewrite_instanceKey obj} then P.Nothing else P.Just $ default_InstanceConfigRewrite{instanceConfigRewrite_instanceKey = instanceConfigRewrite_instanceKey obj}
    , if obj == default_InstanceConfigRewrite{instanceConfigRewrite_oldTask = instanceConfigRewrite_oldTask obj} then P.Nothing else P.Just $ default_InstanceConfigRewrite{instanceConfigRewrite_oldTask = instanceConfigRewrite_oldTask obj}
    , if obj == default_InstanceConfigRewrite{instanceConfigRewrite_rewrittenTask = instanceConfigRewrite_rewrittenTask obj} then P.Nothing else P.Just $ default_InstanceConfigRewrite{instanceConfigRewrite_rewrittenTask = instanceConfigRewrite_rewrittenTask obj}
    ]
from_InstanceConfigRewrite :: InstanceConfigRewrite -> T.ThriftVal
from_InstanceConfigRewrite record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v727 -> P.Just (1, ("instanceKey",from_InstanceKey _v727))) $ instanceConfigRewrite_instanceKey record
  , (\_v727 -> P.Just (2, ("oldTask",from_TaskConfig _v727))) $ instanceConfigRewrite_oldTask record
  , (\_v727 -> P.Just (3, ("rewrittenTask",from_TaskConfig _v727))) $ instanceConfigRewrite_rewrittenTask record
  ]
write_InstanceConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> InstanceConfigRewrite -> P.IO ()
write_InstanceConfigRewrite oprot record = T.writeVal oprot $ from_InstanceConfigRewrite record
encode_InstanceConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> InstanceConfigRewrite -> LBS.ByteString
encode_InstanceConfigRewrite oprot record = T.serializeVal oprot $ from_InstanceConfigRewrite record
to_InstanceConfigRewrite :: T.ThriftVal -> InstanceConfigRewrite
to_InstanceConfigRewrite (T.TStruct fields) = InstanceConfigRewrite{
  instanceConfigRewrite_instanceKey = P.maybe (instanceConfigRewrite_instanceKey default_InstanceConfigRewrite) (\(_,_val729) -> (case _val729 of {T.TStruct _val730 -> (to_InstanceKey (T.TStruct _val730)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  instanceConfigRewrite_oldTask = P.maybe (instanceConfigRewrite_oldTask default_InstanceConfigRewrite) (\(_,_val729) -> (case _val729 of {T.TStruct _val731 -> (to_TaskConfig (T.TStruct _val731)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  instanceConfigRewrite_rewrittenTask = P.maybe (instanceConfigRewrite_rewrittenTask default_InstanceConfigRewrite) (\(_,_val729) -> (case _val729 of {T.TStruct _val732 -> (to_TaskConfig (T.TStruct _val732)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InstanceConfigRewrite _ = P.error "not a struct"
read_InstanceConfigRewrite :: (T.Transport t, T.Protocol p) => p t -> P.IO InstanceConfigRewrite
read_InstanceConfigRewrite iprot = to_InstanceConfigRewrite <$> T.readVal iprot (T.T_STRUCT typemap_InstanceConfigRewrite)
decode_InstanceConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> InstanceConfigRewrite
decode_InstanceConfigRewrite iprot bs = to_InstanceConfigRewrite $ T.deserializeVal iprot (T.T_STRUCT typemap_InstanceConfigRewrite) bs
typemap_InstanceConfigRewrite :: T.TypeMap
typemap_InstanceConfigRewrite = Map.fromList [(1,("instanceKey",(T.T_STRUCT typemap_InstanceKey))),(2,("oldTask",(T.T_STRUCT typemap_TaskConfig))),(3,("rewrittenTask",(T.T_STRUCT typemap_TaskConfig)))]
default_InstanceConfigRewrite :: InstanceConfigRewrite
default_InstanceConfigRewrite = InstanceConfigRewrite{
  instanceConfigRewrite_instanceKey = default_InstanceKey,
  instanceConfigRewrite_oldTask = default_TaskConfig,
  instanceConfigRewrite_rewrittenTask = default_TaskConfig}
data JobConfigRewrite = JobConfigRewrite  { jobConfigRewrite_oldJob :: JobConfiguration
  , jobConfigRewrite_rewrittenJob :: JobConfiguration
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable JobConfigRewrite where
  hashWithSalt salt record = salt   `H.hashWithSalt` jobConfigRewrite_oldJob record   `H.hashWithSalt` jobConfigRewrite_rewrittenJob record  
instance QC.Arbitrary JobConfigRewrite where 
  arbitrary = M.liftM JobConfigRewrite (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JobConfigRewrite = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JobConfigRewrite{jobConfigRewrite_oldJob = jobConfigRewrite_oldJob obj} then P.Nothing else P.Just $ default_JobConfigRewrite{jobConfigRewrite_oldJob = jobConfigRewrite_oldJob obj}
    , if obj == default_JobConfigRewrite{jobConfigRewrite_rewrittenJob = jobConfigRewrite_rewrittenJob obj} then P.Nothing else P.Just $ default_JobConfigRewrite{jobConfigRewrite_rewrittenJob = jobConfigRewrite_rewrittenJob obj}
    ]
from_JobConfigRewrite :: JobConfigRewrite -> T.ThriftVal
from_JobConfigRewrite record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v735 -> P.Just (1, ("oldJob",from_JobConfiguration _v735))) $ jobConfigRewrite_oldJob record
  , (\_v735 -> P.Just (2, ("rewrittenJob",from_JobConfiguration _v735))) $ jobConfigRewrite_rewrittenJob record
  ]
write_JobConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> JobConfigRewrite -> P.IO ()
write_JobConfigRewrite oprot record = T.writeVal oprot $ from_JobConfigRewrite record
encode_JobConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> JobConfigRewrite -> LBS.ByteString
encode_JobConfigRewrite oprot record = T.serializeVal oprot $ from_JobConfigRewrite record
to_JobConfigRewrite :: T.ThriftVal -> JobConfigRewrite
to_JobConfigRewrite (T.TStruct fields) = JobConfigRewrite{
  jobConfigRewrite_oldJob = P.maybe (jobConfigRewrite_oldJob default_JobConfigRewrite) (\(_,_val737) -> (case _val737 of {T.TStruct _val738 -> (to_JobConfiguration (T.TStruct _val738)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  jobConfigRewrite_rewrittenJob = P.maybe (jobConfigRewrite_rewrittenJob default_JobConfigRewrite) (\(_,_val737) -> (case _val737 of {T.TStruct _val739 -> (to_JobConfiguration (T.TStruct _val739)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_JobConfigRewrite _ = P.error "not a struct"
read_JobConfigRewrite :: (T.Transport t, T.Protocol p) => p t -> P.IO JobConfigRewrite
read_JobConfigRewrite iprot = to_JobConfigRewrite <$> T.readVal iprot (T.T_STRUCT typemap_JobConfigRewrite)
decode_JobConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> JobConfigRewrite
decode_JobConfigRewrite iprot bs = to_JobConfigRewrite $ T.deserializeVal iprot (T.T_STRUCT typemap_JobConfigRewrite) bs
typemap_JobConfigRewrite :: T.TypeMap
typemap_JobConfigRewrite = Map.fromList [(1,("oldJob",(T.T_STRUCT typemap_JobConfiguration))),(2,("rewrittenJob",(T.T_STRUCT typemap_JobConfiguration)))]
default_JobConfigRewrite :: JobConfigRewrite
default_JobConfigRewrite = JobConfigRewrite{
  jobConfigRewrite_oldJob = default_JobConfiguration,
  jobConfigRewrite_rewrittenJob = default_JobConfiguration}
data ConfigRewrite = ConfigRewrite  { configRewrite_jobRewrite :: JobConfigRewrite
  , configRewrite_instanceRewrite :: InstanceConfigRewrite
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ConfigRewrite where
  hashWithSalt salt record = salt   `H.hashWithSalt` configRewrite_jobRewrite record   `H.hashWithSalt` configRewrite_instanceRewrite record  
instance QC.Arbitrary ConfigRewrite where 
  arbitrary = M.liftM ConfigRewrite (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfigRewrite = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfigRewrite{configRewrite_jobRewrite = configRewrite_jobRewrite obj} then P.Nothing else P.Just $ default_ConfigRewrite{configRewrite_jobRewrite = configRewrite_jobRewrite obj}
    , if obj == default_ConfigRewrite{configRewrite_instanceRewrite = configRewrite_instanceRewrite obj} then P.Nothing else P.Just $ default_ConfigRewrite{configRewrite_instanceRewrite = configRewrite_instanceRewrite obj}
    ]
from_ConfigRewrite :: ConfigRewrite -> T.ThriftVal
from_ConfigRewrite record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v742 -> P.Just (1, ("jobRewrite",from_JobConfigRewrite _v742))) $ configRewrite_jobRewrite record
  , (\_v742 -> P.Just (2, ("instanceRewrite",from_InstanceConfigRewrite _v742))) $ configRewrite_instanceRewrite record
  ]
write_ConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> ConfigRewrite -> P.IO ()
write_ConfigRewrite oprot record = T.writeVal oprot $ from_ConfigRewrite record
encode_ConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> ConfigRewrite -> LBS.ByteString
encode_ConfigRewrite oprot record = T.serializeVal oprot $ from_ConfigRewrite record
to_ConfigRewrite :: T.ThriftVal -> ConfigRewrite
to_ConfigRewrite (T.TStruct fields) = ConfigRewrite{
  configRewrite_jobRewrite = P.maybe (configRewrite_jobRewrite default_ConfigRewrite) (\(_,_val744) -> (case _val744 of {T.TStruct _val745 -> (to_JobConfigRewrite (T.TStruct _val745)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  configRewrite_instanceRewrite = P.maybe (configRewrite_instanceRewrite default_ConfigRewrite) (\(_,_val744) -> (case _val744 of {T.TStruct _val746 -> (to_InstanceConfigRewrite (T.TStruct _val746)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConfigRewrite _ = P.error "not a struct"
read_ConfigRewrite :: (T.Transport t, T.Protocol p) => p t -> P.IO ConfigRewrite
read_ConfigRewrite iprot = to_ConfigRewrite <$> T.readVal iprot (T.T_STRUCT typemap_ConfigRewrite)
decode_ConfigRewrite :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ConfigRewrite
decode_ConfigRewrite iprot bs = to_ConfigRewrite $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfigRewrite) bs
typemap_ConfigRewrite :: T.TypeMap
typemap_ConfigRewrite = Map.fromList [(1,("jobRewrite",(T.T_STRUCT typemap_JobConfigRewrite))),(2,("instanceRewrite",(T.T_STRUCT typemap_InstanceConfigRewrite)))]
default_ConfigRewrite :: ConfigRewrite
default_ConfigRewrite = ConfigRewrite{
  configRewrite_jobRewrite = default_JobConfigRewrite,
  configRewrite_instanceRewrite = default_InstanceConfigRewrite}
data RewriteConfigsRequest = RewriteConfigsRequest  { rewriteConfigsRequest_rewriteCommands :: (Vector.Vector ConfigRewrite)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RewriteConfigsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` rewriteConfigsRequest_rewriteCommands record  
instance QC.Arbitrary RewriteConfigsRequest where 
  arbitrary = M.liftM RewriteConfigsRequest (QC.arbitrary)
  shrink obj | obj == default_RewriteConfigsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RewriteConfigsRequest{rewriteConfigsRequest_rewriteCommands = rewriteConfigsRequest_rewriteCommands obj} then P.Nothing else P.Just $ default_RewriteConfigsRequest{rewriteConfigsRequest_rewriteCommands = rewriteConfigsRequest_rewriteCommands obj}
    ]
from_RewriteConfigsRequest :: RewriteConfigsRequest -> T.ThriftVal
from_RewriteConfigsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v749 -> P.Just (1, ("rewriteCommands",T.TList (T.T_STRUCT typemap_ConfigRewrite) $ P.map (\_v751 -> from_ConfigRewrite _v751) $ Vector.toList _v749))) $ rewriteConfigsRequest_rewriteCommands record
  ]
write_RewriteConfigsRequest :: (T.Protocol p, T.Transport t) => p t -> RewriteConfigsRequest -> P.IO ()
write_RewriteConfigsRequest oprot record = T.writeVal oprot $ from_RewriteConfigsRequest record
encode_RewriteConfigsRequest :: (T.Protocol p, T.Transport t) => p t -> RewriteConfigsRequest -> LBS.ByteString
encode_RewriteConfigsRequest oprot record = T.serializeVal oprot $ from_RewriteConfigsRequest record
to_RewriteConfigsRequest :: T.ThriftVal -> RewriteConfigsRequest
to_RewriteConfigsRequest (T.TStruct fields) = RewriteConfigsRequest{
  rewriteConfigsRequest_rewriteCommands = P.maybe (rewriteConfigsRequest_rewriteCommands default_RewriteConfigsRequest) (\(_,_val753) -> (case _val753 of {T.TList _ _val754 -> (Vector.fromList $ P.map (\_v755 -> (case _v755 of {T.TStruct _val756 -> (to_ConfigRewrite (T.TStruct _val756)); _ -> P.error "wrong type"})) _val754); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RewriteConfigsRequest _ = P.error "not a struct"
read_RewriteConfigsRequest :: (T.Transport t, T.Protocol p) => p t -> P.IO RewriteConfigsRequest
read_RewriteConfigsRequest iprot = to_RewriteConfigsRequest <$> T.readVal iprot (T.T_STRUCT typemap_RewriteConfigsRequest)
decode_RewriteConfigsRequest :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RewriteConfigsRequest
decode_RewriteConfigsRequest iprot bs = to_RewriteConfigsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_RewriteConfigsRequest) bs
typemap_RewriteConfigsRequest :: T.TypeMap
typemap_RewriteConfigsRequest = Map.fromList [(1,("rewriteCommands",(T.T_LIST (T.T_STRUCT typemap_ConfigRewrite))))]
default_RewriteConfigsRequest :: RewriteConfigsRequest
default_RewriteConfigsRequest = RewriteConfigsRequest{
  rewriteConfigsRequest_rewriteCommands = Vector.empty}
