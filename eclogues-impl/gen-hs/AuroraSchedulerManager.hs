{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AuroraSchedulerManager where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import qualified ReadOnlyScheduler
import Api_Types
import qualified AuroraSchedulerManager_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data CreateJob_args = CreateJob_args  { createJob_args_description :: JobConfiguration
  , createJob_args_lock :: P.Maybe Lock
  , createJob_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable CreateJob_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createJob_args_description record   `H.hashWithSalt` createJob_args_lock record   `H.hashWithSalt` createJob_args_session record  
instance QC.Arbitrary CreateJob_args where 
  arbitrary = M.liftM CreateJob_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateJob_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateJob_args{createJob_args_description = createJob_args_description obj} then P.Nothing else P.Just $ default_CreateJob_args{createJob_args_description = createJob_args_description obj}
    , if obj == default_CreateJob_args{createJob_args_lock = createJob_args_lock obj} then P.Nothing else P.Just $ default_CreateJob_args{createJob_args_lock = createJob_args_lock obj}
    , if obj == default_CreateJob_args{createJob_args_session = createJob_args_session obj} then P.Nothing else P.Just $ default_CreateJob_args{createJob_args_session = createJob_args_session obj}
    ]
from_CreateJob_args :: CreateJob_args -> T.ThriftVal
from_CreateJob_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v901 -> P.Just (1, ("description",from_JobConfiguration _v901))) $ createJob_args_description record
  , (\_v901 -> P.Just (2, ("session",from_SessionKey _v901))) $ createJob_args_session record
  , (\_v901 -> (3, ("lock",from_Lock _v901))) <$> createJob_args_lock record
  ]
write_CreateJob_args :: (T.Protocol p, T.Transport t) => p t -> CreateJob_args -> P.IO ()
write_CreateJob_args oprot record = T.writeVal oprot $ from_CreateJob_args record
encode_CreateJob_args :: (T.Protocol p, T.Transport t) => p t -> CreateJob_args -> LBS.ByteString
encode_CreateJob_args oprot record = T.serializeVal oprot $ from_CreateJob_args record
to_CreateJob_args :: T.ThriftVal -> CreateJob_args
to_CreateJob_args (T.TStruct fields) = CreateJob_args{
  createJob_args_description = P.maybe (createJob_args_description default_CreateJob_args) (\(_,_val903) -> (case _val903 of {T.TStruct _val904 -> (to_JobConfiguration (T.TStruct _val904)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createJob_args_lock = P.maybe (createJob_args_lock default_CreateJob_args) (\(_,_val903) -> P.Just (case _val903 of {T.TStruct _val905 -> (to_Lock (T.TStruct _val905)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createJob_args_session = P.maybe (createJob_args_session default_CreateJob_args) (\(_,_val903) -> (case _val903 of {T.TStruct _val906 -> (to_SessionKey (T.TStruct _val906)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateJob_args _ = P.error "not a struct"
read_CreateJob_args :: (T.Transport t, T.Protocol p) => p t -> P.IO CreateJob_args
read_CreateJob_args iprot = to_CreateJob_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateJob_args)
decode_CreateJob_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CreateJob_args
decode_CreateJob_args iprot bs = to_CreateJob_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateJob_args) bs
typemap_CreateJob_args :: T.TypeMap
typemap_CreateJob_args = Map.fromList [(1,("description",(T.T_STRUCT typemap_JobConfiguration))),(2,("session",(T.T_STRUCT typemap_SessionKey))),(3,("lock",(T.T_STRUCT typemap_Lock)))]
default_CreateJob_args :: CreateJob_args
default_CreateJob_args = CreateJob_args{
  createJob_args_description = default_JobConfiguration,
  createJob_args_session = default_SessionKey,
  createJob_args_lock = P.Nothing}
data CreateJob_result = CreateJob_result  { createJob_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable CreateJob_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createJob_result_success record  
instance QC.Arbitrary CreateJob_result where 
  arbitrary = M.liftM CreateJob_result (QC.arbitrary)
  shrink obj | obj == default_CreateJob_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateJob_result{createJob_result_success = createJob_result_success obj} then P.Nothing else P.Just $ default_CreateJob_result{createJob_result_success = createJob_result_success obj}
    ]
from_CreateJob_result :: CreateJob_result -> T.ThriftVal
from_CreateJob_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v909 -> P.Just (0, ("success",from_Response _v909))) $ createJob_result_success record
  ]
write_CreateJob_result :: (T.Protocol p, T.Transport t) => p t -> CreateJob_result -> P.IO ()
write_CreateJob_result oprot record = T.writeVal oprot $ from_CreateJob_result record
encode_CreateJob_result :: (T.Protocol p, T.Transport t) => p t -> CreateJob_result -> LBS.ByteString
encode_CreateJob_result oprot record = T.serializeVal oprot $ from_CreateJob_result record
to_CreateJob_result :: T.ThriftVal -> CreateJob_result
to_CreateJob_result (T.TStruct fields) = CreateJob_result{
  createJob_result_success = P.maybe (createJob_result_success default_CreateJob_result) (\(_,_val911) -> (case _val911 of {T.TStruct _val912 -> (to_Response (T.TStruct _val912)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_CreateJob_result _ = P.error "not a struct"
read_CreateJob_result :: (T.Transport t, T.Protocol p) => p t -> P.IO CreateJob_result
read_CreateJob_result iprot = to_CreateJob_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateJob_result)
decode_CreateJob_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CreateJob_result
decode_CreateJob_result iprot bs = to_CreateJob_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateJob_result) bs
typemap_CreateJob_result :: T.TypeMap
typemap_CreateJob_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_CreateJob_result :: CreateJob_result
default_CreateJob_result = CreateJob_result{
  createJob_result_success = default_Response}
data ScheduleCronJob_args = ScheduleCronJob_args  { scheduleCronJob_args_description :: JobConfiguration
  , scheduleCronJob_args_lock :: Lock
  , scheduleCronJob_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ScheduleCronJob_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` scheduleCronJob_args_description record   `H.hashWithSalt` scheduleCronJob_args_lock record   `H.hashWithSalt` scheduleCronJob_args_session record  
instance QC.Arbitrary ScheduleCronJob_args where 
  arbitrary = M.liftM ScheduleCronJob_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ScheduleCronJob_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ScheduleCronJob_args{scheduleCronJob_args_description = scheduleCronJob_args_description obj} then P.Nothing else P.Just $ default_ScheduleCronJob_args{scheduleCronJob_args_description = scheduleCronJob_args_description obj}
    , if obj == default_ScheduleCronJob_args{scheduleCronJob_args_lock = scheduleCronJob_args_lock obj} then P.Nothing else P.Just $ default_ScheduleCronJob_args{scheduleCronJob_args_lock = scheduleCronJob_args_lock obj}
    , if obj == default_ScheduleCronJob_args{scheduleCronJob_args_session = scheduleCronJob_args_session obj} then P.Nothing else P.Just $ default_ScheduleCronJob_args{scheduleCronJob_args_session = scheduleCronJob_args_session obj}
    ]
from_ScheduleCronJob_args :: ScheduleCronJob_args -> T.ThriftVal
from_ScheduleCronJob_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v915 -> P.Just (1, ("description",from_JobConfiguration _v915))) $ scheduleCronJob_args_description record
  , (\_v915 -> P.Just (2, ("session",from_SessionKey _v915))) $ scheduleCronJob_args_session record
  , (\_v915 -> P.Just (3, ("lock",from_Lock _v915))) $ scheduleCronJob_args_lock record
  ]
write_ScheduleCronJob_args :: (T.Protocol p, T.Transport t) => p t -> ScheduleCronJob_args -> P.IO ()
write_ScheduleCronJob_args oprot record = T.writeVal oprot $ from_ScheduleCronJob_args record
encode_ScheduleCronJob_args :: (T.Protocol p, T.Transport t) => p t -> ScheduleCronJob_args -> LBS.ByteString
encode_ScheduleCronJob_args oprot record = T.serializeVal oprot $ from_ScheduleCronJob_args record
to_ScheduleCronJob_args :: T.ThriftVal -> ScheduleCronJob_args
to_ScheduleCronJob_args (T.TStruct fields) = ScheduleCronJob_args{
  scheduleCronJob_args_description = P.maybe (scheduleCronJob_args_description default_ScheduleCronJob_args) (\(_,_val917) -> (case _val917 of {T.TStruct _val918 -> (to_JobConfiguration (T.TStruct _val918)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  scheduleCronJob_args_lock = P.maybe (scheduleCronJob_args_lock default_ScheduleCronJob_args) (\(_,_val917) -> (case _val917 of {T.TStruct _val919 -> (to_Lock (T.TStruct _val919)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  scheduleCronJob_args_session = P.maybe (scheduleCronJob_args_session default_ScheduleCronJob_args) (\(_,_val917) -> (case _val917 of {T.TStruct _val920 -> (to_SessionKey (T.TStruct _val920)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ScheduleCronJob_args _ = P.error "not a struct"
read_ScheduleCronJob_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ScheduleCronJob_args
read_ScheduleCronJob_args iprot = to_ScheduleCronJob_args <$> T.readVal iprot (T.T_STRUCT typemap_ScheduleCronJob_args)
decode_ScheduleCronJob_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ScheduleCronJob_args
decode_ScheduleCronJob_args iprot bs = to_ScheduleCronJob_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ScheduleCronJob_args) bs
typemap_ScheduleCronJob_args :: T.TypeMap
typemap_ScheduleCronJob_args = Map.fromList [(1,("description",(T.T_STRUCT typemap_JobConfiguration))),(2,("session",(T.T_STRUCT typemap_SessionKey))),(3,("lock",(T.T_STRUCT typemap_Lock)))]
default_ScheduleCronJob_args :: ScheduleCronJob_args
default_ScheduleCronJob_args = ScheduleCronJob_args{
  scheduleCronJob_args_description = default_JobConfiguration,
  scheduleCronJob_args_session = default_SessionKey,
  scheduleCronJob_args_lock = default_Lock}
data ScheduleCronJob_result = ScheduleCronJob_result  { scheduleCronJob_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ScheduleCronJob_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` scheduleCronJob_result_success record  
instance QC.Arbitrary ScheduleCronJob_result where 
  arbitrary = M.liftM ScheduleCronJob_result (QC.arbitrary)
  shrink obj | obj == default_ScheduleCronJob_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ScheduleCronJob_result{scheduleCronJob_result_success = scheduleCronJob_result_success obj} then P.Nothing else P.Just $ default_ScheduleCronJob_result{scheduleCronJob_result_success = scheduleCronJob_result_success obj}
    ]
from_ScheduleCronJob_result :: ScheduleCronJob_result -> T.ThriftVal
from_ScheduleCronJob_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v923 -> P.Just (0, ("success",from_Response _v923))) $ scheduleCronJob_result_success record
  ]
write_ScheduleCronJob_result :: (T.Protocol p, T.Transport t) => p t -> ScheduleCronJob_result -> P.IO ()
write_ScheduleCronJob_result oprot record = T.writeVal oprot $ from_ScheduleCronJob_result record
encode_ScheduleCronJob_result :: (T.Protocol p, T.Transport t) => p t -> ScheduleCronJob_result -> LBS.ByteString
encode_ScheduleCronJob_result oprot record = T.serializeVal oprot $ from_ScheduleCronJob_result record
to_ScheduleCronJob_result :: T.ThriftVal -> ScheduleCronJob_result
to_ScheduleCronJob_result (T.TStruct fields) = ScheduleCronJob_result{
  scheduleCronJob_result_success = P.maybe (scheduleCronJob_result_success default_ScheduleCronJob_result) (\(_,_val925) -> (case _val925 of {T.TStruct _val926 -> (to_Response (T.TStruct _val926)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_ScheduleCronJob_result _ = P.error "not a struct"
read_ScheduleCronJob_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ScheduleCronJob_result
read_ScheduleCronJob_result iprot = to_ScheduleCronJob_result <$> T.readVal iprot (T.T_STRUCT typemap_ScheduleCronJob_result)
decode_ScheduleCronJob_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ScheduleCronJob_result
decode_ScheduleCronJob_result iprot bs = to_ScheduleCronJob_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ScheduleCronJob_result) bs
typemap_ScheduleCronJob_result :: T.TypeMap
typemap_ScheduleCronJob_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_ScheduleCronJob_result :: ScheduleCronJob_result
default_ScheduleCronJob_result = ScheduleCronJob_result{
  scheduleCronJob_result_success = default_Response}
data DescheduleCronJob_args = DescheduleCronJob_args  { descheduleCronJob_args_job :: JobKey
  , descheduleCronJob_args_lock :: Lock
  , descheduleCronJob_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DescheduleCronJob_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` descheduleCronJob_args_job record   `H.hashWithSalt` descheduleCronJob_args_lock record   `H.hashWithSalt` descheduleCronJob_args_session record  
instance QC.Arbitrary DescheduleCronJob_args where 
  arbitrary = M.liftM DescheduleCronJob_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DescheduleCronJob_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DescheduleCronJob_args{descheduleCronJob_args_job = descheduleCronJob_args_job obj} then P.Nothing else P.Just $ default_DescheduleCronJob_args{descheduleCronJob_args_job = descheduleCronJob_args_job obj}
    , if obj == default_DescheduleCronJob_args{descheduleCronJob_args_lock = descheduleCronJob_args_lock obj} then P.Nothing else P.Just $ default_DescheduleCronJob_args{descheduleCronJob_args_lock = descheduleCronJob_args_lock obj}
    , if obj == default_DescheduleCronJob_args{descheduleCronJob_args_session = descheduleCronJob_args_session obj} then P.Nothing else P.Just $ default_DescheduleCronJob_args{descheduleCronJob_args_session = descheduleCronJob_args_session obj}
    ]
from_DescheduleCronJob_args :: DescheduleCronJob_args -> T.ThriftVal
from_DescheduleCronJob_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v929 -> P.Just (2, ("session",from_SessionKey _v929))) $ descheduleCronJob_args_session record
  , (\_v929 -> P.Just (3, ("lock",from_Lock _v929))) $ descheduleCronJob_args_lock record
  , (\_v929 -> P.Just (4, ("job",from_JobKey _v929))) $ descheduleCronJob_args_job record
  ]
write_DescheduleCronJob_args :: (T.Protocol p, T.Transport t) => p t -> DescheduleCronJob_args -> P.IO ()
write_DescheduleCronJob_args oprot record = T.writeVal oprot $ from_DescheduleCronJob_args record
encode_DescheduleCronJob_args :: (T.Protocol p, T.Transport t) => p t -> DescheduleCronJob_args -> LBS.ByteString
encode_DescheduleCronJob_args oprot record = T.serializeVal oprot $ from_DescheduleCronJob_args record
to_DescheduleCronJob_args :: T.ThriftVal -> DescheduleCronJob_args
to_DescheduleCronJob_args (T.TStruct fields) = DescheduleCronJob_args{
  descheduleCronJob_args_job = P.maybe (descheduleCronJob_args_job default_DescheduleCronJob_args) (\(_,_val931) -> (case _val931 of {T.TStruct _val932 -> (to_JobKey (T.TStruct _val932)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  descheduleCronJob_args_lock = P.maybe (descheduleCronJob_args_lock default_DescheduleCronJob_args) (\(_,_val931) -> (case _val931 of {T.TStruct _val933 -> (to_Lock (T.TStruct _val933)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  descheduleCronJob_args_session = P.maybe (descheduleCronJob_args_session default_DescheduleCronJob_args) (\(_,_val931) -> (case _val931 of {T.TStruct _val934 -> (to_SessionKey (T.TStruct _val934)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_DescheduleCronJob_args _ = P.error "not a struct"
read_DescheduleCronJob_args :: (T.Transport t, T.Protocol p) => p t -> P.IO DescheduleCronJob_args
read_DescheduleCronJob_args iprot = to_DescheduleCronJob_args <$> T.readVal iprot (T.T_STRUCT typemap_DescheduleCronJob_args)
decode_DescheduleCronJob_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DescheduleCronJob_args
decode_DescheduleCronJob_args iprot bs = to_DescheduleCronJob_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DescheduleCronJob_args) bs
typemap_DescheduleCronJob_args :: T.TypeMap
typemap_DescheduleCronJob_args = Map.fromList [(2,("session",(T.T_STRUCT typemap_SessionKey))),(3,("lock",(T.T_STRUCT typemap_Lock))),(4,("job",(T.T_STRUCT typemap_JobKey)))]
default_DescheduleCronJob_args :: DescheduleCronJob_args
default_DescheduleCronJob_args = DescheduleCronJob_args{
  descheduleCronJob_args_session = default_SessionKey,
  descheduleCronJob_args_lock = default_Lock,
  descheduleCronJob_args_job = default_JobKey}
data DescheduleCronJob_result = DescheduleCronJob_result  { descheduleCronJob_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DescheduleCronJob_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` descheduleCronJob_result_success record  
instance QC.Arbitrary DescheduleCronJob_result where 
  arbitrary = M.liftM DescheduleCronJob_result (QC.arbitrary)
  shrink obj | obj == default_DescheduleCronJob_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DescheduleCronJob_result{descheduleCronJob_result_success = descheduleCronJob_result_success obj} then P.Nothing else P.Just $ default_DescheduleCronJob_result{descheduleCronJob_result_success = descheduleCronJob_result_success obj}
    ]
from_DescheduleCronJob_result :: DescheduleCronJob_result -> T.ThriftVal
from_DescheduleCronJob_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v937 -> P.Just (0, ("success",from_Response _v937))) $ descheduleCronJob_result_success record
  ]
write_DescheduleCronJob_result :: (T.Protocol p, T.Transport t) => p t -> DescheduleCronJob_result -> P.IO ()
write_DescheduleCronJob_result oprot record = T.writeVal oprot $ from_DescheduleCronJob_result record
encode_DescheduleCronJob_result :: (T.Protocol p, T.Transport t) => p t -> DescheduleCronJob_result -> LBS.ByteString
encode_DescheduleCronJob_result oprot record = T.serializeVal oprot $ from_DescheduleCronJob_result record
to_DescheduleCronJob_result :: T.ThriftVal -> DescheduleCronJob_result
to_DescheduleCronJob_result (T.TStruct fields) = DescheduleCronJob_result{
  descheduleCronJob_result_success = P.maybe (descheduleCronJob_result_success default_DescheduleCronJob_result) (\(_,_val939) -> (case _val939 of {T.TStruct _val940 -> (to_Response (T.TStruct _val940)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_DescheduleCronJob_result _ = P.error "not a struct"
read_DescheduleCronJob_result :: (T.Transport t, T.Protocol p) => p t -> P.IO DescheduleCronJob_result
read_DescheduleCronJob_result iprot = to_DescheduleCronJob_result <$> T.readVal iprot (T.T_STRUCT typemap_DescheduleCronJob_result)
decode_DescheduleCronJob_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DescheduleCronJob_result
decode_DescheduleCronJob_result iprot bs = to_DescheduleCronJob_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DescheduleCronJob_result) bs
typemap_DescheduleCronJob_result :: T.TypeMap
typemap_DescheduleCronJob_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_DescheduleCronJob_result :: DescheduleCronJob_result
default_DescheduleCronJob_result = DescheduleCronJob_result{
  descheduleCronJob_result_success = default_Response}
data StartCronJob_args = StartCronJob_args  { startCronJob_args_job :: JobKey
  , startCronJob_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartCronJob_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startCronJob_args_job record   `H.hashWithSalt` startCronJob_args_session record  
instance QC.Arbitrary StartCronJob_args where 
  arbitrary = M.liftM StartCronJob_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartCronJob_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartCronJob_args{startCronJob_args_job = startCronJob_args_job obj} then P.Nothing else P.Just $ default_StartCronJob_args{startCronJob_args_job = startCronJob_args_job obj}
    , if obj == default_StartCronJob_args{startCronJob_args_session = startCronJob_args_session obj} then P.Nothing else P.Just $ default_StartCronJob_args{startCronJob_args_session = startCronJob_args_session obj}
    ]
from_StartCronJob_args :: StartCronJob_args -> T.ThriftVal
from_StartCronJob_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v943 -> P.Just (3, ("session",from_SessionKey _v943))) $ startCronJob_args_session record
  , (\_v943 -> P.Just (4, ("job",from_JobKey _v943))) $ startCronJob_args_job record
  ]
write_StartCronJob_args :: (T.Protocol p, T.Transport t) => p t -> StartCronJob_args -> P.IO ()
write_StartCronJob_args oprot record = T.writeVal oprot $ from_StartCronJob_args record
encode_StartCronJob_args :: (T.Protocol p, T.Transport t) => p t -> StartCronJob_args -> LBS.ByteString
encode_StartCronJob_args oprot record = T.serializeVal oprot $ from_StartCronJob_args record
to_StartCronJob_args :: T.ThriftVal -> StartCronJob_args
to_StartCronJob_args (T.TStruct fields) = StartCronJob_args{
  startCronJob_args_job = P.maybe (startCronJob_args_job default_StartCronJob_args) (\(_,_val945) -> (case _val945 of {T.TStruct _val946 -> (to_JobKey (T.TStruct _val946)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  startCronJob_args_session = P.maybe (startCronJob_args_session default_StartCronJob_args) (\(_,_val945) -> (case _val945 of {T.TStruct _val947 -> (to_SessionKey (T.TStruct _val947)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_StartCronJob_args _ = P.error "not a struct"
read_StartCronJob_args :: (T.Transport t, T.Protocol p) => p t -> P.IO StartCronJob_args
read_StartCronJob_args iprot = to_StartCronJob_args <$> T.readVal iprot (T.T_STRUCT typemap_StartCronJob_args)
decode_StartCronJob_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartCronJob_args
decode_StartCronJob_args iprot bs = to_StartCronJob_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartCronJob_args) bs
typemap_StartCronJob_args :: T.TypeMap
typemap_StartCronJob_args = Map.fromList [(3,("session",(T.T_STRUCT typemap_SessionKey))),(4,("job",(T.T_STRUCT typemap_JobKey)))]
default_StartCronJob_args :: StartCronJob_args
default_StartCronJob_args = StartCronJob_args{
  startCronJob_args_session = default_SessionKey,
  startCronJob_args_job = default_JobKey}
data StartCronJob_result = StartCronJob_result  { startCronJob_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartCronJob_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startCronJob_result_success record  
instance QC.Arbitrary StartCronJob_result where 
  arbitrary = M.liftM StartCronJob_result (QC.arbitrary)
  shrink obj | obj == default_StartCronJob_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartCronJob_result{startCronJob_result_success = startCronJob_result_success obj} then P.Nothing else P.Just $ default_StartCronJob_result{startCronJob_result_success = startCronJob_result_success obj}
    ]
from_StartCronJob_result :: StartCronJob_result -> T.ThriftVal
from_StartCronJob_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v950 -> P.Just (0, ("success",from_Response _v950))) $ startCronJob_result_success record
  ]
write_StartCronJob_result :: (T.Protocol p, T.Transport t) => p t -> StartCronJob_result -> P.IO ()
write_StartCronJob_result oprot record = T.writeVal oprot $ from_StartCronJob_result record
encode_StartCronJob_result :: (T.Protocol p, T.Transport t) => p t -> StartCronJob_result -> LBS.ByteString
encode_StartCronJob_result oprot record = T.serializeVal oprot $ from_StartCronJob_result record
to_StartCronJob_result :: T.ThriftVal -> StartCronJob_result
to_StartCronJob_result (T.TStruct fields) = StartCronJob_result{
  startCronJob_result_success = P.maybe (startCronJob_result_success default_StartCronJob_result) (\(_,_val952) -> (case _val952 of {T.TStruct _val953 -> (to_Response (T.TStruct _val953)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_StartCronJob_result _ = P.error "not a struct"
read_StartCronJob_result :: (T.Transport t, T.Protocol p) => p t -> P.IO StartCronJob_result
read_StartCronJob_result iprot = to_StartCronJob_result <$> T.readVal iprot (T.T_STRUCT typemap_StartCronJob_result)
decode_StartCronJob_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartCronJob_result
decode_StartCronJob_result iprot bs = to_StartCronJob_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartCronJob_result) bs
typemap_StartCronJob_result :: T.TypeMap
typemap_StartCronJob_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_StartCronJob_result :: StartCronJob_result
default_StartCronJob_result = StartCronJob_result{
  startCronJob_result_success = default_Response}
data RestartShards_args = RestartShards_args  { restartShards_args_job :: JobKey
  , restartShards_args_shardIds :: (Set.HashSet I.Int32)
  , restartShards_args_lock :: Lock
  , restartShards_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RestartShards_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` restartShards_args_job record   `H.hashWithSalt` restartShards_args_shardIds record   `H.hashWithSalt` restartShards_args_lock record   `H.hashWithSalt` restartShards_args_session record  
instance QC.Arbitrary RestartShards_args where 
  arbitrary = M.liftM RestartShards_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RestartShards_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RestartShards_args{restartShards_args_job = restartShards_args_job obj} then P.Nothing else P.Just $ default_RestartShards_args{restartShards_args_job = restartShards_args_job obj}
    , if obj == default_RestartShards_args{restartShards_args_shardIds = restartShards_args_shardIds obj} then P.Nothing else P.Just $ default_RestartShards_args{restartShards_args_shardIds = restartShards_args_shardIds obj}
    , if obj == default_RestartShards_args{restartShards_args_lock = restartShards_args_lock obj} then P.Nothing else P.Just $ default_RestartShards_args{restartShards_args_lock = restartShards_args_lock obj}
    , if obj == default_RestartShards_args{restartShards_args_session = restartShards_args_session obj} then P.Nothing else P.Just $ default_RestartShards_args{restartShards_args_session = restartShards_args_session obj}
    ]
from_RestartShards_args :: RestartShards_args -> T.ThriftVal
from_RestartShards_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v956 -> P.Just (3, ("shardIds",T.TSet T.T_I32 $ P.map (\_v958 -> T.TI32 _v958) $ Set.toList _v956))) $ restartShards_args_shardIds record
  , (\_v956 -> P.Just (4, ("session",from_SessionKey _v956))) $ restartShards_args_session record
  , (\_v956 -> P.Just (5, ("job",from_JobKey _v956))) $ restartShards_args_job record
  , (\_v956 -> P.Just (6, ("lock",from_Lock _v956))) $ restartShards_args_lock record
  ]
write_RestartShards_args :: (T.Protocol p, T.Transport t) => p t -> RestartShards_args -> P.IO ()
write_RestartShards_args oprot record = T.writeVal oprot $ from_RestartShards_args record
encode_RestartShards_args :: (T.Protocol p, T.Transport t) => p t -> RestartShards_args -> LBS.ByteString
encode_RestartShards_args oprot record = T.serializeVal oprot $ from_RestartShards_args record
to_RestartShards_args :: T.ThriftVal -> RestartShards_args
to_RestartShards_args (T.TStruct fields) = RestartShards_args{
  restartShards_args_job = P.maybe (restartShards_args_job default_RestartShards_args) (\(_,_val960) -> (case _val960 of {T.TStruct _val961 -> (to_JobKey (T.TStruct _val961)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  restartShards_args_shardIds = P.maybe (restartShards_args_shardIds default_RestartShards_args) (\(_,_val960) -> (case _val960 of {T.TSet _ _val962 -> (Set.fromList $ P.map (\_v963 -> (case _v963 of {T.TI32 _val964 -> _val964; _ -> P.error "wrong type"})) _val962); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  restartShards_args_lock = P.maybe (restartShards_args_lock default_RestartShards_args) (\(_,_val960) -> (case _val960 of {T.TStruct _val965 -> (to_Lock (T.TStruct _val965)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  restartShards_args_session = P.maybe (restartShards_args_session default_RestartShards_args) (\(_,_val960) -> (case _val960 of {T.TStruct _val966 -> (to_SessionKey (T.TStruct _val966)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RestartShards_args _ = P.error "not a struct"
read_RestartShards_args :: (T.Transport t, T.Protocol p) => p t -> P.IO RestartShards_args
read_RestartShards_args iprot = to_RestartShards_args <$> T.readVal iprot (T.T_STRUCT typemap_RestartShards_args)
decode_RestartShards_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RestartShards_args
decode_RestartShards_args iprot bs = to_RestartShards_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RestartShards_args) bs
typemap_RestartShards_args :: T.TypeMap
typemap_RestartShards_args = Map.fromList [(3,("shardIds",(T.T_SET T.T_I32))),(4,("session",(T.T_STRUCT typemap_SessionKey))),(5,("job",(T.T_STRUCT typemap_JobKey))),(6,("lock",(T.T_STRUCT typemap_Lock)))]
default_RestartShards_args :: RestartShards_args
default_RestartShards_args = RestartShards_args{
  restartShards_args_shardIds = Set.empty,
  restartShards_args_session = default_SessionKey,
  restartShards_args_job = default_JobKey,
  restartShards_args_lock = default_Lock}
data RestartShards_result = RestartShards_result  { restartShards_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RestartShards_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` restartShards_result_success record  
instance QC.Arbitrary RestartShards_result where 
  arbitrary = M.liftM RestartShards_result (QC.arbitrary)
  shrink obj | obj == default_RestartShards_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RestartShards_result{restartShards_result_success = restartShards_result_success obj} then P.Nothing else P.Just $ default_RestartShards_result{restartShards_result_success = restartShards_result_success obj}
    ]
from_RestartShards_result :: RestartShards_result -> T.ThriftVal
from_RestartShards_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v969 -> P.Just (0, ("success",from_Response _v969))) $ restartShards_result_success record
  ]
write_RestartShards_result :: (T.Protocol p, T.Transport t) => p t -> RestartShards_result -> P.IO ()
write_RestartShards_result oprot record = T.writeVal oprot $ from_RestartShards_result record
encode_RestartShards_result :: (T.Protocol p, T.Transport t) => p t -> RestartShards_result -> LBS.ByteString
encode_RestartShards_result oprot record = T.serializeVal oprot $ from_RestartShards_result record
to_RestartShards_result :: T.ThriftVal -> RestartShards_result
to_RestartShards_result (T.TStruct fields) = RestartShards_result{
  restartShards_result_success = P.maybe (restartShards_result_success default_RestartShards_result) (\(_,_val971) -> (case _val971 of {T.TStruct _val972 -> (to_Response (T.TStruct _val972)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_RestartShards_result _ = P.error "not a struct"
read_RestartShards_result :: (T.Transport t, T.Protocol p) => p t -> P.IO RestartShards_result
read_RestartShards_result iprot = to_RestartShards_result <$> T.readVal iprot (T.T_STRUCT typemap_RestartShards_result)
decode_RestartShards_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RestartShards_result
decode_RestartShards_result iprot bs = to_RestartShards_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RestartShards_result) bs
typemap_RestartShards_result :: T.TypeMap
typemap_RestartShards_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_RestartShards_result :: RestartShards_result
default_RestartShards_result = RestartShards_result{
  restartShards_result_success = default_Response}
data KillTasks_args = KillTasks_args  { killTasks_args_query :: TaskQuery
  , killTasks_args_lock :: P.Maybe Lock
  , killTasks_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable KillTasks_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` killTasks_args_query record   `H.hashWithSalt` killTasks_args_lock record   `H.hashWithSalt` killTasks_args_session record  
instance QC.Arbitrary KillTasks_args where 
  arbitrary = M.liftM KillTasks_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_KillTasks_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KillTasks_args{killTasks_args_query = killTasks_args_query obj} then P.Nothing else P.Just $ default_KillTasks_args{killTasks_args_query = killTasks_args_query obj}
    , if obj == default_KillTasks_args{killTasks_args_lock = killTasks_args_lock obj} then P.Nothing else P.Just $ default_KillTasks_args{killTasks_args_lock = killTasks_args_lock obj}
    , if obj == default_KillTasks_args{killTasks_args_session = killTasks_args_session obj} then P.Nothing else P.Just $ default_KillTasks_args{killTasks_args_session = killTasks_args_session obj}
    ]
from_KillTasks_args :: KillTasks_args -> T.ThriftVal
from_KillTasks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v975 -> P.Just (1, ("query",from_TaskQuery _v975))) $ killTasks_args_query record
  , (\_v975 -> P.Just (2, ("session",from_SessionKey _v975))) $ killTasks_args_session record
  , (\_v975 -> (3, ("lock",from_Lock _v975))) <$> killTasks_args_lock record
  ]
write_KillTasks_args :: (T.Protocol p, T.Transport t) => p t -> KillTasks_args -> P.IO ()
write_KillTasks_args oprot record = T.writeVal oprot $ from_KillTasks_args record
encode_KillTasks_args :: (T.Protocol p, T.Transport t) => p t -> KillTasks_args -> LBS.ByteString
encode_KillTasks_args oprot record = T.serializeVal oprot $ from_KillTasks_args record
to_KillTasks_args :: T.ThriftVal -> KillTasks_args
to_KillTasks_args (T.TStruct fields) = KillTasks_args{
  killTasks_args_query = P.maybe (killTasks_args_query default_KillTasks_args) (\(_,_val977) -> (case _val977 of {T.TStruct _val978 -> (to_TaskQuery (T.TStruct _val978)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  killTasks_args_lock = P.maybe (killTasks_args_lock default_KillTasks_args) (\(_,_val977) -> (case _val977 of {T.TStruct _val979 -> P.Just (to_Lock (T.TStruct _val979)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  killTasks_args_session = P.maybe (killTasks_args_session default_KillTasks_args) (\(_,_val977) -> (case _val977 of {T.TStruct _val980 -> (to_SessionKey (T.TStruct _val980)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_KillTasks_args _ = P.error "not a struct"
read_KillTasks_args :: (T.Transport t, T.Protocol p) => p t -> P.IO KillTasks_args
read_KillTasks_args iprot = to_KillTasks_args <$> T.readVal iprot (T.T_STRUCT typemap_KillTasks_args)
decode_KillTasks_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> KillTasks_args
decode_KillTasks_args iprot bs = to_KillTasks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_KillTasks_args) bs
typemap_KillTasks_args :: T.TypeMap
typemap_KillTasks_args = Map.fromList [(1,("query",(T.T_STRUCT typemap_TaskQuery))),(2,("session",(T.T_STRUCT typemap_SessionKey))),(3,("lock",(T.T_STRUCT typemap_Lock)))]
default_KillTasks_args :: KillTasks_args
default_KillTasks_args = KillTasks_args{
  killTasks_args_query = default_TaskQuery,
  killTasks_args_session = default_SessionKey,
  killTasks_args_lock = P.Nothing}
data KillTasks_result = KillTasks_result  { killTasks_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable KillTasks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` killTasks_result_success record  
instance QC.Arbitrary KillTasks_result where 
  arbitrary = M.liftM KillTasks_result (QC.arbitrary)
  shrink obj | obj == default_KillTasks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KillTasks_result{killTasks_result_success = killTasks_result_success obj} then P.Nothing else P.Just $ default_KillTasks_result{killTasks_result_success = killTasks_result_success obj}
    ]
from_KillTasks_result :: KillTasks_result -> T.ThriftVal
from_KillTasks_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v983 -> P.Just (0, ("success",from_Response _v983))) $ killTasks_result_success record
  ]
write_KillTasks_result :: (T.Protocol p, T.Transport t) => p t -> KillTasks_result -> P.IO ()
write_KillTasks_result oprot record = T.writeVal oprot $ from_KillTasks_result record
encode_KillTasks_result :: (T.Protocol p, T.Transport t) => p t -> KillTasks_result -> LBS.ByteString
encode_KillTasks_result oprot record = T.serializeVal oprot $ from_KillTasks_result record
to_KillTasks_result :: T.ThriftVal -> KillTasks_result
to_KillTasks_result (T.TStruct fields) = KillTasks_result{
  killTasks_result_success = P.maybe (killTasks_result_success default_KillTasks_result) (\(_,_val985) -> (case _val985 of {T.TStruct _val986 -> (to_Response (T.TStruct _val986)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_KillTasks_result _ = P.error "not a struct"
read_KillTasks_result :: (T.Transport t, T.Protocol p) => p t -> P.IO KillTasks_result
read_KillTasks_result iprot = to_KillTasks_result <$> T.readVal iprot (T.T_STRUCT typemap_KillTasks_result)
decode_KillTasks_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> KillTasks_result
decode_KillTasks_result iprot bs = to_KillTasks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_KillTasks_result) bs
typemap_KillTasks_result :: T.TypeMap
typemap_KillTasks_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_KillTasks_result :: KillTasks_result
default_KillTasks_result = KillTasks_result{
  killTasks_result_success = default_Response}
data AddInstances_args = AddInstances_args  { addInstances_args_config :: AddInstancesConfig
  , addInstances_args_lock :: Lock
  , addInstances_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AddInstances_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addInstances_args_config record   `H.hashWithSalt` addInstances_args_lock record   `H.hashWithSalt` addInstances_args_session record  
instance QC.Arbitrary AddInstances_args where 
  arbitrary = M.liftM AddInstances_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddInstances_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddInstances_args{addInstances_args_config = addInstances_args_config obj} then P.Nothing else P.Just $ default_AddInstances_args{addInstances_args_config = addInstances_args_config obj}
    , if obj == default_AddInstances_args{addInstances_args_lock = addInstances_args_lock obj} then P.Nothing else P.Just $ default_AddInstances_args{addInstances_args_lock = addInstances_args_lock obj}
    , if obj == default_AddInstances_args{addInstances_args_session = addInstances_args_session obj} then P.Nothing else P.Just $ default_AddInstances_args{addInstances_args_session = addInstances_args_session obj}
    ]
from_AddInstances_args :: AddInstances_args -> T.ThriftVal
from_AddInstances_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v989 -> P.Just (1, ("config",from_AddInstancesConfig _v989))) $ addInstances_args_config record
  , (\_v989 -> P.Just (2, ("lock",from_Lock _v989))) $ addInstances_args_lock record
  , (\_v989 -> P.Just (3, ("session",from_SessionKey _v989))) $ addInstances_args_session record
  ]
write_AddInstances_args :: (T.Protocol p, T.Transport t) => p t -> AddInstances_args -> P.IO ()
write_AddInstances_args oprot record = T.writeVal oprot $ from_AddInstances_args record
encode_AddInstances_args :: (T.Protocol p, T.Transport t) => p t -> AddInstances_args -> LBS.ByteString
encode_AddInstances_args oprot record = T.serializeVal oprot $ from_AddInstances_args record
to_AddInstances_args :: T.ThriftVal -> AddInstances_args
to_AddInstances_args (T.TStruct fields) = AddInstances_args{
  addInstances_args_config = P.maybe (addInstances_args_config default_AddInstances_args) (\(_,_val991) -> (case _val991 of {T.TStruct _val992 -> (to_AddInstancesConfig (T.TStruct _val992)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  addInstances_args_lock = P.maybe (addInstances_args_lock default_AddInstances_args) (\(_,_val991) -> (case _val991 of {T.TStruct _val993 -> (to_Lock (T.TStruct _val993)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addInstances_args_session = P.maybe (addInstances_args_session default_AddInstances_args) (\(_,_val991) -> (case _val991 of {T.TStruct _val994 -> (to_SessionKey (T.TStruct _val994)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AddInstances_args _ = P.error "not a struct"
read_AddInstances_args :: (T.Transport t, T.Protocol p) => p t -> P.IO AddInstances_args
read_AddInstances_args iprot = to_AddInstances_args <$> T.readVal iprot (T.T_STRUCT typemap_AddInstances_args)
decode_AddInstances_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AddInstances_args
decode_AddInstances_args iprot bs = to_AddInstances_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddInstances_args) bs
typemap_AddInstances_args :: T.TypeMap
typemap_AddInstances_args = Map.fromList [(1,("config",(T.T_STRUCT typemap_AddInstancesConfig))),(2,("lock",(T.T_STRUCT typemap_Lock))),(3,("session",(T.T_STRUCT typemap_SessionKey)))]
default_AddInstances_args :: AddInstances_args
default_AddInstances_args = AddInstances_args{
  addInstances_args_config = default_AddInstancesConfig,
  addInstances_args_lock = default_Lock,
  addInstances_args_session = default_SessionKey}
data AddInstances_result = AddInstances_result  { addInstances_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AddInstances_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addInstances_result_success record  
instance QC.Arbitrary AddInstances_result where 
  arbitrary = M.liftM AddInstances_result (QC.arbitrary)
  shrink obj | obj == default_AddInstances_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddInstances_result{addInstances_result_success = addInstances_result_success obj} then P.Nothing else P.Just $ default_AddInstances_result{addInstances_result_success = addInstances_result_success obj}
    ]
from_AddInstances_result :: AddInstances_result -> T.ThriftVal
from_AddInstances_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v997 -> P.Just (0, ("success",from_Response _v997))) $ addInstances_result_success record
  ]
write_AddInstances_result :: (T.Protocol p, T.Transport t) => p t -> AddInstances_result -> P.IO ()
write_AddInstances_result oprot record = T.writeVal oprot $ from_AddInstances_result record
encode_AddInstances_result :: (T.Protocol p, T.Transport t) => p t -> AddInstances_result -> LBS.ByteString
encode_AddInstances_result oprot record = T.serializeVal oprot $ from_AddInstances_result record
to_AddInstances_result :: T.ThriftVal -> AddInstances_result
to_AddInstances_result (T.TStruct fields) = AddInstances_result{
  addInstances_result_success = P.maybe (addInstances_result_success default_AddInstances_result) (\(_,_val999) -> (case _val999 of {T.TStruct _val1000 -> (to_Response (T.TStruct _val1000)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_AddInstances_result _ = P.error "not a struct"
read_AddInstances_result :: (T.Transport t, T.Protocol p) => p t -> P.IO AddInstances_result
read_AddInstances_result iprot = to_AddInstances_result <$> T.readVal iprot (T.T_STRUCT typemap_AddInstances_result)
decode_AddInstances_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AddInstances_result
decode_AddInstances_result iprot bs = to_AddInstances_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddInstances_result) bs
typemap_AddInstances_result :: T.TypeMap
typemap_AddInstances_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_AddInstances_result :: AddInstances_result
default_AddInstances_result = AddInstances_result{
  addInstances_result_success = default_Response}
data AcquireLock_args = AcquireLock_args  { acquireLock_args_lockKey :: LockKey
  , acquireLock_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AcquireLock_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireLock_args_lockKey record   `H.hashWithSalt` acquireLock_args_session record  
instance QC.Arbitrary AcquireLock_args where 
  arbitrary = M.liftM AcquireLock_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcquireLock_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireLock_args{acquireLock_args_lockKey = acquireLock_args_lockKey obj} then P.Nothing else P.Just $ default_AcquireLock_args{acquireLock_args_lockKey = acquireLock_args_lockKey obj}
    , if obj == default_AcquireLock_args{acquireLock_args_session = acquireLock_args_session obj} then P.Nothing else P.Just $ default_AcquireLock_args{acquireLock_args_session = acquireLock_args_session obj}
    ]
from_AcquireLock_args :: AcquireLock_args -> T.ThriftVal
from_AcquireLock_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1003 -> P.Just (1, ("lockKey",from_LockKey _v1003))) $ acquireLock_args_lockKey record
  , (\_v1003 -> P.Just (2, ("session",from_SessionKey _v1003))) $ acquireLock_args_session record
  ]
write_AcquireLock_args :: (T.Protocol p, T.Transport t) => p t -> AcquireLock_args -> P.IO ()
write_AcquireLock_args oprot record = T.writeVal oprot $ from_AcquireLock_args record
encode_AcquireLock_args :: (T.Protocol p, T.Transport t) => p t -> AcquireLock_args -> LBS.ByteString
encode_AcquireLock_args oprot record = T.serializeVal oprot $ from_AcquireLock_args record
to_AcquireLock_args :: T.ThriftVal -> AcquireLock_args
to_AcquireLock_args (T.TStruct fields) = AcquireLock_args{
  acquireLock_args_lockKey = P.maybe (acquireLock_args_lockKey default_AcquireLock_args) (\(_,_val1005) -> (case _val1005 of {T.TStruct _val1006 -> (to_LockKey (T.TStruct _val1006)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  acquireLock_args_session = P.maybe (acquireLock_args_session default_AcquireLock_args) (\(_,_val1005) -> (case _val1005 of {T.TStruct _val1007 -> (to_SessionKey (T.TStruct _val1007)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireLock_args _ = P.error "not a struct"
read_AcquireLock_args :: (T.Transport t, T.Protocol p) => p t -> P.IO AcquireLock_args
read_AcquireLock_args iprot = to_AcquireLock_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireLock_args)
decode_AcquireLock_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AcquireLock_args
decode_AcquireLock_args iprot bs = to_AcquireLock_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireLock_args) bs
typemap_AcquireLock_args :: T.TypeMap
typemap_AcquireLock_args = Map.fromList [(1,("lockKey",(T.T_STRUCT typemap_LockKey))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_AcquireLock_args :: AcquireLock_args
default_AcquireLock_args = AcquireLock_args{
  acquireLock_args_lockKey = default_LockKey,
  acquireLock_args_session = default_SessionKey}
data AcquireLock_result = AcquireLock_result  { acquireLock_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AcquireLock_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireLock_result_success record  
instance QC.Arbitrary AcquireLock_result where 
  arbitrary = M.liftM AcquireLock_result (QC.arbitrary)
  shrink obj | obj == default_AcquireLock_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireLock_result{acquireLock_result_success = acquireLock_result_success obj} then P.Nothing else P.Just $ default_AcquireLock_result{acquireLock_result_success = acquireLock_result_success obj}
    ]
from_AcquireLock_result :: AcquireLock_result -> T.ThriftVal
from_AcquireLock_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1010 -> P.Just (0, ("success",from_Response _v1010))) $ acquireLock_result_success record
  ]
write_AcquireLock_result :: (T.Protocol p, T.Transport t) => p t -> AcquireLock_result -> P.IO ()
write_AcquireLock_result oprot record = T.writeVal oprot $ from_AcquireLock_result record
encode_AcquireLock_result :: (T.Protocol p, T.Transport t) => p t -> AcquireLock_result -> LBS.ByteString
encode_AcquireLock_result oprot record = T.serializeVal oprot $ from_AcquireLock_result record
to_AcquireLock_result :: T.ThriftVal -> AcquireLock_result
to_AcquireLock_result (T.TStruct fields) = AcquireLock_result{
  acquireLock_result_success = P.maybe (acquireLock_result_success default_AcquireLock_result) (\(_,_val1012) -> (case _val1012 of {T.TStruct _val1013 -> (to_Response (T.TStruct _val1013)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_AcquireLock_result _ = P.error "not a struct"
read_AcquireLock_result :: (T.Transport t, T.Protocol p) => p t -> P.IO AcquireLock_result
read_AcquireLock_result iprot = to_AcquireLock_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireLock_result)
decode_AcquireLock_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AcquireLock_result
decode_AcquireLock_result iprot bs = to_AcquireLock_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireLock_result) bs
typemap_AcquireLock_result :: T.TypeMap
typemap_AcquireLock_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_AcquireLock_result :: AcquireLock_result
default_AcquireLock_result = AcquireLock_result{
  acquireLock_result_success = default_Response}
data ReleaseLock_args = ReleaseLock_args  { releaseLock_args_lock :: Lock
  , releaseLock_args_validation :: LockValidation
  , releaseLock_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ReleaseLock_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` releaseLock_args_lock record   `H.hashWithSalt` releaseLock_args_validation record   `H.hashWithSalt` releaseLock_args_session record  
instance QC.Arbitrary ReleaseLock_args where 
  arbitrary = M.liftM ReleaseLock_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReleaseLock_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReleaseLock_args{releaseLock_args_lock = releaseLock_args_lock obj} then P.Nothing else P.Just $ default_ReleaseLock_args{releaseLock_args_lock = releaseLock_args_lock obj}
    , if obj == default_ReleaseLock_args{releaseLock_args_validation = releaseLock_args_validation obj} then P.Nothing else P.Just $ default_ReleaseLock_args{releaseLock_args_validation = releaseLock_args_validation obj}
    , if obj == default_ReleaseLock_args{releaseLock_args_session = releaseLock_args_session obj} then P.Nothing else P.Just $ default_ReleaseLock_args{releaseLock_args_session = releaseLock_args_session obj}
    ]
from_ReleaseLock_args :: ReleaseLock_args -> T.ThriftVal
from_ReleaseLock_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1016 -> P.Just (1, ("lock",from_Lock _v1016))) $ releaseLock_args_lock record
  , (\_v1016 -> P.Just (2, ("validation",T.TI32 $ P.fromIntegral $ P.fromEnum _v1016))) $ releaseLock_args_validation record
  , (\_v1016 -> P.Just (3, ("session",from_SessionKey _v1016))) $ releaseLock_args_session record
  ]
write_ReleaseLock_args :: (T.Protocol p, T.Transport t) => p t -> ReleaseLock_args -> P.IO ()
write_ReleaseLock_args oprot record = T.writeVal oprot $ from_ReleaseLock_args record
encode_ReleaseLock_args :: (T.Protocol p, T.Transport t) => p t -> ReleaseLock_args -> LBS.ByteString
encode_ReleaseLock_args oprot record = T.serializeVal oprot $ from_ReleaseLock_args record
to_ReleaseLock_args :: T.ThriftVal -> ReleaseLock_args
to_ReleaseLock_args (T.TStruct fields) = ReleaseLock_args{
  releaseLock_args_lock = P.maybe (releaseLock_args_lock default_ReleaseLock_args) (\(_,_val1018) -> (case _val1018 of {T.TStruct _val1019 -> (to_Lock (T.TStruct _val1019)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  releaseLock_args_validation = P.maybe (releaseLock_args_validation default_ReleaseLock_args) (\(_,_val1018) -> (case _val1018 of {T.TI32 _val1020 -> P.toEnum $ P.fromIntegral _val1020; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  releaseLock_args_session = P.maybe (releaseLock_args_session default_ReleaseLock_args) (\(_,_val1018) -> (case _val1018 of {T.TStruct _val1021 -> (to_SessionKey (T.TStruct _val1021)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReleaseLock_args _ = P.error "not a struct"
read_ReleaseLock_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ReleaseLock_args
read_ReleaseLock_args iprot = to_ReleaseLock_args <$> T.readVal iprot (T.T_STRUCT typemap_ReleaseLock_args)
decode_ReleaseLock_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ReleaseLock_args
decode_ReleaseLock_args iprot bs = to_ReleaseLock_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReleaseLock_args) bs
typemap_ReleaseLock_args :: T.TypeMap
typemap_ReleaseLock_args = Map.fromList [(1,("lock",(T.T_STRUCT typemap_Lock))),(2,("validation",T.T_I32)),(3,("session",(T.T_STRUCT typemap_SessionKey)))]
default_ReleaseLock_args :: ReleaseLock_args
default_ReleaseLock_args = ReleaseLock_args{
  releaseLock_args_lock = default_Lock,
  releaseLock_args_validation = (P.toEnum 0),
  releaseLock_args_session = default_SessionKey}
data ReleaseLock_result = ReleaseLock_result  { releaseLock_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ReleaseLock_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` releaseLock_result_success record  
instance QC.Arbitrary ReleaseLock_result where 
  arbitrary = M.liftM ReleaseLock_result (QC.arbitrary)
  shrink obj | obj == default_ReleaseLock_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReleaseLock_result{releaseLock_result_success = releaseLock_result_success obj} then P.Nothing else P.Just $ default_ReleaseLock_result{releaseLock_result_success = releaseLock_result_success obj}
    ]
from_ReleaseLock_result :: ReleaseLock_result -> T.ThriftVal
from_ReleaseLock_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1024 -> P.Just (0, ("success",from_Response _v1024))) $ releaseLock_result_success record
  ]
write_ReleaseLock_result :: (T.Protocol p, T.Transport t) => p t -> ReleaseLock_result -> P.IO ()
write_ReleaseLock_result oprot record = T.writeVal oprot $ from_ReleaseLock_result record
encode_ReleaseLock_result :: (T.Protocol p, T.Transport t) => p t -> ReleaseLock_result -> LBS.ByteString
encode_ReleaseLock_result oprot record = T.serializeVal oprot $ from_ReleaseLock_result record
to_ReleaseLock_result :: T.ThriftVal -> ReleaseLock_result
to_ReleaseLock_result (T.TStruct fields) = ReleaseLock_result{
  releaseLock_result_success = P.maybe (releaseLock_result_success default_ReleaseLock_result) (\(_,_val1026) -> (case _val1026 of {T.TStruct _val1027 -> (to_Response (T.TStruct _val1027)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_ReleaseLock_result _ = P.error "not a struct"
read_ReleaseLock_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ReleaseLock_result
read_ReleaseLock_result iprot = to_ReleaseLock_result <$> T.readVal iprot (T.T_STRUCT typemap_ReleaseLock_result)
decode_ReleaseLock_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ReleaseLock_result
decode_ReleaseLock_result iprot bs = to_ReleaseLock_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReleaseLock_result) bs
typemap_ReleaseLock_result :: T.TypeMap
typemap_ReleaseLock_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_ReleaseLock_result :: ReleaseLock_result
default_ReleaseLock_result = ReleaseLock_result{
  releaseLock_result_success = default_Response}
data ReplaceCronTemplate_args = ReplaceCronTemplate_args  { replaceCronTemplate_args_config :: JobConfiguration
  , replaceCronTemplate_args_lock :: Lock
  , replaceCronTemplate_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ReplaceCronTemplate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` replaceCronTemplate_args_config record   `H.hashWithSalt` replaceCronTemplate_args_lock record   `H.hashWithSalt` replaceCronTemplate_args_session record  
instance QC.Arbitrary ReplaceCronTemplate_args where 
  arbitrary = M.liftM ReplaceCronTemplate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReplaceCronTemplate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReplaceCronTemplate_args{replaceCronTemplate_args_config = replaceCronTemplate_args_config obj} then P.Nothing else P.Just $ default_ReplaceCronTemplate_args{replaceCronTemplate_args_config = replaceCronTemplate_args_config obj}
    , if obj == default_ReplaceCronTemplate_args{replaceCronTemplate_args_lock = replaceCronTemplate_args_lock obj} then P.Nothing else P.Just $ default_ReplaceCronTemplate_args{replaceCronTemplate_args_lock = replaceCronTemplate_args_lock obj}
    , if obj == default_ReplaceCronTemplate_args{replaceCronTemplate_args_session = replaceCronTemplate_args_session obj} then P.Nothing else P.Just $ default_ReplaceCronTemplate_args{replaceCronTemplate_args_session = replaceCronTemplate_args_session obj}
    ]
from_ReplaceCronTemplate_args :: ReplaceCronTemplate_args -> T.ThriftVal
from_ReplaceCronTemplate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1030 -> P.Just (1, ("config",from_JobConfiguration _v1030))) $ replaceCronTemplate_args_config record
  , (\_v1030 -> P.Just (2, ("lock",from_Lock _v1030))) $ replaceCronTemplate_args_lock record
  , (\_v1030 -> P.Just (3, ("session",from_SessionKey _v1030))) $ replaceCronTemplate_args_session record
  ]
write_ReplaceCronTemplate_args :: (T.Protocol p, T.Transport t) => p t -> ReplaceCronTemplate_args -> P.IO ()
write_ReplaceCronTemplate_args oprot record = T.writeVal oprot $ from_ReplaceCronTemplate_args record
encode_ReplaceCronTemplate_args :: (T.Protocol p, T.Transport t) => p t -> ReplaceCronTemplate_args -> LBS.ByteString
encode_ReplaceCronTemplate_args oprot record = T.serializeVal oprot $ from_ReplaceCronTemplate_args record
to_ReplaceCronTemplate_args :: T.ThriftVal -> ReplaceCronTemplate_args
to_ReplaceCronTemplate_args (T.TStruct fields) = ReplaceCronTemplate_args{
  replaceCronTemplate_args_config = P.maybe (replaceCronTemplate_args_config default_ReplaceCronTemplate_args) (\(_,_val1032) -> (case _val1032 of {T.TStruct _val1033 -> (to_JobConfiguration (T.TStruct _val1033)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  replaceCronTemplate_args_lock = P.maybe (replaceCronTemplate_args_lock default_ReplaceCronTemplate_args) (\(_,_val1032) -> (case _val1032 of {T.TStruct _val1034 -> (to_Lock (T.TStruct _val1034)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  replaceCronTemplate_args_session = P.maybe (replaceCronTemplate_args_session default_ReplaceCronTemplate_args) (\(_,_val1032) -> (case _val1032 of {T.TStruct _val1035 -> (to_SessionKey (T.TStruct _val1035)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReplaceCronTemplate_args _ = P.error "not a struct"
read_ReplaceCronTemplate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ReplaceCronTemplate_args
read_ReplaceCronTemplate_args iprot = to_ReplaceCronTemplate_args <$> T.readVal iprot (T.T_STRUCT typemap_ReplaceCronTemplate_args)
decode_ReplaceCronTemplate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ReplaceCronTemplate_args
decode_ReplaceCronTemplate_args iprot bs = to_ReplaceCronTemplate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReplaceCronTemplate_args) bs
typemap_ReplaceCronTemplate_args :: T.TypeMap
typemap_ReplaceCronTemplate_args = Map.fromList [(1,("config",(T.T_STRUCT typemap_JobConfiguration))),(2,("lock",(T.T_STRUCT typemap_Lock))),(3,("session",(T.T_STRUCT typemap_SessionKey)))]
default_ReplaceCronTemplate_args :: ReplaceCronTemplate_args
default_ReplaceCronTemplate_args = ReplaceCronTemplate_args{
  replaceCronTemplate_args_config = default_JobConfiguration,
  replaceCronTemplate_args_lock = default_Lock,
  replaceCronTemplate_args_session = default_SessionKey}
data ReplaceCronTemplate_result = ReplaceCronTemplate_result  { replaceCronTemplate_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ReplaceCronTemplate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` replaceCronTemplate_result_success record  
instance QC.Arbitrary ReplaceCronTemplate_result where 
  arbitrary = M.liftM ReplaceCronTemplate_result (QC.arbitrary)
  shrink obj | obj == default_ReplaceCronTemplate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReplaceCronTemplate_result{replaceCronTemplate_result_success = replaceCronTemplate_result_success obj} then P.Nothing else P.Just $ default_ReplaceCronTemplate_result{replaceCronTemplate_result_success = replaceCronTemplate_result_success obj}
    ]
from_ReplaceCronTemplate_result :: ReplaceCronTemplate_result -> T.ThriftVal
from_ReplaceCronTemplate_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1038 -> P.Just (0, ("success",from_Response _v1038))) $ replaceCronTemplate_result_success record
  ]
write_ReplaceCronTemplate_result :: (T.Protocol p, T.Transport t) => p t -> ReplaceCronTemplate_result -> P.IO ()
write_ReplaceCronTemplate_result oprot record = T.writeVal oprot $ from_ReplaceCronTemplate_result record
encode_ReplaceCronTemplate_result :: (T.Protocol p, T.Transport t) => p t -> ReplaceCronTemplate_result -> LBS.ByteString
encode_ReplaceCronTemplate_result oprot record = T.serializeVal oprot $ from_ReplaceCronTemplate_result record
to_ReplaceCronTemplate_result :: T.ThriftVal -> ReplaceCronTemplate_result
to_ReplaceCronTemplate_result (T.TStruct fields) = ReplaceCronTemplate_result{
  replaceCronTemplate_result_success = P.maybe (replaceCronTemplate_result_success default_ReplaceCronTemplate_result) (\(_,_val1040) -> (case _val1040 of {T.TStruct _val1041 -> (to_Response (T.TStruct _val1041)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_ReplaceCronTemplate_result _ = P.error "not a struct"
read_ReplaceCronTemplate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ReplaceCronTemplate_result
read_ReplaceCronTemplate_result iprot = to_ReplaceCronTemplate_result <$> T.readVal iprot (T.T_STRUCT typemap_ReplaceCronTemplate_result)
decode_ReplaceCronTemplate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ReplaceCronTemplate_result
decode_ReplaceCronTemplate_result iprot bs = to_ReplaceCronTemplate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReplaceCronTemplate_result) bs
typemap_ReplaceCronTemplate_result :: T.TypeMap
typemap_ReplaceCronTemplate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_ReplaceCronTemplate_result :: ReplaceCronTemplate_result
default_ReplaceCronTemplate_result = ReplaceCronTemplate_result{
  replaceCronTemplate_result_success = default_Response}
data StartJobUpdate_args = StartJobUpdate_args  { startJobUpdate_args_request :: JobUpdateRequest
  , startJobUpdate_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartJobUpdate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startJobUpdate_args_request record   `H.hashWithSalt` startJobUpdate_args_session record  
instance QC.Arbitrary StartJobUpdate_args where 
  arbitrary = M.liftM StartJobUpdate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartJobUpdate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartJobUpdate_args{startJobUpdate_args_request = startJobUpdate_args_request obj} then P.Nothing else P.Just $ default_StartJobUpdate_args{startJobUpdate_args_request = startJobUpdate_args_request obj}
    , if obj == default_StartJobUpdate_args{startJobUpdate_args_session = startJobUpdate_args_session obj} then P.Nothing else P.Just $ default_StartJobUpdate_args{startJobUpdate_args_session = startJobUpdate_args_session obj}
    ]
from_StartJobUpdate_args :: StartJobUpdate_args -> T.ThriftVal
from_StartJobUpdate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1044 -> P.Just (1, ("request",from_JobUpdateRequest _v1044))) $ startJobUpdate_args_request record
  , (\_v1044 -> P.Just (2, ("session",from_SessionKey _v1044))) $ startJobUpdate_args_session record
  ]
write_StartJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> StartJobUpdate_args -> P.IO ()
write_StartJobUpdate_args oprot record = T.writeVal oprot $ from_StartJobUpdate_args record
encode_StartJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> StartJobUpdate_args -> LBS.ByteString
encode_StartJobUpdate_args oprot record = T.serializeVal oprot $ from_StartJobUpdate_args record
to_StartJobUpdate_args :: T.ThriftVal -> StartJobUpdate_args
to_StartJobUpdate_args (T.TStruct fields) = StartJobUpdate_args{
  startJobUpdate_args_request = P.maybe (startJobUpdate_args_request default_StartJobUpdate_args) (\(_,_val1046) -> (case _val1046 of {T.TStruct _val1047 -> (to_JobUpdateRequest (T.TStruct _val1047)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  startJobUpdate_args_session = P.maybe (startJobUpdate_args_session default_StartJobUpdate_args) (\(_,_val1046) -> (case _val1046 of {T.TStruct _val1048 -> (to_SessionKey (T.TStruct _val1048)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StartJobUpdate_args _ = P.error "not a struct"
read_StartJobUpdate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO StartJobUpdate_args
read_StartJobUpdate_args iprot = to_StartJobUpdate_args <$> T.readVal iprot (T.T_STRUCT typemap_StartJobUpdate_args)
decode_StartJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartJobUpdate_args
decode_StartJobUpdate_args iprot bs = to_StartJobUpdate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartJobUpdate_args) bs
typemap_StartJobUpdate_args :: T.TypeMap
typemap_StartJobUpdate_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_JobUpdateRequest))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_StartJobUpdate_args :: StartJobUpdate_args
default_StartJobUpdate_args = StartJobUpdate_args{
  startJobUpdate_args_request = default_JobUpdateRequest,
  startJobUpdate_args_session = default_SessionKey}
data StartJobUpdate_result = StartJobUpdate_result  { startJobUpdate_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartJobUpdate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startJobUpdate_result_success record  
instance QC.Arbitrary StartJobUpdate_result where 
  arbitrary = M.liftM StartJobUpdate_result (QC.arbitrary)
  shrink obj | obj == default_StartJobUpdate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartJobUpdate_result{startJobUpdate_result_success = startJobUpdate_result_success obj} then P.Nothing else P.Just $ default_StartJobUpdate_result{startJobUpdate_result_success = startJobUpdate_result_success obj}
    ]
from_StartJobUpdate_result :: StartJobUpdate_result -> T.ThriftVal
from_StartJobUpdate_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1051 -> P.Just (0, ("success",from_Response _v1051))) $ startJobUpdate_result_success record
  ]
write_StartJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> StartJobUpdate_result -> P.IO ()
write_StartJobUpdate_result oprot record = T.writeVal oprot $ from_StartJobUpdate_result record
encode_StartJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> StartJobUpdate_result -> LBS.ByteString
encode_StartJobUpdate_result oprot record = T.serializeVal oprot $ from_StartJobUpdate_result record
to_StartJobUpdate_result :: T.ThriftVal -> StartJobUpdate_result
to_StartJobUpdate_result (T.TStruct fields) = StartJobUpdate_result{
  startJobUpdate_result_success = P.maybe (startJobUpdate_result_success default_StartJobUpdate_result) (\(_,_val1053) -> (case _val1053 of {T.TStruct _val1054 -> (to_Response (T.TStruct _val1054)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_StartJobUpdate_result _ = P.error "not a struct"
read_StartJobUpdate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO StartJobUpdate_result
read_StartJobUpdate_result iprot = to_StartJobUpdate_result <$> T.readVal iprot (T.T_STRUCT typemap_StartJobUpdate_result)
decode_StartJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartJobUpdate_result
decode_StartJobUpdate_result iprot bs = to_StartJobUpdate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartJobUpdate_result) bs
typemap_StartJobUpdate_result :: T.TypeMap
typemap_StartJobUpdate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_StartJobUpdate_result :: StartJobUpdate_result
default_StartJobUpdate_result = StartJobUpdate_result{
  startJobUpdate_result_success = default_Response}
data PauseJobUpdate_args = PauseJobUpdate_args  { pauseJobUpdate_args_jobKey :: JobKey
  , pauseJobUpdate_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PauseJobUpdate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` pauseJobUpdate_args_jobKey record   `H.hashWithSalt` pauseJobUpdate_args_session record  
instance QC.Arbitrary PauseJobUpdate_args where 
  arbitrary = M.liftM PauseJobUpdate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PauseJobUpdate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PauseJobUpdate_args{pauseJobUpdate_args_jobKey = pauseJobUpdate_args_jobKey obj} then P.Nothing else P.Just $ default_PauseJobUpdate_args{pauseJobUpdate_args_jobKey = pauseJobUpdate_args_jobKey obj}
    , if obj == default_PauseJobUpdate_args{pauseJobUpdate_args_session = pauseJobUpdate_args_session obj} then P.Nothing else P.Just $ default_PauseJobUpdate_args{pauseJobUpdate_args_session = pauseJobUpdate_args_session obj}
    ]
from_PauseJobUpdate_args :: PauseJobUpdate_args -> T.ThriftVal
from_PauseJobUpdate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1057 -> P.Just (1, ("jobKey",from_JobKey _v1057))) $ pauseJobUpdate_args_jobKey record
  , (\_v1057 -> P.Just (2, ("session",from_SessionKey _v1057))) $ pauseJobUpdate_args_session record
  ]
write_PauseJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> PauseJobUpdate_args -> P.IO ()
write_PauseJobUpdate_args oprot record = T.writeVal oprot $ from_PauseJobUpdate_args record
encode_PauseJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> PauseJobUpdate_args -> LBS.ByteString
encode_PauseJobUpdate_args oprot record = T.serializeVal oprot $ from_PauseJobUpdate_args record
to_PauseJobUpdate_args :: T.ThriftVal -> PauseJobUpdate_args
to_PauseJobUpdate_args (T.TStruct fields) = PauseJobUpdate_args{
  pauseJobUpdate_args_jobKey = P.maybe (pauseJobUpdate_args_jobKey default_PauseJobUpdate_args) (\(_,_val1059) -> (case _val1059 of {T.TStruct _val1060 -> (to_JobKey (T.TStruct _val1060)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  pauseJobUpdate_args_session = P.maybe (pauseJobUpdate_args_session default_PauseJobUpdate_args) (\(_,_val1059) -> (case _val1059 of {T.TStruct _val1061 -> (to_SessionKey (T.TStruct _val1061)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PauseJobUpdate_args _ = P.error "not a struct"
read_PauseJobUpdate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO PauseJobUpdate_args
read_PauseJobUpdate_args iprot = to_PauseJobUpdate_args <$> T.readVal iprot (T.T_STRUCT typemap_PauseJobUpdate_args)
decode_PauseJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PauseJobUpdate_args
decode_PauseJobUpdate_args iprot bs = to_PauseJobUpdate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_PauseJobUpdate_args) bs
typemap_PauseJobUpdate_args :: T.TypeMap
typemap_PauseJobUpdate_args = Map.fromList [(1,("jobKey",(T.T_STRUCT typemap_JobKey))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_PauseJobUpdate_args :: PauseJobUpdate_args
default_PauseJobUpdate_args = PauseJobUpdate_args{
  pauseJobUpdate_args_jobKey = default_JobKey,
  pauseJobUpdate_args_session = default_SessionKey}
data PauseJobUpdate_result = PauseJobUpdate_result  { pauseJobUpdate_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PauseJobUpdate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` pauseJobUpdate_result_success record  
instance QC.Arbitrary PauseJobUpdate_result where 
  arbitrary = M.liftM PauseJobUpdate_result (QC.arbitrary)
  shrink obj | obj == default_PauseJobUpdate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PauseJobUpdate_result{pauseJobUpdate_result_success = pauseJobUpdate_result_success obj} then P.Nothing else P.Just $ default_PauseJobUpdate_result{pauseJobUpdate_result_success = pauseJobUpdate_result_success obj}
    ]
from_PauseJobUpdate_result :: PauseJobUpdate_result -> T.ThriftVal
from_PauseJobUpdate_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1064 -> P.Just (0, ("success",from_Response _v1064))) $ pauseJobUpdate_result_success record
  ]
write_PauseJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> PauseJobUpdate_result -> P.IO ()
write_PauseJobUpdate_result oprot record = T.writeVal oprot $ from_PauseJobUpdate_result record
encode_PauseJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> PauseJobUpdate_result -> LBS.ByteString
encode_PauseJobUpdate_result oprot record = T.serializeVal oprot $ from_PauseJobUpdate_result record
to_PauseJobUpdate_result :: T.ThriftVal -> PauseJobUpdate_result
to_PauseJobUpdate_result (T.TStruct fields) = PauseJobUpdate_result{
  pauseJobUpdate_result_success = P.maybe (pauseJobUpdate_result_success default_PauseJobUpdate_result) (\(_,_val1066) -> (case _val1066 of {T.TStruct _val1067 -> (to_Response (T.TStruct _val1067)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_PauseJobUpdate_result _ = P.error "not a struct"
read_PauseJobUpdate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO PauseJobUpdate_result
read_PauseJobUpdate_result iprot = to_PauseJobUpdate_result <$> T.readVal iprot (T.T_STRUCT typemap_PauseJobUpdate_result)
decode_PauseJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PauseJobUpdate_result
decode_PauseJobUpdate_result iprot bs = to_PauseJobUpdate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_PauseJobUpdate_result) bs
typemap_PauseJobUpdate_result :: T.TypeMap
typemap_PauseJobUpdate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_PauseJobUpdate_result :: PauseJobUpdate_result
default_PauseJobUpdate_result = PauseJobUpdate_result{
  pauseJobUpdate_result_success = default_Response}
data ResumeJobUpdate_args = ResumeJobUpdate_args  { resumeJobUpdate_args_jobKey :: JobKey
  , resumeJobUpdate_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ResumeJobUpdate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resumeJobUpdate_args_jobKey record   `H.hashWithSalt` resumeJobUpdate_args_session record  
instance QC.Arbitrary ResumeJobUpdate_args where 
  arbitrary = M.liftM ResumeJobUpdate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ResumeJobUpdate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResumeJobUpdate_args{resumeJobUpdate_args_jobKey = resumeJobUpdate_args_jobKey obj} then P.Nothing else P.Just $ default_ResumeJobUpdate_args{resumeJobUpdate_args_jobKey = resumeJobUpdate_args_jobKey obj}
    , if obj == default_ResumeJobUpdate_args{resumeJobUpdate_args_session = resumeJobUpdate_args_session obj} then P.Nothing else P.Just $ default_ResumeJobUpdate_args{resumeJobUpdate_args_session = resumeJobUpdate_args_session obj}
    ]
from_ResumeJobUpdate_args :: ResumeJobUpdate_args -> T.ThriftVal
from_ResumeJobUpdate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1070 -> P.Just (1, ("jobKey",from_JobKey _v1070))) $ resumeJobUpdate_args_jobKey record
  , (\_v1070 -> P.Just (2, ("session",from_SessionKey _v1070))) $ resumeJobUpdate_args_session record
  ]
write_ResumeJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> ResumeJobUpdate_args -> P.IO ()
write_ResumeJobUpdate_args oprot record = T.writeVal oprot $ from_ResumeJobUpdate_args record
encode_ResumeJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> ResumeJobUpdate_args -> LBS.ByteString
encode_ResumeJobUpdate_args oprot record = T.serializeVal oprot $ from_ResumeJobUpdate_args record
to_ResumeJobUpdate_args :: T.ThriftVal -> ResumeJobUpdate_args
to_ResumeJobUpdate_args (T.TStruct fields) = ResumeJobUpdate_args{
  resumeJobUpdate_args_jobKey = P.maybe (resumeJobUpdate_args_jobKey default_ResumeJobUpdate_args) (\(_,_val1072) -> (case _val1072 of {T.TStruct _val1073 -> (to_JobKey (T.TStruct _val1073)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  resumeJobUpdate_args_session = P.maybe (resumeJobUpdate_args_session default_ResumeJobUpdate_args) (\(_,_val1072) -> (case _val1072 of {T.TStruct _val1074 -> (to_SessionKey (T.TStruct _val1074)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResumeJobUpdate_args _ = P.error "not a struct"
read_ResumeJobUpdate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ResumeJobUpdate_args
read_ResumeJobUpdate_args iprot = to_ResumeJobUpdate_args <$> T.readVal iprot (T.T_STRUCT typemap_ResumeJobUpdate_args)
decode_ResumeJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ResumeJobUpdate_args
decode_ResumeJobUpdate_args iprot bs = to_ResumeJobUpdate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResumeJobUpdate_args) bs
typemap_ResumeJobUpdate_args :: T.TypeMap
typemap_ResumeJobUpdate_args = Map.fromList [(1,("jobKey",(T.T_STRUCT typemap_JobKey))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_ResumeJobUpdate_args :: ResumeJobUpdate_args
default_ResumeJobUpdate_args = ResumeJobUpdate_args{
  resumeJobUpdate_args_jobKey = default_JobKey,
  resumeJobUpdate_args_session = default_SessionKey}
data ResumeJobUpdate_result = ResumeJobUpdate_result  { resumeJobUpdate_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ResumeJobUpdate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resumeJobUpdate_result_success record  
instance QC.Arbitrary ResumeJobUpdate_result where 
  arbitrary = M.liftM ResumeJobUpdate_result (QC.arbitrary)
  shrink obj | obj == default_ResumeJobUpdate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResumeJobUpdate_result{resumeJobUpdate_result_success = resumeJobUpdate_result_success obj} then P.Nothing else P.Just $ default_ResumeJobUpdate_result{resumeJobUpdate_result_success = resumeJobUpdate_result_success obj}
    ]
from_ResumeJobUpdate_result :: ResumeJobUpdate_result -> T.ThriftVal
from_ResumeJobUpdate_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1077 -> P.Just (0, ("success",from_Response _v1077))) $ resumeJobUpdate_result_success record
  ]
write_ResumeJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> ResumeJobUpdate_result -> P.IO ()
write_ResumeJobUpdate_result oprot record = T.writeVal oprot $ from_ResumeJobUpdate_result record
encode_ResumeJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> ResumeJobUpdate_result -> LBS.ByteString
encode_ResumeJobUpdate_result oprot record = T.serializeVal oprot $ from_ResumeJobUpdate_result record
to_ResumeJobUpdate_result :: T.ThriftVal -> ResumeJobUpdate_result
to_ResumeJobUpdate_result (T.TStruct fields) = ResumeJobUpdate_result{
  resumeJobUpdate_result_success = P.maybe (resumeJobUpdate_result_success default_ResumeJobUpdate_result) (\(_,_val1079) -> (case _val1079 of {T.TStruct _val1080 -> (to_Response (T.TStruct _val1080)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_ResumeJobUpdate_result _ = P.error "not a struct"
read_ResumeJobUpdate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ResumeJobUpdate_result
read_ResumeJobUpdate_result iprot = to_ResumeJobUpdate_result <$> T.readVal iprot (T.T_STRUCT typemap_ResumeJobUpdate_result)
decode_ResumeJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ResumeJobUpdate_result
decode_ResumeJobUpdate_result iprot bs = to_ResumeJobUpdate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResumeJobUpdate_result) bs
typemap_ResumeJobUpdate_result :: T.TypeMap
typemap_ResumeJobUpdate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_ResumeJobUpdate_result :: ResumeJobUpdate_result
default_ResumeJobUpdate_result = ResumeJobUpdate_result{
  resumeJobUpdate_result_success = default_Response}
data AbortJobUpdate_args = AbortJobUpdate_args  { abortJobUpdate_args_jobKey :: JobKey
  , abortJobUpdate_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AbortJobUpdate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` abortJobUpdate_args_jobKey record   `H.hashWithSalt` abortJobUpdate_args_session record  
instance QC.Arbitrary AbortJobUpdate_args where 
  arbitrary = M.liftM AbortJobUpdate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AbortJobUpdate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AbortJobUpdate_args{abortJobUpdate_args_jobKey = abortJobUpdate_args_jobKey obj} then P.Nothing else P.Just $ default_AbortJobUpdate_args{abortJobUpdate_args_jobKey = abortJobUpdate_args_jobKey obj}
    , if obj == default_AbortJobUpdate_args{abortJobUpdate_args_session = abortJobUpdate_args_session obj} then P.Nothing else P.Just $ default_AbortJobUpdate_args{abortJobUpdate_args_session = abortJobUpdate_args_session obj}
    ]
from_AbortJobUpdate_args :: AbortJobUpdate_args -> T.ThriftVal
from_AbortJobUpdate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1083 -> P.Just (1, ("jobKey",from_JobKey _v1083))) $ abortJobUpdate_args_jobKey record
  , (\_v1083 -> P.Just (2, ("session",from_SessionKey _v1083))) $ abortJobUpdate_args_session record
  ]
write_AbortJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> AbortJobUpdate_args -> P.IO ()
write_AbortJobUpdate_args oprot record = T.writeVal oprot $ from_AbortJobUpdate_args record
encode_AbortJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> AbortJobUpdate_args -> LBS.ByteString
encode_AbortJobUpdate_args oprot record = T.serializeVal oprot $ from_AbortJobUpdate_args record
to_AbortJobUpdate_args :: T.ThriftVal -> AbortJobUpdate_args
to_AbortJobUpdate_args (T.TStruct fields) = AbortJobUpdate_args{
  abortJobUpdate_args_jobKey = P.maybe (abortJobUpdate_args_jobKey default_AbortJobUpdate_args) (\(_,_val1085) -> (case _val1085 of {T.TStruct _val1086 -> (to_JobKey (T.TStruct _val1086)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  abortJobUpdate_args_session = P.maybe (abortJobUpdate_args_session default_AbortJobUpdate_args) (\(_,_val1085) -> (case _val1085 of {T.TStruct _val1087 -> (to_SessionKey (T.TStruct _val1087)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AbortJobUpdate_args _ = P.error "not a struct"
read_AbortJobUpdate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO AbortJobUpdate_args
read_AbortJobUpdate_args iprot = to_AbortJobUpdate_args <$> T.readVal iprot (T.T_STRUCT typemap_AbortJobUpdate_args)
decode_AbortJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AbortJobUpdate_args
decode_AbortJobUpdate_args iprot bs = to_AbortJobUpdate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AbortJobUpdate_args) bs
typemap_AbortJobUpdate_args :: T.TypeMap
typemap_AbortJobUpdate_args = Map.fromList [(1,("jobKey",(T.T_STRUCT typemap_JobKey))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_AbortJobUpdate_args :: AbortJobUpdate_args
default_AbortJobUpdate_args = AbortJobUpdate_args{
  abortJobUpdate_args_jobKey = default_JobKey,
  abortJobUpdate_args_session = default_SessionKey}
data AbortJobUpdate_result = AbortJobUpdate_result  { abortJobUpdate_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable AbortJobUpdate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` abortJobUpdate_result_success record  
instance QC.Arbitrary AbortJobUpdate_result where 
  arbitrary = M.liftM AbortJobUpdate_result (QC.arbitrary)
  shrink obj | obj == default_AbortJobUpdate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AbortJobUpdate_result{abortJobUpdate_result_success = abortJobUpdate_result_success obj} then P.Nothing else P.Just $ default_AbortJobUpdate_result{abortJobUpdate_result_success = abortJobUpdate_result_success obj}
    ]
from_AbortJobUpdate_result :: AbortJobUpdate_result -> T.ThriftVal
from_AbortJobUpdate_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1090 -> P.Just (0, ("success",from_Response _v1090))) $ abortJobUpdate_result_success record
  ]
write_AbortJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> AbortJobUpdate_result -> P.IO ()
write_AbortJobUpdate_result oprot record = T.writeVal oprot $ from_AbortJobUpdate_result record
encode_AbortJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> AbortJobUpdate_result -> LBS.ByteString
encode_AbortJobUpdate_result oprot record = T.serializeVal oprot $ from_AbortJobUpdate_result record
to_AbortJobUpdate_result :: T.ThriftVal -> AbortJobUpdate_result
to_AbortJobUpdate_result (T.TStruct fields) = AbortJobUpdate_result{
  abortJobUpdate_result_success = P.maybe (abortJobUpdate_result_success default_AbortJobUpdate_result) (\(_,_val1092) -> (case _val1092 of {T.TStruct _val1093 -> (to_Response (T.TStruct _val1093)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_AbortJobUpdate_result _ = P.error "not a struct"
read_AbortJobUpdate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO AbortJobUpdate_result
read_AbortJobUpdate_result iprot = to_AbortJobUpdate_result <$> T.readVal iprot (T.T_STRUCT typemap_AbortJobUpdate_result)
decode_AbortJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AbortJobUpdate_result
decode_AbortJobUpdate_result iprot bs = to_AbortJobUpdate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AbortJobUpdate_result) bs
typemap_AbortJobUpdate_result :: T.TypeMap
typemap_AbortJobUpdate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_AbortJobUpdate_result :: AbortJobUpdate_result
default_AbortJobUpdate_result = AbortJobUpdate_result{
  abortJobUpdate_result_success = default_Response}
data PulseJobUpdate_args = PulseJobUpdate_args  { pulseJobUpdate_args_updateId :: LT.Text
  , pulseJobUpdate_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PulseJobUpdate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` pulseJobUpdate_args_updateId record   `H.hashWithSalt` pulseJobUpdate_args_session record  
instance QC.Arbitrary PulseJobUpdate_args where 
  arbitrary = M.liftM PulseJobUpdate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PulseJobUpdate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PulseJobUpdate_args{pulseJobUpdate_args_updateId = pulseJobUpdate_args_updateId obj} then P.Nothing else P.Just $ default_PulseJobUpdate_args{pulseJobUpdate_args_updateId = pulseJobUpdate_args_updateId obj}
    , if obj == default_PulseJobUpdate_args{pulseJobUpdate_args_session = pulseJobUpdate_args_session obj} then P.Nothing else P.Just $ default_PulseJobUpdate_args{pulseJobUpdate_args_session = pulseJobUpdate_args_session obj}
    ]
from_PulseJobUpdate_args :: PulseJobUpdate_args -> T.ThriftVal
from_PulseJobUpdate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1096 -> P.Just (1, ("updateId",T.TString $ E.encodeUtf8 _v1096))) $ pulseJobUpdate_args_updateId record
  , (\_v1096 -> P.Just (2, ("session",from_SessionKey _v1096))) $ pulseJobUpdate_args_session record
  ]
write_PulseJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> PulseJobUpdate_args -> P.IO ()
write_PulseJobUpdate_args oprot record = T.writeVal oprot $ from_PulseJobUpdate_args record
encode_PulseJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> PulseJobUpdate_args -> LBS.ByteString
encode_PulseJobUpdate_args oprot record = T.serializeVal oprot $ from_PulseJobUpdate_args record
to_PulseJobUpdate_args :: T.ThriftVal -> PulseJobUpdate_args
to_PulseJobUpdate_args (T.TStruct fields) = PulseJobUpdate_args{
  pulseJobUpdate_args_updateId = P.maybe (pulseJobUpdate_args_updateId default_PulseJobUpdate_args) (\(_,_val1098) -> (case _val1098 of {T.TString _val1099 -> E.decodeUtf8 _val1099; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  pulseJobUpdate_args_session = P.maybe (pulseJobUpdate_args_session default_PulseJobUpdate_args) (\(_,_val1098) -> (case _val1098 of {T.TStruct _val1100 -> (to_SessionKey (T.TStruct _val1100)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PulseJobUpdate_args _ = P.error "not a struct"
read_PulseJobUpdate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO PulseJobUpdate_args
read_PulseJobUpdate_args iprot = to_PulseJobUpdate_args <$> T.readVal iprot (T.T_STRUCT typemap_PulseJobUpdate_args)
decode_PulseJobUpdate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PulseJobUpdate_args
decode_PulseJobUpdate_args iprot bs = to_PulseJobUpdate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_PulseJobUpdate_args) bs
typemap_PulseJobUpdate_args :: T.TypeMap
typemap_PulseJobUpdate_args = Map.fromList [(1,("updateId",T.T_STRING)),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_PulseJobUpdate_args :: PulseJobUpdate_args
default_PulseJobUpdate_args = PulseJobUpdate_args{
  pulseJobUpdate_args_updateId = "",
  pulseJobUpdate_args_session = default_SessionKey}
data PulseJobUpdate_result = PulseJobUpdate_result  { pulseJobUpdate_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PulseJobUpdate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` pulseJobUpdate_result_success record  
instance QC.Arbitrary PulseJobUpdate_result where 
  arbitrary = M.liftM PulseJobUpdate_result (QC.arbitrary)
  shrink obj | obj == default_PulseJobUpdate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PulseJobUpdate_result{pulseJobUpdate_result_success = pulseJobUpdate_result_success obj} then P.Nothing else P.Just $ default_PulseJobUpdate_result{pulseJobUpdate_result_success = pulseJobUpdate_result_success obj}
    ]
from_PulseJobUpdate_result :: PulseJobUpdate_result -> T.ThriftVal
from_PulseJobUpdate_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1103 -> P.Just (0, ("success",from_Response _v1103))) $ pulseJobUpdate_result_success record
  ]
write_PulseJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> PulseJobUpdate_result -> P.IO ()
write_PulseJobUpdate_result oprot record = T.writeVal oprot $ from_PulseJobUpdate_result record
encode_PulseJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> PulseJobUpdate_result -> LBS.ByteString
encode_PulseJobUpdate_result oprot record = T.serializeVal oprot $ from_PulseJobUpdate_result record
to_PulseJobUpdate_result :: T.ThriftVal -> PulseJobUpdate_result
to_PulseJobUpdate_result (T.TStruct fields) = PulseJobUpdate_result{
  pulseJobUpdate_result_success = P.maybe (pulseJobUpdate_result_success default_PulseJobUpdate_result) (\(_,_val1105) -> (case _val1105 of {T.TStruct _val1106 -> (to_Response (T.TStruct _val1106)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_PulseJobUpdate_result _ = P.error "not a struct"
read_PulseJobUpdate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO PulseJobUpdate_result
read_PulseJobUpdate_result iprot = to_PulseJobUpdate_result <$> T.readVal iprot (T.T_STRUCT typemap_PulseJobUpdate_result)
decode_PulseJobUpdate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PulseJobUpdate_result
decode_PulseJobUpdate_result iprot bs = to_PulseJobUpdate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_PulseJobUpdate_result) bs
typemap_PulseJobUpdate_result :: T.TypeMap
typemap_PulseJobUpdate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_PulseJobUpdate_result :: PulseJobUpdate_result
default_PulseJobUpdate_result = PulseJobUpdate_result{
  pulseJobUpdate_result_success = default_Response}
process_createJob (seqid, iprot, oprot, handler) = do
  args <- read_CreateJob_args iprot
  (X.catch
    (do
      val <- Iface.createJob handler (createJob_args_description args) (createJob_args_lock args) (createJob_args_session args)
      let res = default_CreateJob_result{createJob_result_success = val}
      T.writeMessageBegin oprot ("createJob", T.M_REPLY, seqid)
      write_CreateJob_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("createJob", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_scheduleCronJob (seqid, iprot, oprot, handler) = do
  args <- read_ScheduleCronJob_args iprot
  (X.catch
    (do
      val <- Iface.scheduleCronJob handler (scheduleCronJob_args_description args) (scheduleCronJob_args_lock args) (scheduleCronJob_args_session args)
      let res = default_ScheduleCronJob_result{scheduleCronJob_result_success = val}
      T.writeMessageBegin oprot ("scheduleCronJob", T.M_REPLY, seqid)
      write_ScheduleCronJob_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("scheduleCronJob", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_descheduleCronJob (seqid, iprot, oprot, handler) = do
  args <- read_DescheduleCronJob_args iprot
  (X.catch
    (do
      val <- Iface.descheduleCronJob handler (descheduleCronJob_args_job args) (descheduleCronJob_args_lock args) (descheduleCronJob_args_session args)
      let res = default_DescheduleCronJob_result{descheduleCronJob_result_success = val}
      T.writeMessageBegin oprot ("descheduleCronJob", T.M_REPLY, seqid)
      write_DescheduleCronJob_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("descheduleCronJob", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_startCronJob (seqid, iprot, oprot, handler) = do
  args <- read_StartCronJob_args iprot
  (X.catch
    (do
      val <- Iface.startCronJob handler (startCronJob_args_job args) (startCronJob_args_session args)
      let res = default_StartCronJob_result{startCronJob_result_success = val}
      T.writeMessageBegin oprot ("startCronJob", T.M_REPLY, seqid)
      write_StartCronJob_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("startCronJob", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_restartShards (seqid, iprot, oprot, handler) = do
  args <- read_RestartShards_args iprot
  (X.catch
    (do
      val <- Iface.restartShards handler (restartShards_args_job args) (restartShards_args_shardIds args) (restartShards_args_lock args) (restartShards_args_session args)
      let res = default_RestartShards_result{restartShards_result_success = val}
      T.writeMessageBegin oprot ("restartShards", T.M_REPLY, seqid)
      write_RestartShards_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("restartShards", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_killTasks (seqid, iprot, oprot, handler) = do
  args <- read_KillTasks_args iprot
  (X.catch
    (do
      val <- Iface.killTasks handler (killTasks_args_query args) (killTasks_args_lock args) (killTasks_args_session args)
      let res = default_KillTasks_result{killTasks_result_success = val}
      T.writeMessageBegin oprot ("killTasks", T.M_REPLY, seqid)
      write_KillTasks_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("killTasks", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_addInstances (seqid, iprot, oprot, handler) = do
  args <- read_AddInstances_args iprot
  (X.catch
    (do
      val <- Iface.addInstances handler (addInstances_args_config args) (addInstances_args_lock args) (addInstances_args_session args)
      let res = default_AddInstances_result{addInstances_result_success = val}
      T.writeMessageBegin oprot ("addInstances", T.M_REPLY, seqid)
      write_AddInstances_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("addInstances", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_acquireLock (seqid, iprot, oprot, handler) = do
  args <- read_AcquireLock_args iprot
  (X.catch
    (do
      val <- Iface.acquireLock handler (acquireLock_args_lockKey args) (acquireLock_args_session args)
      let res = default_AcquireLock_result{acquireLock_result_success = val}
      T.writeMessageBegin oprot ("acquireLock", T.M_REPLY, seqid)
      write_AcquireLock_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("acquireLock", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_releaseLock (seqid, iprot, oprot, handler) = do
  args <- read_ReleaseLock_args iprot
  (X.catch
    (do
      val <- Iface.releaseLock handler (releaseLock_args_lock args) (releaseLock_args_validation args) (releaseLock_args_session args)
      let res = default_ReleaseLock_result{releaseLock_result_success = val}
      T.writeMessageBegin oprot ("releaseLock", T.M_REPLY, seqid)
      write_ReleaseLock_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("releaseLock", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_replaceCronTemplate (seqid, iprot, oprot, handler) = do
  args <- read_ReplaceCronTemplate_args iprot
  (X.catch
    (do
      val <- Iface.replaceCronTemplate handler (replaceCronTemplate_args_config args) (replaceCronTemplate_args_lock args) (replaceCronTemplate_args_session args)
      let res = default_ReplaceCronTemplate_result{replaceCronTemplate_result_success = val}
      T.writeMessageBegin oprot ("replaceCronTemplate", T.M_REPLY, seqid)
      write_ReplaceCronTemplate_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("replaceCronTemplate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_startJobUpdate (seqid, iprot, oprot, handler) = do
  args <- read_StartJobUpdate_args iprot
  (X.catch
    (do
      val <- Iface.startJobUpdate handler (startJobUpdate_args_request args) (startJobUpdate_args_session args)
      let res = default_StartJobUpdate_result{startJobUpdate_result_success = val}
      T.writeMessageBegin oprot ("startJobUpdate", T.M_REPLY, seqid)
      write_StartJobUpdate_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("startJobUpdate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_pauseJobUpdate (seqid, iprot, oprot, handler) = do
  args <- read_PauseJobUpdate_args iprot
  (X.catch
    (do
      val <- Iface.pauseJobUpdate handler (pauseJobUpdate_args_jobKey args) (pauseJobUpdate_args_session args)
      let res = default_PauseJobUpdate_result{pauseJobUpdate_result_success = val}
      T.writeMessageBegin oprot ("pauseJobUpdate", T.M_REPLY, seqid)
      write_PauseJobUpdate_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("pauseJobUpdate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_resumeJobUpdate (seqid, iprot, oprot, handler) = do
  args <- read_ResumeJobUpdate_args iprot
  (X.catch
    (do
      val <- Iface.resumeJobUpdate handler (resumeJobUpdate_args_jobKey args) (resumeJobUpdate_args_session args)
      let res = default_ResumeJobUpdate_result{resumeJobUpdate_result_success = val}
      T.writeMessageBegin oprot ("resumeJobUpdate", T.M_REPLY, seqid)
      write_ResumeJobUpdate_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("resumeJobUpdate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_abortJobUpdate (seqid, iprot, oprot, handler) = do
  args <- read_AbortJobUpdate_args iprot
  (X.catch
    (do
      val <- Iface.abortJobUpdate handler (abortJobUpdate_args_jobKey args) (abortJobUpdate_args_session args)
      let res = default_AbortJobUpdate_result{abortJobUpdate_result_success = val}
      T.writeMessageBegin oprot ("abortJobUpdate", T.M_REPLY, seqid)
      write_AbortJobUpdate_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("abortJobUpdate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_pulseJobUpdate (seqid, iprot, oprot, handler) = do
  args <- read_PulseJobUpdate_args iprot
  (X.catch
    (do
      val <- Iface.pulseJobUpdate handler (pulseJobUpdate_args_updateId args) (pulseJobUpdate_args_session args)
      let res = default_PulseJobUpdate_result{pulseJobUpdate_result_success = val}
      T.writeMessageBegin oprot ("pulseJobUpdate", T.M_REPLY, seqid)
      write_PulseJobUpdate_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("pulseJobUpdate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "createJob" -> process_createJob (seqid,iprot,oprot,handler)
  "scheduleCronJob" -> process_scheduleCronJob (seqid,iprot,oprot,handler)
  "descheduleCronJob" -> process_descheduleCronJob (seqid,iprot,oprot,handler)
  "startCronJob" -> process_startCronJob (seqid,iprot,oprot,handler)
  "restartShards" -> process_restartShards (seqid,iprot,oprot,handler)
  "killTasks" -> process_killTasks (seqid,iprot,oprot,handler)
  "addInstances" -> process_addInstances (seqid,iprot,oprot,handler)
  "acquireLock" -> process_acquireLock (seqid,iprot,oprot,handler)
  "releaseLock" -> process_releaseLock (seqid,iprot,oprot,handler)
  "replaceCronTemplate" -> process_replaceCronTemplate (seqid,iprot,oprot,handler)
  "startJobUpdate" -> process_startJobUpdate (seqid,iprot,oprot,handler)
  "pauseJobUpdate" -> process_pauseJobUpdate (seqid,iprot,oprot,handler)
  "resumeJobUpdate" -> process_resumeJobUpdate (seqid,iprot,oprot,handler)
  "abortJobUpdate" -> process_abortJobUpdate (seqid,iprot,oprot,handler)
  "pulseJobUpdate" -> process_pulseJobUpdate (seqid,iprot,oprot,handler)
  _ -> ReadOnlyScheduler.proc_ handler (iprot,oprot) (name,typ,seqid)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
