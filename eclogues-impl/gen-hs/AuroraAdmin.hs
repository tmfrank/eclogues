{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AuroraAdmin where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import qualified AuroraSchedulerManager
import Api_Types
import qualified AuroraAdmin_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data SetQuota_args = SetQuota_args  { setQuota_args_ownerRole :: LT.Text
  , setQuota_args_quota :: ResourceAggregate
  , setQuota_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable SetQuota_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setQuota_args_ownerRole record   `H.hashWithSalt` setQuota_args_quota record   `H.hashWithSalt` setQuota_args_session record  
instance QC.Arbitrary SetQuota_args where 
  arbitrary = M.liftM SetQuota_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetQuota_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetQuota_args{setQuota_args_ownerRole = setQuota_args_ownerRole obj} then P.Nothing else P.Just $ default_SetQuota_args{setQuota_args_ownerRole = setQuota_args_ownerRole obj}
    , if obj == default_SetQuota_args{setQuota_args_quota = setQuota_args_quota obj} then P.Nothing else P.Just $ default_SetQuota_args{setQuota_args_quota = setQuota_args_quota obj}
    , if obj == default_SetQuota_args{setQuota_args_session = setQuota_args_session obj} then P.Nothing else P.Just $ default_SetQuota_args{setQuota_args_session = setQuota_args_session obj}
    ]
from_SetQuota_args :: SetQuota_args -> T.ThriftVal
from_SetQuota_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1109 -> P.Just (1, ("ownerRole",T.TString $ E.encodeUtf8 _v1109))) $ setQuota_args_ownerRole record
  , (\_v1109 -> P.Just (2, ("quota",from_ResourceAggregate _v1109))) $ setQuota_args_quota record
  , (\_v1109 -> P.Just (3, ("session",from_SessionKey _v1109))) $ setQuota_args_session record
  ]
write_SetQuota_args :: (T.Protocol p, T.Transport t) => p t -> SetQuota_args -> P.IO ()
write_SetQuota_args oprot record = T.writeVal oprot $ from_SetQuota_args record
encode_SetQuota_args :: (T.Protocol p, T.Transport t) => p t -> SetQuota_args -> LBS.ByteString
encode_SetQuota_args oprot record = T.serializeVal oprot $ from_SetQuota_args record
to_SetQuota_args :: T.ThriftVal -> SetQuota_args
to_SetQuota_args (T.TStruct fields) = SetQuota_args{
  setQuota_args_ownerRole = P.maybe (setQuota_args_ownerRole default_SetQuota_args) (\(_,_val1111) -> (case _val1111 of {T.TString _val1112 -> E.decodeUtf8 _val1112; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setQuota_args_quota = P.maybe (setQuota_args_quota default_SetQuota_args) (\(_,_val1111) -> (case _val1111 of {T.TStruct _val1113 -> (to_ResourceAggregate (T.TStruct _val1113)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setQuota_args_session = P.maybe (setQuota_args_session default_SetQuota_args) (\(_,_val1111) -> (case _val1111 of {T.TStruct _val1114 -> (to_SessionKey (T.TStruct _val1114)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SetQuota_args _ = P.error "not a struct"
read_SetQuota_args :: (T.Transport t, T.Protocol p) => p t -> P.IO SetQuota_args
read_SetQuota_args iprot = to_SetQuota_args <$> T.readVal iprot (T.T_STRUCT typemap_SetQuota_args)
decode_SetQuota_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SetQuota_args
decode_SetQuota_args iprot bs = to_SetQuota_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetQuota_args) bs
typemap_SetQuota_args :: T.TypeMap
typemap_SetQuota_args = Map.fromList [(1,("ownerRole",T.T_STRING)),(2,("quota",(T.T_STRUCT typemap_ResourceAggregate))),(3,("session",(T.T_STRUCT typemap_SessionKey)))]
default_SetQuota_args :: SetQuota_args
default_SetQuota_args = SetQuota_args{
  setQuota_args_ownerRole = "",
  setQuota_args_quota = default_ResourceAggregate,
  setQuota_args_session = default_SessionKey}
data SetQuota_result = SetQuota_result  { setQuota_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable SetQuota_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setQuota_result_success record  
instance QC.Arbitrary SetQuota_result where 
  arbitrary = M.liftM SetQuota_result (QC.arbitrary)
  shrink obj | obj == default_SetQuota_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetQuota_result{setQuota_result_success = setQuota_result_success obj} then P.Nothing else P.Just $ default_SetQuota_result{setQuota_result_success = setQuota_result_success obj}
    ]
from_SetQuota_result :: SetQuota_result -> T.ThriftVal
from_SetQuota_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1117 -> P.Just (0, ("success",from_Response _v1117))) $ setQuota_result_success record
  ]
write_SetQuota_result :: (T.Protocol p, T.Transport t) => p t -> SetQuota_result -> P.IO ()
write_SetQuota_result oprot record = T.writeVal oprot $ from_SetQuota_result record
encode_SetQuota_result :: (T.Protocol p, T.Transport t) => p t -> SetQuota_result -> LBS.ByteString
encode_SetQuota_result oprot record = T.serializeVal oprot $ from_SetQuota_result record
to_SetQuota_result :: T.ThriftVal -> SetQuota_result
to_SetQuota_result (T.TStruct fields) = SetQuota_result{
  setQuota_result_success = P.maybe (setQuota_result_success default_SetQuota_result) (\(_,_val1119) -> (case _val1119 of {T.TStruct _val1120 -> (to_Response (T.TStruct _val1120)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_SetQuota_result _ = P.error "not a struct"
read_SetQuota_result :: (T.Transport t, T.Protocol p) => p t -> P.IO SetQuota_result
read_SetQuota_result iprot = to_SetQuota_result <$> T.readVal iprot (T.T_STRUCT typemap_SetQuota_result)
decode_SetQuota_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SetQuota_result
decode_SetQuota_result iprot bs = to_SetQuota_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetQuota_result) bs
typemap_SetQuota_result :: T.TypeMap
typemap_SetQuota_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_SetQuota_result :: SetQuota_result
default_SetQuota_result = SetQuota_result{
  setQuota_result_success = default_Response}
data ForceTaskState_args = ForceTaskState_args  { forceTaskState_args_taskId :: LT.Text
  , forceTaskState_args_status :: ScheduleStatus
  , forceTaskState_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ForceTaskState_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` forceTaskState_args_taskId record   `H.hashWithSalt` forceTaskState_args_status record   `H.hashWithSalt` forceTaskState_args_session record  
instance QC.Arbitrary ForceTaskState_args where 
  arbitrary = M.liftM ForceTaskState_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ForceTaskState_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ForceTaskState_args{forceTaskState_args_taskId = forceTaskState_args_taskId obj} then P.Nothing else P.Just $ default_ForceTaskState_args{forceTaskState_args_taskId = forceTaskState_args_taskId obj}
    , if obj == default_ForceTaskState_args{forceTaskState_args_status = forceTaskState_args_status obj} then P.Nothing else P.Just $ default_ForceTaskState_args{forceTaskState_args_status = forceTaskState_args_status obj}
    , if obj == default_ForceTaskState_args{forceTaskState_args_session = forceTaskState_args_session obj} then P.Nothing else P.Just $ default_ForceTaskState_args{forceTaskState_args_session = forceTaskState_args_session obj}
    ]
from_ForceTaskState_args :: ForceTaskState_args -> T.ThriftVal
from_ForceTaskState_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1123 -> P.Just (1, ("taskId",T.TString $ E.encodeUtf8 _v1123))) $ forceTaskState_args_taskId record
  , (\_v1123 -> P.Just (2, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v1123))) $ forceTaskState_args_status record
  , (\_v1123 -> P.Just (3, ("session",from_SessionKey _v1123))) $ forceTaskState_args_session record
  ]
write_ForceTaskState_args :: (T.Protocol p, T.Transport t) => p t -> ForceTaskState_args -> P.IO ()
write_ForceTaskState_args oprot record = T.writeVal oprot $ from_ForceTaskState_args record
encode_ForceTaskState_args :: (T.Protocol p, T.Transport t) => p t -> ForceTaskState_args -> LBS.ByteString
encode_ForceTaskState_args oprot record = T.serializeVal oprot $ from_ForceTaskState_args record
to_ForceTaskState_args :: T.ThriftVal -> ForceTaskState_args
to_ForceTaskState_args (T.TStruct fields) = ForceTaskState_args{
  forceTaskState_args_taskId = P.maybe (forceTaskState_args_taskId default_ForceTaskState_args) (\(_,_val1125) -> (case _val1125 of {T.TString _val1126 -> E.decodeUtf8 _val1126; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  forceTaskState_args_status = P.maybe (forceTaskState_args_status default_ForceTaskState_args) (\(_,_val1125) -> (case _val1125 of {T.TI32 _val1127 -> P.toEnum $ P.fromIntegral _val1127; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  forceTaskState_args_session = P.maybe (forceTaskState_args_session default_ForceTaskState_args) (\(_,_val1125) -> (case _val1125 of {T.TStruct _val1128 -> (to_SessionKey (T.TStruct _val1128)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ForceTaskState_args _ = P.error "not a struct"
read_ForceTaskState_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ForceTaskState_args
read_ForceTaskState_args iprot = to_ForceTaskState_args <$> T.readVal iprot (T.T_STRUCT typemap_ForceTaskState_args)
decode_ForceTaskState_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ForceTaskState_args
decode_ForceTaskState_args iprot bs = to_ForceTaskState_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ForceTaskState_args) bs
typemap_ForceTaskState_args :: T.TypeMap
typemap_ForceTaskState_args = Map.fromList [(1,("taskId",T.T_STRING)),(2,("status",T.T_I32)),(3,("session",(T.T_STRUCT typemap_SessionKey)))]
default_ForceTaskState_args :: ForceTaskState_args
default_ForceTaskState_args = ForceTaskState_args{
  forceTaskState_args_taskId = "",
  forceTaskState_args_status = (P.toEnum 0),
  forceTaskState_args_session = default_SessionKey}
data ForceTaskState_result = ForceTaskState_result  { forceTaskState_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ForceTaskState_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` forceTaskState_result_success record  
instance QC.Arbitrary ForceTaskState_result where 
  arbitrary = M.liftM ForceTaskState_result (QC.arbitrary)
  shrink obj | obj == default_ForceTaskState_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ForceTaskState_result{forceTaskState_result_success = forceTaskState_result_success obj} then P.Nothing else P.Just $ default_ForceTaskState_result{forceTaskState_result_success = forceTaskState_result_success obj}
    ]
from_ForceTaskState_result :: ForceTaskState_result -> T.ThriftVal
from_ForceTaskState_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1131 -> P.Just (0, ("success",from_Response _v1131))) $ forceTaskState_result_success record
  ]
write_ForceTaskState_result :: (T.Protocol p, T.Transport t) => p t -> ForceTaskState_result -> P.IO ()
write_ForceTaskState_result oprot record = T.writeVal oprot $ from_ForceTaskState_result record
encode_ForceTaskState_result :: (T.Protocol p, T.Transport t) => p t -> ForceTaskState_result -> LBS.ByteString
encode_ForceTaskState_result oprot record = T.serializeVal oprot $ from_ForceTaskState_result record
to_ForceTaskState_result :: T.ThriftVal -> ForceTaskState_result
to_ForceTaskState_result (T.TStruct fields) = ForceTaskState_result{
  forceTaskState_result_success = P.maybe (forceTaskState_result_success default_ForceTaskState_result) (\(_,_val1133) -> (case _val1133 of {T.TStruct _val1134 -> (to_Response (T.TStruct _val1134)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_ForceTaskState_result _ = P.error "not a struct"
read_ForceTaskState_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ForceTaskState_result
read_ForceTaskState_result iprot = to_ForceTaskState_result <$> T.readVal iprot (T.T_STRUCT typemap_ForceTaskState_result)
decode_ForceTaskState_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ForceTaskState_result
decode_ForceTaskState_result iprot bs = to_ForceTaskState_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ForceTaskState_result) bs
typemap_ForceTaskState_result :: T.TypeMap
typemap_ForceTaskState_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_ForceTaskState_result :: ForceTaskState_result
default_ForceTaskState_result = ForceTaskState_result{
  forceTaskState_result_success = default_Response}
data PerformBackup_args = PerformBackup_args  { performBackup_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PerformBackup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` performBackup_args_session record  
instance QC.Arbitrary PerformBackup_args where 
  arbitrary = M.liftM PerformBackup_args (QC.arbitrary)
  shrink obj | obj == default_PerformBackup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PerformBackup_args{performBackup_args_session = performBackup_args_session obj} then P.Nothing else P.Just $ default_PerformBackup_args{performBackup_args_session = performBackup_args_session obj}
    ]
from_PerformBackup_args :: PerformBackup_args -> T.ThriftVal
from_PerformBackup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1137 -> P.Just (1, ("session",from_SessionKey _v1137))) $ performBackup_args_session record
  ]
write_PerformBackup_args :: (T.Protocol p, T.Transport t) => p t -> PerformBackup_args -> P.IO ()
write_PerformBackup_args oprot record = T.writeVal oprot $ from_PerformBackup_args record
encode_PerformBackup_args :: (T.Protocol p, T.Transport t) => p t -> PerformBackup_args -> LBS.ByteString
encode_PerformBackup_args oprot record = T.serializeVal oprot $ from_PerformBackup_args record
to_PerformBackup_args :: T.ThriftVal -> PerformBackup_args
to_PerformBackup_args (T.TStruct fields) = PerformBackup_args{
  performBackup_args_session = P.maybe (performBackup_args_session default_PerformBackup_args) (\(_,_val1139) -> (case _val1139 of {T.TStruct _val1140 -> (to_SessionKey (T.TStruct _val1140)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_PerformBackup_args _ = P.error "not a struct"
read_PerformBackup_args :: (T.Transport t, T.Protocol p) => p t -> P.IO PerformBackup_args
read_PerformBackup_args iprot = to_PerformBackup_args <$> T.readVal iprot (T.T_STRUCT typemap_PerformBackup_args)
decode_PerformBackup_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PerformBackup_args
decode_PerformBackup_args iprot bs = to_PerformBackup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_PerformBackup_args) bs
typemap_PerformBackup_args :: T.TypeMap
typemap_PerformBackup_args = Map.fromList [(1,("session",(T.T_STRUCT typemap_SessionKey)))]
default_PerformBackup_args :: PerformBackup_args
default_PerformBackup_args = PerformBackup_args{
  performBackup_args_session = default_SessionKey}
data PerformBackup_result = PerformBackup_result  { performBackup_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PerformBackup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` performBackup_result_success record  
instance QC.Arbitrary PerformBackup_result where 
  arbitrary = M.liftM PerformBackup_result (QC.arbitrary)
  shrink obj | obj == default_PerformBackup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PerformBackup_result{performBackup_result_success = performBackup_result_success obj} then P.Nothing else P.Just $ default_PerformBackup_result{performBackup_result_success = performBackup_result_success obj}
    ]
from_PerformBackup_result :: PerformBackup_result -> T.ThriftVal
from_PerformBackup_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1143 -> P.Just (0, ("success",from_Response _v1143))) $ performBackup_result_success record
  ]
write_PerformBackup_result :: (T.Protocol p, T.Transport t) => p t -> PerformBackup_result -> P.IO ()
write_PerformBackup_result oprot record = T.writeVal oprot $ from_PerformBackup_result record
encode_PerformBackup_result :: (T.Protocol p, T.Transport t) => p t -> PerformBackup_result -> LBS.ByteString
encode_PerformBackup_result oprot record = T.serializeVal oprot $ from_PerformBackup_result record
to_PerformBackup_result :: T.ThriftVal -> PerformBackup_result
to_PerformBackup_result (T.TStruct fields) = PerformBackup_result{
  performBackup_result_success = P.maybe (performBackup_result_success default_PerformBackup_result) (\(_,_val1145) -> (case _val1145 of {T.TStruct _val1146 -> (to_Response (T.TStruct _val1146)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_PerformBackup_result _ = P.error "not a struct"
read_PerformBackup_result :: (T.Transport t, T.Protocol p) => p t -> P.IO PerformBackup_result
read_PerformBackup_result iprot = to_PerformBackup_result <$> T.readVal iprot (T.T_STRUCT typemap_PerformBackup_result)
decode_PerformBackup_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PerformBackup_result
decode_PerformBackup_result iprot bs = to_PerformBackup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_PerformBackup_result) bs
typemap_PerformBackup_result :: T.TypeMap
typemap_PerformBackup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_PerformBackup_result :: PerformBackup_result
default_PerformBackup_result = PerformBackup_result{
  performBackup_result_success = default_Response}
data ListBackups_args = ListBackups_args  { listBackups_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ListBackups_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBackups_args_session record  
instance QC.Arbitrary ListBackups_args where 
  arbitrary = M.liftM ListBackups_args (QC.arbitrary)
  shrink obj | obj == default_ListBackups_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBackups_args{listBackups_args_session = listBackups_args_session obj} then P.Nothing else P.Just $ default_ListBackups_args{listBackups_args_session = listBackups_args_session obj}
    ]
from_ListBackups_args :: ListBackups_args -> T.ThriftVal
from_ListBackups_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1149 -> P.Just (1, ("session",from_SessionKey _v1149))) $ listBackups_args_session record
  ]
write_ListBackups_args :: (T.Protocol p, T.Transport t) => p t -> ListBackups_args -> P.IO ()
write_ListBackups_args oprot record = T.writeVal oprot $ from_ListBackups_args record
encode_ListBackups_args :: (T.Protocol p, T.Transport t) => p t -> ListBackups_args -> LBS.ByteString
encode_ListBackups_args oprot record = T.serializeVal oprot $ from_ListBackups_args record
to_ListBackups_args :: T.ThriftVal -> ListBackups_args
to_ListBackups_args (T.TStruct fields) = ListBackups_args{
  listBackups_args_session = P.maybe (listBackups_args_session default_ListBackups_args) (\(_,_val1151) -> (case _val1151 of {T.TStruct _val1152 -> (to_SessionKey (T.TStruct _val1152)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListBackups_args _ = P.error "not a struct"
read_ListBackups_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ListBackups_args
read_ListBackups_args iprot = to_ListBackups_args <$> T.readVal iprot (T.T_STRUCT typemap_ListBackups_args)
decode_ListBackups_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ListBackups_args
decode_ListBackups_args iprot bs = to_ListBackups_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBackups_args) bs
typemap_ListBackups_args :: T.TypeMap
typemap_ListBackups_args = Map.fromList [(1,("session",(T.T_STRUCT typemap_SessionKey)))]
default_ListBackups_args :: ListBackups_args
default_ListBackups_args = ListBackups_args{
  listBackups_args_session = default_SessionKey}
data ListBackups_result = ListBackups_result  { listBackups_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ListBackups_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBackups_result_success record  
instance QC.Arbitrary ListBackups_result where 
  arbitrary = M.liftM ListBackups_result (QC.arbitrary)
  shrink obj | obj == default_ListBackups_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBackups_result{listBackups_result_success = listBackups_result_success obj} then P.Nothing else P.Just $ default_ListBackups_result{listBackups_result_success = listBackups_result_success obj}
    ]
from_ListBackups_result :: ListBackups_result -> T.ThriftVal
from_ListBackups_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1155 -> P.Just (0, ("success",from_Response _v1155))) $ listBackups_result_success record
  ]
write_ListBackups_result :: (T.Protocol p, T.Transport t) => p t -> ListBackups_result -> P.IO ()
write_ListBackups_result oprot record = T.writeVal oprot $ from_ListBackups_result record
encode_ListBackups_result :: (T.Protocol p, T.Transport t) => p t -> ListBackups_result -> LBS.ByteString
encode_ListBackups_result oprot record = T.serializeVal oprot $ from_ListBackups_result record
to_ListBackups_result :: T.ThriftVal -> ListBackups_result
to_ListBackups_result (T.TStruct fields) = ListBackups_result{
  listBackups_result_success = P.maybe (listBackups_result_success default_ListBackups_result) (\(_,_val1157) -> (case _val1157 of {T.TStruct _val1158 -> (to_Response (T.TStruct _val1158)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_ListBackups_result _ = P.error "not a struct"
read_ListBackups_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ListBackups_result
read_ListBackups_result iprot = to_ListBackups_result <$> T.readVal iprot (T.T_STRUCT typemap_ListBackups_result)
decode_ListBackups_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ListBackups_result
decode_ListBackups_result iprot bs = to_ListBackups_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBackups_result) bs
typemap_ListBackups_result :: T.TypeMap
typemap_ListBackups_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_ListBackups_result :: ListBackups_result
default_ListBackups_result = ListBackups_result{
  listBackups_result_success = default_Response}
data StageRecovery_args = StageRecovery_args  { stageRecovery_args_backupId :: LT.Text
  , stageRecovery_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StageRecovery_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` stageRecovery_args_backupId record   `H.hashWithSalt` stageRecovery_args_session record  
instance QC.Arbitrary StageRecovery_args where 
  arbitrary = M.liftM StageRecovery_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StageRecovery_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StageRecovery_args{stageRecovery_args_backupId = stageRecovery_args_backupId obj} then P.Nothing else P.Just $ default_StageRecovery_args{stageRecovery_args_backupId = stageRecovery_args_backupId obj}
    , if obj == default_StageRecovery_args{stageRecovery_args_session = stageRecovery_args_session obj} then P.Nothing else P.Just $ default_StageRecovery_args{stageRecovery_args_session = stageRecovery_args_session obj}
    ]
from_StageRecovery_args :: StageRecovery_args -> T.ThriftVal
from_StageRecovery_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1161 -> P.Just (1, ("backupId",T.TString $ E.encodeUtf8 _v1161))) $ stageRecovery_args_backupId record
  , (\_v1161 -> P.Just (2, ("session",from_SessionKey _v1161))) $ stageRecovery_args_session record
  ]
write_StageRecovery_args :: (T.Protocol p, T.Transport t) => p t -> StageRecovery_args -> P.IO ()
write_StageRecovery_args oprot record = T.writeVal oprot $ from_StageRecovery_args record
encode_StageRecovery_args :: (T.Protocol p, T.Transport t) => p t -> StageRecovery_args -> LBS.ByteString
encode_StageRecovery_args oprot record = T.serializeVal oprot $ from_StageRecovery_args record
to_StageRecovery_args :: T.ThriftVal -> StageRecovery_args
to_StageRecovery_args (T.TStruct fields) = StageRecovery_args{
  stageRecovery_args_backupId = P.maybe (stageRecovery_args_backupId default_StageRecovery_args) (\(_,_val1163) -> (case _val1163 of {T.TString _val1164 -> E.decodeUtf8 _val1164; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  stageRecovery_args_session = P.maybe (stageRecovery_args_session default_StageRecovery_args) (\(_,_val1163) -> (case _val1163 of {T.TStruct _val1165 -> (to_SessionKey (T.TStruct _val1165)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StageRecovery_args _ = P.error "not a struct"
read_StageRecovery_args :: (T.Transport t, T.Protocol p) => p t -> P.IO StageRecovery_args
read_StageRecovery_args iprot = to_StageRecovery_args <$> T.readVal iprot (T.T_STRUCT typemap_StageRecovery_args)
decode_StageRecovery_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StageRecovery_args
decode_StageRecovery_args iprot bs = to_StageRecovery_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StageRecovery_args) bs
typemap_StageRecovery_args :: T.TypeMap
typemap_StageRecovery_args = Map.fromList [(1,("backupId",T.T_STRING)),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_StageRecovery_args :: StageRecovery_args
default_StageRecovery_args = StageRecovery_args{
  stageRecovery_args_backupId = "",
  stageRecovery_args_session = default_SessionKey}
data StageRecovery_result = StageRecovery_result  { stageRecovery_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StageRecovery_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` stageRecovery_result_success record  
instance QC.Arbitrary StageRecovery_result where 
  arbitrary = M.liftM StageRecovery_result (QC.arbitrary)
  shrink obj | obj == default_StageRecovery_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StageRecovery_result{stageRecovery_result_success = stageRecovery_result_success obj} then P.Nothing else P.Just $ default_StageRecovery_result{stageRecovery_result_success = stageRecovery_result_success obj}
    ]
from_StageRecovery_result :: StageRecovery_result -> T.ThriftVal
from_StageRecovery_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1168 -> P.Just (0, ("success",from_Response _v1168))) $ stageRecovery_result_success record
  ]
write_StageRecovery_result :: (T.Protocol p, T.Transport t) => p t -> StageRecovery_result -> P.IO ()
write_StageRecovery_result oprot record = T.writeVal oprot $ from_StageRecovery_result record
encode_StageRecovery_result :: (T.Protocol p, T.Transport t) => p t -> StageRecovery_result -> LBS.ByteString
encode_StageRecovery_result oprot record = T.serializeVal oprot $ from_StageRecovery_result record
to_StageRecovery_result :: T.ThriftVal -> StageRecovery_result
to_StageRecovery_result (T.TStruct fields) = StageRecovery_result{
  stageRecovery_result_success = P.maybe (stageRecovery_result_success default_StageRecovery_result) (\(_,_val1170) -> (case _val1170 of {T.TStruct _val1171 -> (to_Response (T.TStruct _val1171)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_StageRecovery_result _ = P.error "not a struct"
read_StageRecovery_result :: (T.Transport t, T.Protocol p) => p t -> P.IO StageRecovery_result
read_StageRecovery_result iprot = to_StageRecovery_result <$> T.readVal iprot (T.T_STRUCT typemap_StageRecovery_result)
decode_StageRecovery_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StageRecovery_result
decode_StageRecovery_result iprot bs = to_StageRecovery_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StageRecovery_result) bs
typemap_StageRecovery_result :: T.TypeMap
typemap_StageRecovery_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_StageRecovery_result :: StageRecovery_result
default_StageRecovery_result = StageRecovery_result{
  stageRecovery_result_success = default_Response}
data QueryRecovery_args = QueryRecovery_args  { queryRecovery_args_query :: TaskQuery
  , queryRecovery_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable QueryRecovery_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` queryRecovery_args_query record   `H.hashWithSalt` queryRecovery_args_session record  
instance QC.Arbitrary QueryRecovery_args where 
  arbitrary = M.liftM QueryRecovery_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_QueryRecovery_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_QueryRecovery_args{queryRecovery_args_query = queryRecovery_args_query obj} then P.Nothing else P.Just $ default_QueryRecovery_args{queryRecovery_args_query = queryRecovery_args_query obj}
    , if obj == default_QueryRecovery_args{queryRecovery_args_session = queryRecovery_args_session obj} then P.Nothing else P.Just $ default_QueryRecovery_args{queryRecovery_args_session = queryRecovery_args_session obj}
    ]
from_QueryRecovery_args :: QueryRecovery_args -> T.ThriftVal
from_QueryRecovery_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1174 -> P.Just (1, ("query",from_TaskQuery _v1174))) $ queryRecovery_args_query record
  , (\_v1174 -> P.Just (2, ("session",from_SessionKey _v1174))) $ queryRecovery_args_session record
  ]
write_QueryRecovery_args :: (T.Protocol p, T.Transport t) => p t -> QueryRecovery_args -> P.IO ()
write_QueryRecovery_args oprot record = T.writeVal oprot $ from_QueryRecovery_args record
encode_QueryRecovery_args :: (T.Protocol p, T.Transport t) => p t -> QueryRecovery_args -> LBS.ByteString
encode_QueryRecovery_args oprot record = T.serializeVal oprot $ from_QueryRecovery_args record
to_QueryRecovery_args :: T.ThriftVal -> QueryRecovery_args
to_QueryRecovery_args (T.TStruct fields) = QueryRecovery_args{
  queryRecovery_args_query = P.maybe (queryRecovery_args_query default_QueryRecovery_args) (\(_,_val1176) -> (case _val1176 of {T.TStruct _val1177 -> (to_TaskQuery (T.TStruct _val1177)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  queryRecovery_args_session = P.maybe (queryRecovery_args_session default_QueryRecovery_args) (\(_,_val1176) -> (case _val1176 of {T.TStruct _val1178 -> (to_SessionKey (T.TStruct _val1178)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_QueryRecovery_args _ = P.error "not a struct"
read_QueryRecovery_args :: (T.Transport t, T.Protocol p) => p t -> P.IO QueryRecovery_args
read_QueryRecovery_args iprot = to_QueryRecovery_args <$> T.readVal iprot (T.T_STRUCT typemap_QueryRecovery_args)
decode_QueryRecovery_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> QueryRecovery_args
decode_QueryRecovery_args iprot bs = to_QueryRecovery_args $ T.deserializeVal iprot (T.T_STRUCT typemap_QueryRecovery_args) bs
typemap_QueryRecovery_args :: T.TypeMap
typemap_QueryRecovery_args = Map.fromList [(1,("query",(T.T_STRUCT typemap_TaskQuery))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_QueryRecovery_args :: QueryRecovery_args
default_QueryRecovery_args = QueryRecovery_args{
  queryRecovery_args_query = default_TaskQuery,
  queryRecovery_args_session = default_SessionKey}
data QueryRecovery_result = QueryRecovery_result  { queryRecovery_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable QueryRecovery_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` queryRecovery_result_success record  
instance QC.Arbitrary QueryRecovery_result where 
  arbitrary = M.liftM QueryRecovery_result (QC.arbitrary)
  shrink obj | obj == default_QueryRecovery_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_QueryRecovery_result{queryRecovery_result_success = queryRecovery_result_success obj} then P.Nothing else P.Just $ default_QueryRecovery_result{queryRecovery_result_success = queryRecovery_result_success obj}
    ]
from_QueryRecovery_result :: QueryRecovery_result -> T.ThriftVal
from_QueryRecovery_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1181 -> P.Just (0, ("success",from_Response _v1181))) $ queryRecovery_result_success record
  ]
write_QueryRecovery_result :: (T.Protocol p, T.Transport t) => p t -> QueryRecovery_result -> P.IO ()
write_QueryRecovery_result oprot record = T.writeVal oprot $ from_QueryRecovery_result record
encode_QueryRecovery_result :: (T.Protocol p, T.Transport t) => p t -> QueryRecovery_result -> LBS.ByteString
encode_QueryRecovery_result oprot record = T.serializeVal oprot $ from_QueryRecovery_result record
to_QueryRecovery_result :: T.ThriftVal -> QueryRecovery_result
to_QueryRecovery_result (T.TStruct fields) = QueryRecovery_result{
  queryRecovery_result_success = P.maybe (queryRecovery_result_success default_QueryRecovery_result) (\(_,_val1183) -> (case _val1183 of {T.TStruct _val1184 -> (to_Response (T.TStruct _val1184)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_QueryRecovery_result _ = P.error "not a struct"
read_QueryRecovery_result :: (T.Transport t, T.Protocol p) => p t -> P.IO QueryRecovery_result
read_QueryRecovery_result iprot = to_QueryRecovery_result <$> T.readVal iprot (T.T_STRUCT typemap_QueryRecovery_result)
decode_QueryRecovery_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> QueryRecovery_result
decode_QueryRecovery_result iprot bs = to_QueryRecovery_result $ T.deserializeVal iprot (T.T_STRUCT typemap_QueryRecovery_result) bs
typemap_QueryRecovery_result :: T.TypeMap
typemap_QueryRecovery_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_QueryRecovery_result :: QueryRecovery_result
default_QueryRecovery_result = QueryRecovery_result{
  queryRecovery_result_success = default_Response}
data DeleteRecoveryTasks_args = DeleteRecoveryTasks_args  { deleteRecoveryTasks_args_query :: TaskQuery
  , deleteRecoveryTasks_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DeleteRecoveryTasks_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteRecoveryTasks_args_query record   `H.hashWithSalt` deleteRecoveryTasks_args_session record  
instance QC.Arbitrary DeleteRecoveryTasks_args where 
  arbitrary = M.liftM DeleteRecoveryTasks_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeleteRecoveryTasks_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteRecoveryTasks_args{deleteRecoveryTasks_args_query = deleteRecoveryTasks_args_query obj} then P.Nothing else P.Just $ default_DeleteRecoveryTasks_args{deleteRecoveryTasks_args_query = deleteRecoveryTasks_args_query obj}
    , if obj == default_DeleteRecoveryTasks_args{deleteRecoveryTasks_args_session = deleteRecoveryTasks_args_session obj} then P.Nothing else P.Just $ default_DeleteRecoveryTasks_args{deleteRecoveryTasks_args_session = deleteRecoveryTasks_args_session obj}
    ]
from_DeleteRecoveryTasks_args :: DeleteRecoveryTasks_args -> T.ThriftVal
from_DeleteRecoveryTasks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1187 -> P.Just (1, ("query",from_TaskQuery _v1187))) $ deleteRecoveryTasks_args_query record
  , (\_v1187 -> P.Just (2, ("session",from_SessionKey _v1187))) $ deleteRecoveryTasks_args_session record
  ]
write_DeleteRecoveryTasks_args :: (T.Protocol p, T.Transport t) => p t -> DeleteRecoveryTasks_args -> P.IO ()
write_DeleteRecoveryTasks_args oprot record = T.writeVal oprot $ from_DeleteRecoveryTasks_args record
encode_DeleteRecoveryTasks_args :: (T.Protocol p, T.Transport t) => p t -> DeleteRecoveryTasks_args -> LBS.ByteString
encode_DeleteRecoveryTasks_args oprot record = T.serializeVal oprot $ from_DeleteRecoveryTasks_args record
to_DeleteRecoveryTasks_args :: T.ThriftVal -> DeleteRecoveryTasks_args
to_DeleteRecoveryTasks_args (T.TStruct fields) = DeleteRecoveryTasks_args{
  deleteRecoveryTasks_args_query = P.maybe (deleteRecoveryTasks_args_query default_DeleteRecoveryTasks_args) (\(_,_val1189) -> (case _val1189 of {T.TStruct _val1190 -> (to_TaskQuery (T.TStruct _val1190)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  deleteRecoveryTasks_args_session = P.maybe (deleteRecoveryTasks_args_session default_DeleteRecoveryTasks_args) (\(_,_val1189) -> (case _val1189 of {T.TStruct _val1191 -> (to_SessionKey (T.TStruct _val1191)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_DeleteRecoveryTasks_args _ = P.error "not a struct"
read_DeleteRecoveryTasks_args :: (T.Transport t, T.Protocol p) => p t -> P.IO DeleteRecoveryTasks_args
read_DeleteRecoveryTasks_args iprot = to_DeleteRecoveryTasks_args <$> T.readVal iprot (T.T_STRUCT typemap_DeleteRecoveryTasks_args)
decode_DeleteRecoveryTasks_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DeleteRecoveryTasks_args
decode_DeleteRecoveryTasks_args iprot bs = to_DeleteRecoveryTasks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteRecoveryTasks_args) bs
typemap_DeleteRecoveryTasks_args :: T.TypeMap
typemap_DeleteRecoveryTasks_args = Map.fromList [(1,("query",(T.T_STRUCT typemap_TaskQuery))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_DeleteRecoveryTasks_args :: DeleteRecoveryTasks_args
default_DeleteRecoveryTasks_args = DeleteRecoveryTasks_args{
  deleteRecoveryTasks_args_query = default_TaskQuery,
  deleteRecoveryTasks_args_session = default_SessionKey}
data DeleteRecoveryTasks_result = DeleteRecoveryTasks_result  { deleteRecoveryTasks_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DeleteRecoveryTasks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteRecoveryTasks_result_success record  
instance QC.Arbitrary DeleteRecoveryTasks_result where 
  arbitrary = M.liftM DeleteRecoveryTasks_result (QC.arbitrary)
  shrink obj | obj == default_DeleteRecoveryTasks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteRecoveryTasks_result{deleteRecoveryTasks_result_success = deleteRecoveryTasks_result_success obj} then P.Nothing else P.Just $ default_DeleteRecoveryTasks_result{deleteRecoveryTasks_result_success = deleteRecoveryTasks_result_success obj}
    ]
from_DeleteRecoveryTasks_result :: DeleteRecoveryTasks_result -> T.ThriftVal
from_DeleteRecoveryTasks_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1194 -> P.Just (0, ("success",from_Response _v1194))) $ deleteRecoveryTasks_result_success record
  ]
write_DeleteRecoveryTasks_result :: (T.Protocol p, T.Transport t) => p t -> DeleteRecoveryTasks_result -> P.IO ()
write_DeleteRecoveryTasks_result oprot record = T.writeVal oprot $ from_DeleteRecoveryTasks_result record
encode_DeleteRecoveryTasks_result :: (T.Protocol p, T.Transport t) => p t -> DeleteRecoveryTasks_result -> LBS.ByteString
encode_DeleteRecoveryTasks_result oprot record = T.serializeVal oprot $ from_DeleteRecoveryTasks_result record
to_DeleteRecoveryTasks_result :: T.ThriftVal -> DeleteRecoveryTasks_result
to_DeleteRecoveryTasks_result (T.TStruct fields) = DeleteRecoveryTasks_result{
  deleteRecoveryTasks_result_success = P.maybe (deleteRecoveryTasks_result_success default_DeleteRecoveryTasks_result) (\(_,_val1196) -> (case _val1196 of {T.TStruct _val1197 -> (to_Response (T.TStruct _val1197)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_DeleteRecoveryTasks_result _ = P.error "not a struct"
read_DeleteRecoveryTasks_result :: (T.Transport t, T.Protocol p) => p t -> P.IO DeleteRecoveryTasks_result
read_DeleteRecoveryTasks_result iprot = to_DeleteRecoveryTasks_result <$> T.readVal iprot (T.T_STRUCT typemap_DeleteRecoveryTasks_result)
decode_DeleteRecoveryTasks_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DeleteRecoveryTasks_result
decode_DeleteRecoveryTasks_result iprot bs = to_DeleteRecoveryTasks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteRecoveryTasks_result) bs
typemap_DeleteRecoveryTasks_result :: T.TypeMap
typemap_DeleteRecoveryTasks_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_DeleteRecoveryTasks_result :: DeleteRecoveryTasks_result
default_DeleteRecoveryTasks_result = DeleteRecoveryTasks_result{
  deleteRecoveryTasks_result_success = default_Response}
data CommitRecovery_args = CommitRecovery_args  { commitRecovery_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable CommitRecovery_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitRecovery_args_session record  
instance QC.Arbitrary CommitRecovery_args where 
  arbitrary = M.liftM CommitRecovery_args (QC.arbitrary)
  shrink obj | obj == default_CommitRecovery_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitRecovery_args{commitRecovery_args_session = commitRecovery_args_session obj} then P.Nothing else P.Just $ default_CommitRecovery_args{commitRecovery_args_session = commitRecovery_args_session obj}
    ]
from_CommitRecovery_args :: CommitRecovery_args -> T.ThriftVal
from_CommitRecovery_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1200 -> P.Just (1, ("session",from_SessionKey _v1200))) $ commitRecovery_args_session record
  ]
write_CommitRecovery_args :: (T.Protocol p, T.Transport t) => p t -> CommitRecovery_args -> P.IO ()
write_CommitRecovery_args oprot record = T.writeVal oprot $ from_CommitRecovery_args record
encode_CommitRecovery_args :: (T.Protocol p, T.Transport t) => p t -> CommitRecovery_args -> LBS.ByteString
encode_CommitRecovery_args oprot record = T.serializeVal oprot $ from_CommitRecovery_args record
to_CommitRecovery_args :: T.ThriftVal -> CommitRecovery_args
to_CommitRecovery_args (T.TStruct fields) = CommitRecovery_args{
  commitRecovery_args_session = P.maybe (commitRecovery_args_session default_CommitRecovery_args) (\(_,_val1202) -> (case _val1202 of {T.TStruct _val1203 -> (to_SessionKey (T.TStruct _val1203)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitRecovery_args _ = P.error "not a struct"
read_CommitRecovery_args :: (T.Transport t, T.Protocol p) => p t -> P.IO CommitRecovery_args
read_CommitRecovery_args iprot = to_CommitRecovery_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitRecovery_args)
decode_CommitRecovery_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CommitRecovery_args
decode_CommitRecovery_args iprot bs = to_CommitRecovery_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitRecovery_args) bs
typemap_CommitRecovery_args :: T.TypeMap
typemap_CommitRecovery_args = Map.fromList [(1,("session",(T.T_STRUCT typemap_SessionKey)))]
default_CommitRecovery_args :: CommitRecovery_args
default_CommitRecovery_args = CommitRecovery_args{
  commitRecovery_args_session = default_SessionKey}
data CommitRecovery_result = CommitRecovery_result  { commitRecovery_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable CommitRecovery_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitRecovery_result_success record  
instance QC.Arbitrary CommitRecovery_result where 
  arbitrary = M.liftM CommitRecovery_result (QC.arbitrary)
  shrink obj | obj == default_CommitRecovery_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitRecovery_result{commitRecovery_result_success = commitRecovery_result_success obj} then P.Nothing else P.Just $ default_CommitRecovery_result{commitRecovery_result_success = commitRecovery_result_success obj}
    ]
from_CommitRecovery_result :: CommitRecovery_result -> T.ThriftVal
from_CommitRecovery_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1206 -> P.Just (0, ("success",from_Response _v1206))) $ commitRecovery_result_success record
  ]
write_CommitRecovery_result :: (T.Protocol p, T.Transport t) => p t -> CommitRecovery_result -> P.IO ()
write_CommitRecovery_result oprot record = T.writeVal oprot $ from_CommitRecovery_result record
encode_CommitRecovery_result :: (T.Protocol p, T.Transport t) => p t -> CommitRecovery_result -> LBS.ByteString
encode_CommitRecovery_result oprot record = T.serializeVal oprot $ from_CommitRecovery_result record
to_CommitRecovery_result :: T.ThriftVal -> CommitRecovery_result
to_CommitRecovery_result (T.TStruct fields) = CommitRecovery_result{
  commitRecovery_result_success = P.maybe (commitRecovery_result_success default_CommitRecovery_result) (\(_,_val1208) -> (case _val1208 of {T.TStruct _val1209 -> (to_Response (T.TStruct _val1209)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_CommitRecovery_result _ = P.error "not a struct"
read_CommitRecovery_result :: (T.Transport t, T.Protocol p) => p t -> P.IO CommitRecovery_result
read_CommitRecovery_result iprot = to_CommitRecovery_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitRecovery_result)
decode_CommitRecovery_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CommitRecovery_result
decode_CommitRecovery_result iprot bs = to_CommitRecovery_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitRecovery_result) bs
typemap_CommitRecovery_result :: T.TypeMap
typemap_CommitRecovery_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_CommitRecovery_result :: CommitRecovery_result
default_CommitRecovery_result = CommitRecovery_result{
  commitRecovery_result_success = default_Response}
data UnloadRecovery_args = UnloadRecovery_args  { unloadRecovery_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable UnloadRecovery_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unloadRecovery_args_session record  
instance QC.Arbitrary UnloadRecovery_args where 
  arbitrary = M.liftM UnloadRecovery_args (QC.arbitrary)
  shrink obj | obj == default_UnloadRecovery_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnloadRecovery_args{unloadRecovery_args_session = unloadRecovery_args_session obj} then P.Nothing else P.Just $ default_UnloadRecovery_args{unloadRecovery_args_session = unloadRecovery_args_session obj}
    ]
from_UnloadRecovery_args :: UnloadRecovery_args -> T.ThriftVal
from_UnloadRecovery_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1212 -> P.Just (1, ("session",from_SessionKey _v1212))) $ unloadRecovery_args_session record
  ]
write_UnloadRecovery_args :: (T.Protocol p, T.Transport t) => p t -> UnloadRecovery_args -> P.IO ()
write_UnloadRecovery_args oprot record = T.writeVal oprot $ from_UnloadRecovery_args record
encode_UnloadRecovery_args :: (T.Protocol p, T.Transport t) => p t -> UnloadRecovery_args -> LBS.ByteString
encode_UnloadRecovery_args oprot record = T.serializeVal oprot $ from_UnloadRecovery_args record
to_UnloadRecovery_args :: T.ThriftVal -> UnloadRecovery_args
to_UnloadRecovery_args (T.TStruct fields) = UnloadRecovery_args{
  unloadRecovery_args_session = P.maybe (unloadRecovery_args_session default_UnloadRecovery_args) (\(_,_val1214) -> (case _val1214 of {T.TStruct _val1215 -> (to_SessionKey (T.TStruct _val1215)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnloadRecovery_args _ = P.error "not a struct"
read_UnloadRecovery_args :: (T.Transport t, T.Protocol p) => p t -> P.IO UnloadRecovery_args
read_UnloadRecovery_args iprot = to_UnloadRecovery_args <$> T.readVal iprot (T.T_STRUCT typemap_UnloadRecovery_args)
decode_UnloadRecovery_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UnloadRecovery_args
decode_UnloadRecovery_args iprot bs = to_UnloadRecovery_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnloadRecovery_args) bs
typemap_UnloadRecovery_args :: T.TypeMap
typemap_UnloadRecovery_args = Map.fromList [(1,("session",(T.T_STRUCT typemap_SessionKey)))]
default_UnloadRecovery_args :: UnloadRecovery_args
default_UnloadRecovery_args = UnloadRecovery_args{
  unloadRecovery_args_session = default_SessionKey}
data UnloadRecovery_result = UnloadRecovery_result  { unloadRecovery_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable UnloadRecovery_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unloadRecovery_result_success record  
instance QC.Arbitrary UnloadRecovery_result where 
  arbitrary = M.liftM UnloadRecovery_result (QC.arbitrary)
  shrink obj | obj == default_UnloadRecovery_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnloadRecovery_result{unloadRecovery_result_success = unloadRecovery_result_success obj} then P.Nothing else P.Just $ default_UnloadRecovery_result{unloadRecovery_result_success = unloadRecovery_result_success obj}
    ]
from_UnloadRecovery_result :: UnloadRecovery_result -> T.ThriftVal
from_UnloadRecovery_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1218 -> P.Just (0, ("success",from_Response _v1218))) $ unloadRecovery_result_success record
  ]
write_UnloadRecovery_result :: (T.Protocol p, T.Transport t) => p t -> UnloadRecovery_result -> P.IO ()
write_UnloadRecovery_result oprot record = T.writeVal oprot $ from_UnloadRecovery_result record
encode_UnloadRecovery_result :: (T.Protocol p, T.Transport t) => p t -> UnloadRecovery_result -> LBS.ByteString
encode_UnloadRecovery_result oprot record = T.serializeVal oprot $ from_UnloadRecovery_result record
to_UnloadRecovery_result :: T.ThriftVal -> UnloadRecovery_result
to_UnloadRecovery_result (T.TStruct fields) = UnloadRecovery_result{
  unloadRecovery_result_success = P.maybe (unloadRecovery_result_success default_UnloadRecovery_result) (\(_,_val1220) -> (case _val1220 of {T.TStruct _val1221 -> (to_Response (T.TStruct _val1221)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_UnloadRecovery_result _ = P.error "not a struct"
read_UnloadRecovery_result :: (T.Transport t, T.Protocol p) => p t -> P.IO UnloadRecovery_result
read_UnloadRecovery_result iprot = to_UnloadRecovery_result <$> T.readVal iprot (T.T_STRUCT typemap_UnloadRecovery_result)
decode_UnloadRecovery_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UnloadRecovery_result
decode_UnloadRecovery_result iprot bs = to_UnloadRecovery_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnloadRecovery_result) bs
typemap_UnloadRecovery_result :: T.TypeMap
typemap_UnloadRecovery_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_UnloadRecovery_result :: UnloadRecovery_result
default_UnloadRecovery_result = UnloadRecovery_result{
  unloadRecovery_result_success = default_Response}
data StartMaintenance_args = StartMaintenance_args  { startMaintenance_args_hosts :: Hosts
  , startMaintenance_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartMaintenance_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startMaintenance_args_hosts record   `H.hashWithSalt` startMaintenance_args_session record  
instance QC.Arbitrary StartMaintenance_args where 
  arbitrary = M.liftM StartMaintenance_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartMaintenance_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartMaintenance_args{startMaintenance_args_hosts = startMaintenance_args_hosts obj} then P.Nothing else P.Just $ default_StartMaintenance_args{startMaintenance_args_hosts = startMaintenance_args_hosts obj}
    , if obj == default_StartMaintenance_args{startMaintenance_args_session = startMaintenance_args_session obj} then P.Nothing else P.Just $ default_StartMaintenance_args{startMaintenance_args_session = startMaintenance_args_session obj}
    ]
from_StartMaintenance_args :: StartMaintenance_args -> T.ThriftVal
from_StartMaintenance_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1224 -> P.Just (1, ("hosts",from_Hosts _v1224))) $ startMaintenance_args_hosts record
  , (\_v1224 -> P.Just (2, ("session",from_SessionKey _v1224))) $ startMaintenance_args_session record
  ]
write_StartMaintenance_args :: (T.Protocol p, T.Transport t) => p t -> StartMaintenance_args -> P.IO ()
write_StartMaintenance_args oprot record = T.writeVal oprot $ from_StartMaintenance_args record
encode_StartMaintenance_args :: (T.Protocol p, T.Transport t) => p t -> StartMaintenance_args -> LBS.ByteString
encode_StartMaintenance_args oprot record = T.serializeVal oprot $ from_StartMaintenance_args record
to_StartMaintenance_args :: T.ThriftVal -> StartMaintenance_args
to_StartMaintenance_args (T.TStruct fields) = StartMaintenance_args{
  startMaintenance_args_hosts = P.maybe (startMaintenance_args_hosts default_StartMaintenance_args) (\(_,_val1226) -> (case _val1226 of {T.TStruct _val1227 -> (to_Hosts (T.TStruct _val1227)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  startMaintenance_args_session = P.maybe (startMaintenance_args_session default_StartMaintenance_args) (\(_,_val1226) -> (case _val1226 of {T.TStruct _val1228 -> (to_SessionKey (T.TStruct _val1228)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StartMaintenance_args _ = P.error "not a struct"
read_StartMaintenance_args :: (T.Transport t, T.Protocol p) => p t -> P.IO StartMaintenance_args
read_StartMaintenance_args iprot = to_StartMaintenance_args <$> T.readVal iprot (T.T_STRUCT typemap_StartMaintenance_args)
decode_StartMaintenance_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartMaintenance_args
decode_StartMaintenance_args iprot bs = to_StartMaintenance_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartMaintenance_args) bs
typemap_StartMaintenance_args :: T.TypeMap
typemap_StartMaintenance_args = Map.fromList [(1,("hosts",(T.T_STRUCT typemap_Hosts))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_StartMaintenance_args :: StartMaintenance_args
default_StartMaintenance_args = StartMaintenance_args{
  startMaintenance_args_hosts = default_Hosts,
  startMaintenance_args_session = default_SessionKey}
data StartMaintenance_result = StartMaintenance_result  { startMaintenance_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StartMaintenance_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startMaintenance_result_success record  
instance QC.Arbitrary StartMaintenance_result where 
  arbitrary = M.liftM StartMaintenance_result (QC.arbitrary)
  shrink obj | obj == default_StartMaintenance_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartMaintenance_result{startMaintenance_result_success = startMaintenance_result_success obj} then P.Nothing else P.Just $ default_StartMaintenance_result{startMaintenance_result_success = startMaintenance_result_success obj}
    ]
from_StartMaintenance_result :: StartMaintenance_result -> T.ThriftVal
from_StartMaintenance_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1231 -> P.Just (0, ("success",from_Response _v1231))) $ startMaintenance_result_success record
  ]
write_StartMaintenance_result :: (T.Protocol p, T.Transport t) => p t -> StartMaintenance_result -> P.IO ()
write_StartMaintenance_result oprot record = T.writeVal oprot $ from_StartMaintenance_result record
encode_StartMaintenance_result :: (T.Protocol p, T.Transport t) => p t -> StartMaintenance_result -> LBS.ByteString
encode_StartMaintenance_result oprot record = T.serializeVal oprot $ from_StartMaintenance_result record
to_StartMaintenance_result :: T.ThriftVal -> StartMaintenance_result
to_StartMaintenance_result (T.TStruct fields) = StartMaintenance_result{
  startMaintenance_result_success = P.maybe (startMaintenance_result_success default_StartMaintenance_result) (\(_,_val1233) -> (case _val1233 of {T.TStruct _val1234 -> (to_Response (T.TStruct _val1234)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_StartMaintenance_result _ = P.error "not a struct"
read_StartMaintenance_result :: (T.Transport t, T.Protocol p) => p t -> P.IO StartMaintenance_result
read_StartMaintenance_result iprot = to_StartMaintenance_result <$> T.readVal iprot (T.T_STRUCT typemap_StartMaintenance_result)
decode_StartMaintenance_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartMaintenance_result
decode_StartMaintenance_result iprot bs = to_StartMaintenance_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartMaintenance_result) bs
typemap_StartMaintenance_result :: T.TypeMap
typemap_StartMaintenance_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_StartMaintenance_result :: StartMaintenance_result
default_StartMaintenance_result = StartMaintenance_result{
  startMaintenance_result_success = default_Response}
data DrainHosts_args = DrainHosts_args  { drainHosts_args_hosts :: Hosts
  , drainHosts_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DrainHosts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` drainHosts_args_hosts record   `H.hashWithSalt` drainHosts_args_session record  
instance QC.Arbitrary DrainHosts_args where 
  arbitrary = M.liftM DrainHosts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DrainHosts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DrainHosts_args{drainHosts_args_hosts = drainHosts_args_hosts obj} then P.Nothing else P.Just $ default_DrainHosts_args{drainHosts_args_hosts = drainHosts_args_hosts obj}
    , if obj == default_DrainHosts_args{drainHosts_args_session = drainHosts_args_session obj} then P.Nothing else P.Just $ default_DrainHosts_args{drainHosts_args_session = drainHosts_args_session obj}
    ]
from_DrainHosts_args :: DrainHosts_args -> T.ThriftVal
from_DrainHosts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1237 -> P.Just (1, ("hosts",from_Hosts _v1237))) $ drainHosts_args_hosts record
  , (\_v1237 -> P.Just (2, ("session",from_SessionKey _v1237))) $ drainHosts_args_session record
  ]
write_DrainHosts_args :: (T.Protocol p, T.Transport t) => p t -> DrainHosts_args -> P.IO ()
write_DrainHosts_args oprot record = T.writeVal oprot $ from_DrainHosts_args record
encode_DrainHosts_args :: (T.Protocol p, T.Transport t) => p t -> DrainHosts_args -> LBS.ByteString
encode_DrainHosts_args oprot record = T.serializeVal oprot $ from_DrainHosts_args record
to_DrainHosts_args :: T.ThriftVal -> DrainHosts_args
to_DrainHosts_args (T.TStruct fields) = DrainHosts_args{
  drainHosts_args_hosts = P.maybe (drainHosts_args_hosts default_DrainHosts_args) (\(_,_val1239) -> (case _val1239 of {T.TStruct _val1240 -> (to_Hosts (T.TStruct _val1240)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  drainHosts_args_session = P.maybe (drainHosts_args_session default_DrainHosts_args) (\(_,_val1239) -> (case _val1239 of {T.TStruct _val1241 -> (to_SessionKey (T.TStruct _val1241)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_DrainHosts_args _ = P.error "not a struct"
read_DrainHosts_args :: (T.Transport t, T.Protocol p) => p t -> P.IO DrainHosts_args
read_DrainHosts_args iprot = to_DrainHosts_args <$> T.readVal iprot (T.T_STRUCT typemap_DrainHosts_args)
decode_DrainHosts_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DrainHosts_args
decode_DrainHosts_args iprot bs = to_DrainHosts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DrainHosts_args) bs
typemap_DrainHosts_args :: T.TypeMap
typemap_DrainHosts_args = Map.fromList [(1,("hosts",(T.T_STRUCT typemap_Hosts))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_DrainHosts_args :: DrainHosts_args
default_DrainHosts_args = DrainHosts_args{
  drainHosts_args_hosts = default_Hosts,
  drainHosts_args_session = default_SessionKey}
data DrainHosts_result = DrainHosts_result  { drainHosts_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DrainHosts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` drainHosts_result_success record  
instance QC.Arbitrary DrainHosts_result where 
  arbitrary = M.liftM DrainHosts_result (QC.arbitrary)
  shrink obj | obj == default_DrainHosts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DrainHosts_result{drainHosts_result_success = drainHosts_result_success obj} then P.Nothing else P.Just $ default_DrainHosts_result{drainHosts_result_success = drainHosts_result_success obj}
    ]
from_DrainHosts_result :: DrainHosts_result -> T.ThriftVal
from_DrainHosts_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1244 -> P.Just (0, ("success",from_Response _v1244))) $ drainHosts_result_success record
  ]
write_DrainHosts_result :: (T.Protocol p, T.Transport t) => p t -> DrainHosts_result -> P.IO ()
write_DrainHosts_result oprot record = T.writeVal oprot $ from_DrainHosts_result record
encode_DrainHosts_result :: (T.Protocol p, T.Transport t) => p t -> DrainHosts_result -> LBS.ByteString
encode_DrainHosts_result oprot record = T.serializeVal oprot $ from_DrainHosts_result record
to_DrainHosts_result :: T.ThriftVal -> DrainHosts_result
to_DrainHosts_result (T.TStruct fields) = DrainHosts_result{
  drainHosts_result_success = P.maybe (drainHosts_result_success default_DrainHosts_result) (\(_,_val1246) -> (case _val1246 of {T.TStruct _val1247 -> (to_Response (T.TStruct _val1247)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_DrainHosts_result _ = P.error "not a struct"
read_DrainHosts_result :: (T.Transport t, T.Protocol p) => p t -> P.IO DrainHosts_result
read_DrainHosts_result iprot = to_DrainHosts_result <$> T.readVal iprot (T.T_STRUCT typemap_DrainHosts_result)
decode_DrainHosts_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DrainHosts_result
decode_DrainHosts_result iprot bs = to_DrainHosts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DrainHosts_result) bs
typemap_DrainHosts_result :: T.TypeMap
typemap_DrainHosts_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_DrainHosts_result :: DrainHosts_result
default_DrainHosts_result = DrainHosts_result{
  drainHosts_result_success = default_Response}
data MaintenanceStatus_args = MaintenanceStatus_args  { maintenanceStatus_args_hosts :: Hosts
  , maintenanceStatus_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable MaintenanceStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` maintenanceStatus_args_hosts record   `H.hashWithSalt` maintenanceStatus_args_session record  
instance QC.Arbitrary MaintenanceStatus_args where 
  arbitrary = M.liftM MaintenanceStatus_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MaintenanceStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MaintenanceStatus_args{maintenanceStatus_args_hosts = maintenanceStatus_args_hosts obj} then P.Nothing else P.Just $ default_MaintenanceStatus_args{maintenanceStatus_args_hosts = maintenanceStatus_args_hosts obj}
    , if obj == default_MaintenanceStatus_args{maintenanceStatus_args_session = maintenanceStatus_args_session obj} then P.Nothing else P.Just $ default_MaintenanceStatus_args{maintenanceStatus_args_session = maintenanceStatus_args_session obj}
    ]
from_MaintenanceStatus_args :: MaintenanceStatus_args -> T.ThriftVal
from_MaintenanceStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1250 -> P.Just (1, ("hosts",from_Hosts _v1250))) $ maintenanceStatus_args_hosts record
  , (\_v1250 -> P.Just (2, ("session",from_SessionKey _v1250))) $ maintenanceStatus_args_session record
  ]
write_MaintenanceStatus_args :: (T.Protocol p, T.Transport t) => p t -> MaintenanceStatus_args -> P.IO ()
write_MaintenanceStatus_args oprot record = T.writeVal oprot $ from_MaintenanceStatus_args record
encode_MaintenanceStatus_args :: (T.Protocol p, T.Transport t) => p t -> MaintenanceStatus_args -> LBS.ByteString
encode_MaintenanceStatus_args oprot record = T.serializeVal oprot $ from_MaintenanceStatus_args record
to_MaintenanceStatus_args :: T.ThriftVal -> MaintenanceStatus_args
to_MaintenanceStatus_args (T.TStruct fields) = MaintenanceStatus_args{
  maintenanceStatus_args_hosts = P.maybe (maintenanceStatus_args_hosts default_MaintenanceStatus_args) (\(_,_val1252) -> (case _val1252 of {T.TStruct _val1253 -> (to_Hosts (T.TStruct _val1253)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  maintenanceStatus_args_session = P.maybe (maintenanceStatus_args_session default_MaintenanceStatus_args) (\(_,_val1252) -> (case _val1252 of {T.TStruct _val1254 -> (to_SessionKey (T.TStruct _val1254)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_MaintenanceStatus_args _ = P.error "not a struct"
read_MaintenanceStatus_args :: (T.Transport t, T.Protocol p) => p t -> P.IO MaintenanceStatus_args
read_MaintenanceStatus_args iprot = to_MaintenanceStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_MaintenanceStatus_args)
decode_MaintenanceStatus_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> MaintenanceStatus_args
decode_MaintenanceStatus_args iprot bs = to_MaintenanceStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_MaintenanceStatus_args) bs
typemap_MaintenanceStatus_args :: T.TypeMap
typemap_MaintenanceStatus_args = Map.fromList [(1,("hosts",(T.T_STRUCT typemap_Hosts))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_MaintenanceStatus_args :: MaintenanceStatus_args
default_MaintenanceStatus_args = MaintenanceStatus_args{
  maintenanceStatus_args_hosts = default_Hosts,
  maintenanceStatus_args_session = default_SessionKey}
data MaintenanceStatus_result = MaintenanceStatus_result  { maintenanceStatus_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable MaintenanceStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` maintenanceStatus_result_success record  
instance QC.Arbitrary MaintenanceStatus_result where 
  arbitrary = M.liftM MaintenanceStatus_result (QC.arbitrary)
  shrink obj | obj == default_MaintenanceStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MaintenanceStatus_result{maintenanceStatus_result_success = maintenanceStatus_result_success obj} then P.Nothing else P.Just $ default_MaintenanceStatus_result{maintenanceStatus_result_success = maintenanceStatus_result_success obj}
    ]
from_MaintenanceStatus_result :: MaintenanceStatus_result -> T.ThriftVal
from_MaintenanceStatus_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1257 -> P.Just (0, ("success",from_Response _v1257))) $ maintenanceStatus_result_success record
  ]
write_MaintenanceStatus_result :: (T.Protocol p, T.Transport t) => p t -> MaintenanceStatus_result -> P.IO ()
write_MaintenanceStatus_result oprot record = T.writeVal oprot $ from_MaintenanceStatus_result record
encode_MaintenanceStatus_result :: (T.Protocol p, T.Transport t) => p t -> MaintenanceStatus_result -> LBS.ByteString
encode_MaintenanceStatus_result oprot record = T.serializeVal oprot $ from_MaintenanceStatus_result record
to_MaintenanceStatus_result :: T.ThriftVal -> MaintenanceStatus_result
to_MaintenanceStatus_result (T.TStruct fields) = MaintenanceStatus_result{
  maintenanceStatus_result_success = P.maybe (maintenanceStatus_result_success default_MaintenanceStatus_result) (\(_,_val1259) -> (case _val1259 of {T.TStruct _val1260 -> (to_Response (T.TStruct _val1260)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_MaintenanceStatus_result _ = P.error "not a struct"
read_MaintenanceStatus_result :: (T.Transport t, T.Protocol p) => p t -> P.IO MaintenanceStatus_result
read_MaintenanceStatus_result iprot = to_MaintenanceStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_MaintenanceStatus_result)
decode_MaintenanceStatus_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> MaintenanceStatus_result
decode_MaintenanceStatus_result iprot bs = to_MaintenanceStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_MaintenanceStatus_result) bs
typemap_MaintenanceStatus_result :: T.TypeMap
typemap_MaintenanceStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_MaintenanceStatus_result :: MaintenanceStatus_result
default_MaintenanceStatus_result = MaintenanceStatus_result{
  maintenanceStatus_result_success = default_Response}
data EndMaintenance_args = EndMaintenance_args  { endMaintenance_args_hosts :: Hosts
  , endMaintenance_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable EndMaintenance_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` endMaintenance_args_hosts record   `H.hashWithSalt` endMaintenance_args_session record  
instance QC.Arbitrary EndMaintenance_args where 
  arbitrary = M.liftM EndMaintenance_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_EndMaintenance_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EndMaintenance_args{endMaintenance_args_hosts = endMaintenance_args_hosts obj} then P.Nothing else P.Just $ default_EndMaintenance_args{endMaintenance_args_hosts = endMaintenance_args_hosts obj}
    , if obj == default_EndMaintenance_args{endMaintenance_args_session = endMaintenance_args_session obj} then P.Nothing else P.Just $ default_EndMaintenance_args{endMaintenance_args_session = endMaintenance_args_session obj}
    ]
from_EndMaintenance_args :: EndMaintenance_args -> T.ThriftVal
from_EndMaintenance_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1263 -> P.Just (1, ("hosts",from_Hosts _v1263))) $ endMaintenance_args_hosts record
  , (\_v1263 -> P.Just (2, ("session",from_SessionKey _v1263))) $ endMaintenance_args_session record
  ]
write_EndMaintenance_args :: (T.Protocol p, T.Transport t) => p t -> EndMaintenance_args -> P.IO ()
write_EndMaintenance_args oprot record = T.writeVal oprot $ from_EndMaintenance_args record
encode_EndMaintenance_args :: (T.Protocol p, T.Transport t) => p t -> EndMaintenance_args -> LBS.ByteString
encode_EndMaintenance_args oprot record = T.serializeVal oprot $ from_EndMaintenance_args record
to_EndMaintenance_args :: T.ThriftVal -> EndMaintenance_args
to_EndMaintenance_args (T.TStruct fields) = EndMaintenance_args{
  endMaintenance_args_hosts = P.maybe (endMaintenance_args_hosts default_EndMaintenance_args) (\(_,_val1265) -> (case _val1265 of {T.TStruct _val1266 -> (to_Hosts (T.TStruct _val1266)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  endMaintenance_args_session = P.maybe (endMaintenance_args_session default_EndMaintenance_args) (\(_,_val1265) -> (case _val1265 of {T.TStruct _val1267 -> (to_SessionKey (T.TStruct _val1267)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_EndMaintenance_args _ = P.error "not a struct"
read_EndMaintenance_args :: (T.Transport t, T.Protocol p) => p t -> P.IO EndMaintenance_args
read_EndMaintenance_args iprot = to_EndMaintenance_args <$> T.readVal iprot (T.T_STRUCT typemap_EndMaintenance_args)
decode_EndMaintenance_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EndMaintenance_args
decode_EndMaintenance_args iprot bs = to_EndMaintenance_args $ T.deserializeVal iprot (T.T_STRUCT typemap_EndMaintenance_args) bs
typemap_EndMaintenance_args :: T.TypeMap
typemap_EndMaintenance_args = Map.fromList [(1,("hosts",(T.T_STRUCT typemap_Hosts))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_EndMaintenance_args :: EndMaintenance_args
default_EndMaintenance_args = EndMaintenance_args{
  endMaintenance_args_hosts = default_Hosts,
  endMaintenance_args_session = default_SessionKey}
data EndMaintenance_result = EndMaintenance_result  { endMaintenance_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable EndMaintenance_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` endMaintenance_result_success record  
instance QC.Arbitrary EndMaintenance_result where 
  arbitrary = M.liftM EndMaintenance_result (QC.arbitrary)
  shrink obj | obj == default_EndMaintenance_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EndMaintenance_result{endMaintenance_result_success = endMaintenance_result_success obj} then P.Nothing else P.Just $ default_EndMaintenance_result{endMaintenance_result_success = endMaintenance_result_success obj}
    ]
from_EndMaintenance_result :: EndMaintenance_result -> T.ThriftVal
from_EndMaintenance_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1270 -> P.Just (0, ("success",from_Response _v1270))) $ endMaintenance_result_success record
  ]
write_EndMaintenance_result :: (T.Protocol p, T.Transport t) => p t -> EndMaintenance_result -> P.IO ()
write_EndMaintenance_result oprot record = T.writeVal oprot $ from_EndMaintenance_result record
encode_EndMaintenance_result :: (T.Protocol p, T.Transport t) => p t -> EndMaintenance_result -> LBS.ByteString
encode_EndMaintenance_result oprot record = T.serializeVal oprot $ from_EndMaintenance_result record
to_EndMaintenance_result :: T.ThriftVal -> EndMaintenance_result
to_EndMaintenance_result (T.TStruct fields) = EndMaintenance_result{
  endMaintenance_result_success = P.maybe (endMaintenance_result_success default_EndMaintenance_result) (\(_,_val1272) -> (case _val1272 of {T.TStruct _val1273 -> (to_Response (T.TStruct _val1273)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_EndMaintenance_result _ = P.error "not a struct"
read_EndMaintenance_result :: (T.Transport t, T.Protocol p) => p t -> P.IO EndMaintenance_result
read_EndMaintenance_result iprot = to_EndMaintenance_result <$> T.readVal iprot (T.T_STRUCT typemap_EndMaintenance_result)
decode_EndMaintenance_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EndMaintenance_result
decode_EndMaintenance_result iprot bs = to_EndMaintenance_result $ T.deserializeVal iprot (T.T_STRUCT typemap_EndMaintenance_result) bs
typemap_EndMaintenance_result :: T.TypeMap
typemap_EndMaintenance_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_EndMaintenance_result :: EndMaintenance_result
default_EndMaintenance_result = EndMaintenance_result{
  endMaintenance_result_success = default_Response}
data Snapshot_args = Snapshot_args  { snapshot_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Snapshot_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` snapshot_args_session record  
instance QC.Arbitrary Snapshot_args where 
  arbitrary = M.liftM Snapshot_args (QC.arbitrary)
  shrink obj | obj == default_Snapshot_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Snapshot_args{snapshot_args_session = snapshot_args_session obj} then P.Nothing else P.Just $ default_Snapshot_args{snapshot_args_session = snapshot_args_session obj}
    ]
from_Snapshot_args :: Snapshot_args -> T.ThriftVal
from_Snapshot_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1276 -> P.Just (1, ("session",from_SessionKey _v1276))) $ snapshot_args_session record
  ]
write_Snapshot_args :: (T.Protocol p, T.Transport t) => p t -> Snapshot_args -> P.IO ()
write_Snapshot_args oprot record = T.writeVal oprot $ from_Snapshot_args record
encode_Snapshot_args :: (T.Protocol p, T.Transport t) => p t -> Snapshot_args -> LBS.ByteString
encode_Snapshot_args oprot record = T.serializeVal oprot $ from_Snapshot_args record
to_Snapshot_args :: T.ThriftVal -> Snapshot_args
to_Snapshot_args (T.TStruct fields) = Snapshot_args{
  snapshot_args_session = P.maybe (snapshot_args_session default_Snapshot_args) (\(_,_val1278) -> (case _val1278 of {T.TStruct _val1279 -> (to_SessionKey (T.TStruct _val1279)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Snapshot_args _ = P.error "not a struct"
read_Snapshot_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Snapshot_args
read_Snapshot_args iprot = to_Snapshot_args <$> T.readVal iprot (T.T_STRUCT typemap_Snapshot_args)
decode_Snapshot_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Snapshot_args
decode_Snapshot_args iprot bs = to_Snapshot_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Snapshot_args) bs
typemap_Snapshot_args :: T.TypeMap
typemap_Snapshot_args = Map.fromList [(1,("session",(T.T_STRUCT typemap_SessionKey)))]
default_Snapshot_args :: Snapshot_args
default_Snapshot_args = Snapshot_args{
  snapshot_args_session = default_SessionKey}
data Snapshot_result = Snapshot_result  { snapshot_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Snapshot_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` snapshot_result_success record  
instance QC.Arbitrary Snapshot_result where 
  arbitrary = M.liftM Snapshot_result (QC.arbitrary)
  shrink obj | obj == default_Snapshot_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Snapshot_result{snapshot_result_success = snapshot_result_success obj} then P.Nothing else P.Just $ default_Snapshot_result{snapshot_result_success = snapshot_result_success obj}
    ]
from_Snapshot_result :: Snapshot_result -> T.ThriftVal
from_Snapshot_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1282 -> P.Just (0, ("success",from_Response _v1282))) $ snapshot_result_success record
  ]
write_Snapshot_result :: (T.Protocol p, T.Transport t) => p t -> Snapshot_result -> P.IO ()
write_Snapshot_result oprot record = T.writeVal oprot $ from_Snapshot_result record
encode_Snapshot_result :: (T.Protocol p, T.Transport t) => p t -> Snapshot_result -> LBS.ByteString
encode_Snapshot_result oprot record = T.serializeVal oprot $ from_Snapshot_result record
to_Snapshot_result :: T.ThriftVal -> Snapshot_result
to_Snapshot_result (T.TStruct fields) = Snapshot_result{
  snapshot_result_success = P.maybe (snapshot_result_success default_Snapshot_result) (\(_,_val1284) -> (case _val1284 of {T.TStruct _val1285 -> (to_Response (T.TStruct _val1285)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_Snapshot_result _ = P.error "not a struct"
read_Snapshot_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Snapshot_result
read_Snapshot_result iprot = to_Snapshot_result <$> T.readVal iprot (T.T_STRUCT typemap_Snapshot_result)
decode_Snapshot_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Snapshot_result
decode_Snapshot_result iprot bs = to_Snapshot_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Snapshot_result) bs
typemap_Snapshot_result :: T.TypeMap
typemap_Snapshot_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_Snapshot_result :: Snapshot_result
default_Snapshot_result = Snapshot_result{
  snapshot_result_success = default_Response}
data RewriteConfigs_args = RewriteConfigs_args  { rewriteConfigs_args_request :: RewriteConfigsRequest
  , rewriteConfigs_args_session :: SessionKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RewriteConfigs_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` rewriteConfigs_args_request record   `H.hashWithSalt` rewriteConfigs_args_session record  
instance QC.Arbitrary RewriteConfigs_args where 
  arbitrary = M.liftM RewriteConfigs_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RewriteConfigs_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RewriteConfigs_args{rewriteConfigs_args_request = rewriteConfigs_args_request obj} then P.Nothing else P.Just $ default_RewriteConfigs_args{rewriteConfigs_args_request = rewriteConfigs_args_request obj}
    , if obj == default_RewriteConfigs_args{rewriteConfigs_args_session = rewriteConfigs_args_session obj} then P.Nothing else P.Just $ default_RewriteConfigs_args{rewriteConfigs_args_session = rewriteConfigs_args_session obj}
    ]
from_RewriteConfigs_args :: RewriteConfigs_args -> T.ThriftVal
from_RewriteConfigs_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1288 -> P.Just (1, ("request",from_RewriteConfigsRequest _v1288))) $ rewriteConfigs_args_request record
  , (\_v1288 -> P.Just (2, ("session",from_SessionKey _v1288))) $ rewriteConfigs_args_session record
  ]
write_RewriteConfigs_args :: (T.Protocol p, T.Transport t) => p t -> RewriteConfigs_args -> P.IO ()
write_RewriteConfigs_args oprot record = T.writeVal oprot $ from_RewriteConfigs_args record
encode_RewriteConfigs_args :: (T.Protocol p, T.Transport t) => p t -> RewriteConfigs_args -> LBS.ByteString
encode_RewriteConfigs_args oprot record = T.serializeVal oprot $ from_RewriteConfigs_args record
to_RewriteConfigs_args :: T.ThriftVal -> RewriteConfigs_args
to_RewriteConfigs_args (T.TStruct fields) = RewriteConfigs_args{
  rewriteConfigs_args_request = P.maybe (rewriteConfigs_args_request default_RewriteConfigs_args) (\(_,_val1290) -> (case _val1290 of {T.TStruct _val1291 -> (to_RewriteConfigsRequest (T.TStruct _val1291)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rewriteConfigs_args_session = P.maybe (rewriteConfigs_args_session default_RewriteConfigs_args) (\(_,_val1290) -> (case _val1290 of {T.TStruct _val1292 -> (to_SessionKey (T.TStruct _val1292)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RewriteConfigs_args _ = P.error "not a struct"
read_RewriteConfigs_args :: (T.Transport t, T.Protocol p) => p t -> P.IO RewriteConfigs_args
read_RewriteConfigs_args iprot = to_RewriteConfigs_args <$> T.readVal iprot (T.T_STRUCT typemap_RewriteConfigs_args)
decode_RewriteConfigs_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RewriteConfigs_args
decode_RewriteConfigs_args iprot bs = to_RewriteConfigs_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RewriteConfigs_args) bs
typemap_RewriteConfigs_args :: T.TypeMap
typemap_RewriteConfigs_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_RewriteConfigsRequest))),(2,("session",(T.T_STRUCT typemap_SessionKey)))]
default_RewriteConfigs_args :: RewriteConfigs_args
default_RewriteConfigs_args = RewriteConfigs_args{
  rewriteConfigs_args_request = default_RewriteConfigsRequest,
  rewriteConfigs_args_session = default_SessionKey}
data RewriteConfigs_result = RewriteConfigs_result  { rewriteConfigs_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RewriteConfigs_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` rewriteConfigs_result_success record  
instance QC.Arbitrary RewriteConfigs_result where 
  arbitrary = M.liftM RewriteConfigs_result (QC.arbitrary)
  shrink obj | obj == default_RewriteConfigs_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RewriteConfigs_result{rewriteConfigs_result_success = rewriteConfigs_result_success obj} then P.Nothing else P.Just $ default_RewriteConfigs_result{rewriteConfigs_result_success = rewriteConfigs_result_success obj}
    ]
from_RewriteConfigs_result :: RewriteConfigs_result -> T.ThriftVal
from_RewriteConfigs_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1295 -> P.Just (0, ("success",from_Response _v1295))) $ rewriteConfigs_result_success record
  ]
write_RewriteConfigs_result :: (T.Protocol p, T.Transport t) => p t -> RewriteConfigs_result -> P.IO ()
write_RewriteConfigs_result oprot record = T.writeVal oprot $ from_RewriteConfigs_result record
encode_RewriteConfigs_result :: (T.Protocol p, T.Transport t) => p t -> RewriteConfigs_result -> LBS.ByteString
encode_RewriteConfigs_result oprot record = T.serializeVal oprot $ from_RewriteConfigs_result record
to_RewriteConfigs_result :: T.ThriftVal -> RewriteConfigs_result
to_RewriteConfigs_result (T.TStruct fields) = RewriteConfigs_result{
  rewriteConfigs_result_success = P.maybe (rewriteConfigs_result_success default_RewriteConfigs_result) (\(_,_val1297) -> (case _val1297 of {T.TStruct _val1298 -> (to_Response (T.TStruct _val1298)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_RewriteConfigs_result _ = P.error "not a struct"
read_RewriteConfigs_result :: (T.Transport t, T.Protocol p) => p t -> P.IO RewriteConfigs_result
read_RewriteConfigs_result iprot = to_RewriteConfigs_result <$> T.readVal iprot (T.T_STRUCT typemap_RewriteConfigs_result)
decode_RewriteConfigs_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RewriteConfigs_result
decode_RewriteConfigs_result iprot bs = to_RewriteConfigs_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RewriteConfigs_result) bs
typemap_RewriteConfigs_result :: T.TypeMap
typemap_RewriteConfigs_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_RewriteConfigs_result :: RewriteConfigs_result
default_RewriteConfigs_result = RewriteConfigs_result{
  rewriteConfigs_result_success = default_Response}
process_setQuota (seqid, iprot, oprot, handler) = do
  args <- read_SetQuota_args iprot
  (X.catch
    (do
      val <- Iface.setQuota handler (setQuota_args_ownerRole args) (setQuota_args_quota args) (setQuota_args_session args)
      let res = default_SetQuota_result{setQuota_result_success = val}
      T.writeMessageBegin oprot ("setQuota", T.M_REPLY, seqid)
      write_SetQuota_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("setQuota", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_forceTaskState (seqid, iprot, oprot, handler) = do
  args <- read_ForceTaskState_args iprot
  (X.catch
    (do
      val <- Iface.forceTaskState handler (forceTaskState_args_taskId args) (forceTaskState_args_status args) (forceTaskState_args_session args)
      let res = default_ForceTaskState_result{forceTaskState_result_success = val}
      T.writeMessageBegin oprot ("forceTaskState", T.M_REPLY, seqid)
      write_ForceTaskState_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("forceTaskState", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_performBackup (seqid, iprot, oprot, handler) = do
  args <- read_PerformBackup_args iprot
  (X.catch
    (do
      val <- Iface.performBackup handler (performBackup_args_session args)
      let res = default_PerformBackup_result{performBackup_result_success = val}
      T.writeMessageBegin oprot ("performBackup", T.M_REPLY, seqid)
      write_PerformBackup_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("performBackup", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_listBackups (seqid, iprot, oprot, handler) = do
  args <- read_ListBackups_args iprot
  (X.catch
    (do
      val <- Iface.listBackups handler (listBackups_args_session args)
      let res = default_ListBackups_result{listBackups_result_success = val}
      T.writeMessageBegin oprot ("listBackups", T.M_REPLY, seqid)
      write_ListBackups_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("listBackups", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_stageRecovery (seqid, iprot, oprot, handler) = do
  args <- read_StageRecovery_args iprot
  (X.catch
    (do
      val <- Iface.stageRecovery handler (stageRecovery_args_backupId args) (stageRecovery_args_session args)
      let res = default_StageRecovery_result{stageRecovery_result_success = val}
      T.writeMessageBegin oprot ("stageRecovery", T.M_REPLY, seqid)
      write_StageRecovery_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("stageRecovery", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_queryRecovery (seqid, iprot, oprot, handler) = do
  args <- read_QueryRecovery_args iprot
  (X.catch
    (do
      val <- Iface.queryRecovery handler (queryRecovery_args_query args) (queryRecovery_args_session args)
      let res = default_QueryRecovery_result{queryRecovery_result_success = val}
      T.writeMessageBegin oprot ("queryRecovery", T.M_REPLY, seqid)
      write_QueryRecovery_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("queryRecovery", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_deleteRecoveryTasks (seqid, iprot, oprot, handler) = do
  args <- read_DeleteRecoveryTasks_args iprot
  (X.catch
    (do
      val <- Iface.deleteRecoveryTasks handler (deleteRecoveryTasks_args_query args) (deleteRecoveryTasks_args_session args)
      let res = default_DeleteRecoveryTasks_result{deleteRecoveryTasks_result_success = val}
      T.writeMessageBegin oprot ("deleteRecoveryTasks", T.M_REPLY, seqid)
      write_DeleteRecoveryTasks_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("deleteRecoveryTasks", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_commitRecovery (seqid, iprot, oprot, handler) = do
  args <- read_CommitRecovery_args iprot
  (X.catch
    (do
      val <- Iface.commitRecovery handler (commitRecovery_args_session args)
      let res = default_CommitRecovery_result{commitRecovery_result_success = val}
      T.writeMessageBegin oprot ("commitRecovery", T.M_REPLY, seqid)
      write_CommitRecovery_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("commitRecovery", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_unloadRecovery (seqid, iprot, oprot, handler) = do
  args <- read_UnloadRecovery_args iprot
  (X.catch
    (do
      val <- Iface.unloadRecovery handler (unloadRecovery_args_session args)
      let res = default_UnloadRecovery_result{unloadRecovery_result_success = val}
      T.writeMessageBegin oprot ("unloadRecovery", T.M_REPLY, seqid)
      write_UnloadRecovery_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("unloadRecovery", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_startMaintenance (seqid, iprot, oprot, handler) = do
  args <- read_StartMaintenance_args iprot
  (X.catch
    (do
      val <- Iface.startMaintenance handler (startMaintenance_args_hosts args) (startMaintenance_args_session args)
      let res = default_StartMaintenance_result{startMaintenance_result_success = val}
      T.writeMessageBegin oprot ("startMaintenance", T.M_REPLY, seqid)
      write_StartMaintenance_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("startMaintenance", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_drainHosts (seqid, iprot, oprot, handler) = do
  args <- read_DrainHosts_args iprot
  (X.catch
    (do
      val <- Iface.drainHosts handler (drainHosts_args_hosts args) (drainHosts_args_session args)
      let res = default_DrainHosts_result{drainHosts_result_success = val}
      T.writeMessageBegin oprot ("drainHosts", T.M_REPLY, seqid)
      write_DrainHosts_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("drainHosts", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_maintenanceStatus (seqid, iprot, oprot, handler) = do
  args <- read_MaintenanceStatus_args iprot
  (X.catch
    (do
      val <- Iface.maintenanceStatus handler (maintenanceStatus_args_hosts args) (maintenanceStatus_args_session args)
      let res = default_MaintenanceStatus_result{maintenanceStatus_result_success = val}
      T.writeMessageBegin oprot ("maintenanceStatus", T.M_REPLY, seqid)
      write_MaintenanceStatus_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("maintenanceStatus", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_endMaintenance (seqid, iprot, oprot, handler) = do
  args <- read_EndMaintenance_args iprot
  (X.catch
    (do
      val <- Iface.endMaintenance handler (endMaintenance_args_hosts args) (endMaintenance_args_session args)
      let res = default_EndMaintenance_result{endMaintenance_result_success = val}
      T.writeMessageBegin oprot ("endMaintenance", T.M_REPLY, seqid)
      write_EndMaintenance_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("endMaintenance", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_snapshot (seqid, iprot, oprot, handler) = do
  args <- read_Snapshot_args iprot
  (X.catch
    (do
      val <- Iface.snapshot handler (snapshot_args_session args)
      let res = default_Snapshot_result{snapshot_result_success = val}
      T.writeMessageBegin oprot ("snapshot", T.M_REPLY, seqid)
      write_Snapshot_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("snapshot", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_rewriteConfigs (seqid, iprot, oprot, handler) = do
  args <- read_RewriteConfigs_args iprot
  (X.catch
    (do
      val <- Iface.rewriteConfigs handler (rewriteConfigs_args_request args) (rewriteConfigs_args_session args)
      let res = default_RewriteConfigs_result{rewriteConfigs_result_success = val}
      T.writeMessageBegin oprot ("rewriteConfigs", T.M_REPLY, seqid)
      write_RewriteConfigs_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("rewriteConfigs", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "setQuota" -> process_setQuota (seqid,iprot,oprot,handler)
  "forceTaskState" -> process_forceTaskState (seqid,iprot,oprot,handler)
  "performBackup" -> process_performBackup (seqid,iprot,oprot,handler)
  "listBackups" -> process_listBackups (seqid,iprot,oprot,handler)
  "stageRecovery" -> process_stageRecovery (seqid,iprot,oprot,handler)
  "queryRecovery" -> process_queryRecovery (seqid,iprot,oprot,handler)
  "deleteRecoveryTasks" -> process_deleteRecoveryTasks (seqid,iprot,oprot,handler)
  "commitRecovery" -> process_commitRecovery (seqid,iprot,oprot,handler)
  "unloadRecovery" -> process_unloadRecovery (seqid,iprot,oprot,handler)
  "startMaintenance" -> process_startMaintenance (seqid,iprot,oprot,handler)
  "drainHosts" -> process_drainHosts (seqid,iprot,oprot,handler)
  "maintenanceStatus" -> process_maintenanceStatus (seqid,iprot,oprot,handler)
  "endMaintenance" -> process_endMaintenance (seqid,iprot,oprot,handler)
  "snapshot" -> process_snapshot (seqid,iprot,oprot,handler)
  "rewriteConfigs" -> process_rewriteConfigs (seqid,iprot,oprot,handler)
  _ -> AuroraSchedulerManager.proc_ handler (iprot,oprot) (name,typ,seqid)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
