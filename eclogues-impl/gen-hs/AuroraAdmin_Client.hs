{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AuroraAdmin_Client(setQuota,forceTaskState,performBackup,listBackups,stageRecovery,queryRecovery,deleteRecoveryTasks,commitRecovery,unloadRecovery,startMaintenance,drainHosts,maintenanceStatus,endMaintenance,snapshot,rewriteConfigs) where
import AuroraSchedulerManager_Client
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Api_Types
import AuroraAdmin
seqid = R.newIORef 0
setQuota (ip,op) arg_ownerRole arg_quota arg_session = do
  send_setQuota op arg_ownerRole arg_quota arg_session
  recv_setQuota ip
send_setQuota op arg_ownerRole arg_quota arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("setQuota", T.M_CALL, seqn)
  write_SetQuota_args op (SetQuota_args{setQuota_args_ownerRole=arg_ownerRole,setQuota_args_quota=arg_quota,setQuota_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_setQuota ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_SetQuota_result ip
  T.readMessageEnd ip
  P.return $ setQuota_result_success res
forceTaskState (ip,op) arg_taskId arg_status arg_session = do
  send_forceTaskState op arg_taskId arg_status arg_session
  recv_forceTaskState ip
send_forceTaskState op arg_taskId arg_status arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("forceTaskState", T.M_CALL, seqn)
  write_ForceTaskState_args op (ForceTaskState_args{forceTaskState_args_taskId=arg_taskId,forceTaskState_args_status=arg_status,forceTaskState_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_forceTaskState ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ForceTaskState_result ip
  T.readMessageEnd ip
  P.return $ forceTaskState_result_success res
performBackup (ip,op) arg_session = do
  send_performBackup op arg_session
  recv_performBackup ip
send_performBackup op arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("performBackup", T.M_CALL, seqn)
  write_PerformBackup_args op (PerformBackup_args{performBackup_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_performBackup ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_PerformBackup_result ip
  T.readMessageEnd ip
  P.return $ performBackup_result_success res
listBackups (ip,op) arg_session = do
  send_listBackups op arg_session
  recv_listBackups ip
send_listBackups op arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("listBackups", T.M_CALL, seqn)
  write_ListBackups_args op (ListBackups_args{listBackups_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_listBackups ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ListBackups_result ip
  T.readMessageEnd ip
  P.return $ listBackups_result_success res
stageRecovery (ip,op) arg_backupId arg_session = do
  send_stageRecovery op arg_backupId arg_session
  recv_stageRecovery ip
send_stageRecovery op arg_backupId arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("stageRecovery", T.M_CALL, seqn)
  write_StageRecovery_args op (StageRecovery_args{stageRecovery_args_backupId=arg_backupId,stageRecovery_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_stageRecovery ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_StageRecovery_result ip
  T.readMessageEnd ip
  P.return $ stageRecovery_result_success res
queryRecovery (ip,op) arg_query arg_session = do
  send_queryRecovery op arg_query arg_session
  recv_queryRecovery ip
send_queryRecovery op arg_query arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("queryRecovery", T.M_CALL, seqn)
  write_QueryRecovery_args op (QueryRecovery_args{queryRecovery_args_query=arg_query,queryRecovery_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_queryRecovery ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_QueryRecovery_result ip
  T.readMessageEnd ip
  P.return $ queryRecovery_result_success res
deleteRecoveryTasks (ip,op) arg_query arg_session = do
  send_deleteRecoveryTasks op arg_query arg_session
  recv_deleteRecoveryTasks ip
send_deleteRecoveryTasks op arg_query arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("deleteRecoveryTasks", T.M_CALL, seqn)
  write_DeleteRecoveryTasks_args op (DeleteRecoveryTasks_args{deleteRecoveryTasks_args_query=arg_query,deleteRecoveryTasks_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_deleteRecoveryTasks ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_DeleteRecoveryTasks_result ip
  T.readMessageEnd ip
  P.return $ deleteRecoveryTasks_result_success res
commitRecovery (ip,op) arg_session = do
  send_commitRecovery op arg_session
  recv_commitRecovery ip
send_commitRecovery op arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("commitRecovery", T.M_CALL, seqn)
  write_CommitRecovery_args op (CommitRecovery_args{commitRecovery_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_commitRecovery ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_CommitRecovery_result ip
  T.readMessageEnd ip
  P.return $ commitRecovery_result_success res
unloadRecovery (ip,op) arg_session = do
  send_unloadRecovery op arg_session
  recv_unloadRecovery ip
send_unloadRecovery op arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("unloadRecovery", T.M_CALL, seqn)
  write_UnloadRecovery_args op (UnloadRecovery_args{unloadRecovery_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_unloadRecovery ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_UnloadRecovery_result ip
  T.readMessageEnd ip
  P.return $ unloadRecovery_result_success res
startMaintenance (ip,op) arg_hosts arg_session = do
  send_startMaintenance op arg_hosts arg_session
  recv_startMaintenance ip
send_startMaintenance op arg_hosts arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("startMaintenance", T.M_CALL, seqn)
  write_StartMaintenance_args op (StartMaintenance_args{startMaintenance_args_hosts=arg_hosts,startMaintenance_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_startMaintenance ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_StartMaintenance_result ip
  T.readMessageEnd ip
  P.return $ startMaintenance_result_success res
drainHosts (ip,op) arg_hosts arg_session = do
  send_drainHosts op arg_hosts arg_session
  recv_drainHosts ip
send_drainHosts op arg_hosts arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("drainHosts", T.M_CALL, seqn)
  write_DrainHosts_args op (DrainHosts_args{drainHosts_args_hosts=arg_hosts,drainHosts_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_drainHosts ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_DrainHosts_result ip
  T.readMessageEnd ip
  P.return $ drainHosts_result_success res
maintenanceStatus (ip,op) arg_hosts arg_session = do
  send_maintenanceStatus op arg_hosts arg_session
  recv_maintenanceStatus ip
send_maintenanceStatus op arg_hosts arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("maintenanceStatus", T.M_CALL, seqn)
  write_MaintenanceStatus_args op (MaintenanceStatus_args{maintenanceStatus_args_hosts=arg_hosts,maintenanceStatus_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_maintenanceStatus ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_MaintenanceStatus_result ip
  T.readMessageEnd ip
  P.return $ maintenanceStatus_result_success res
endMaintenance (ip,op) arg_hosts arg_session = do
  send_endMaintenance op arg_hosts arg_session
  recv_endMaintenance ip
send_endMaintenance op arg_hosts arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("endMaintenance", T.M_CALL, seqn)
  write_EndMaintenance_args op (EndMaintenance_args{endMaintenance_args_hosts=arg_hosts,endMaintenance_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_endMaintenance ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_EndMaintenance_result ip
  T.readMessageEnd ip
  P.return $ endMaintenance_result_success res
snapshot (ip,op) arg_session = do
  send_snapshot op arg_session
  recv_snapshot ip
send_snapshot op arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("snapshot", T.M_CALL, seqn)
  write_Snapshot_args op (Snapshot_args{snapshot_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_snapshot ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Snapshot_result ip
  T.readMessageEnd ip
  P.return $ snapshot_result_success res
rewriteConfigs (ip,op) arg_request arg_session = do
  send_rewriteConfigs op arg_request arg_session
  recv_rewriteConfigs ip
send_rewriteConfigs op arg_request arg_session = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("rewriteConfigs", T.M_CALL, seqn)
  write_RewriteConfigs_args op (RewriteConfigs_args{rewriteConfigs_args_request=arg_request,rewriteConfigs_args_session=arg_session})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_rewriteConfigs ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_RewriteConfigs_result ip
  T.readMessageEnd ip
  P.return $ rewriteConfigs_result_success res
