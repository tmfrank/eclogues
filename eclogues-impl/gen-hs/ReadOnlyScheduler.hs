{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ReadOnlyScheduler where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Api_Types
import qualified ReadOnlyScheduler_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetRoleSummary_args = GetRoleSummary_args deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetRoleSummary_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetRoleSummary_args where 
  arbitrary = QC.elements [GetRoleSummary_args]
from_GetRoleSummary_args :: GetRoleSummary_args -> T.ThriftVal
from_GetRoleSummary_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetRoleSummary_args :: (T.Protocol p, T.Transport t) => p t -> GetRoleSummary_args -> P.IO ()
write_GetRoleSummary_args oprot record = T.writeVal oprot $ from_GetRoleSummary_args record
encode_GetRoleSummary_args :: (T.Protocol p, T.Transport t) => p t -> GetRoleSummary_args -> LBS.ByteString
encode_GetRoleSummary_args oprot record = T.serializeVal oprot $ from_GetRoleSummary_args record
to_GetRoleSummary_args :: T.ThriftVal -> GetRoleSummary_args
to_GetRoleSummary_args (T.TStruct fields) = GetRoleSummary_args{

  }
to_GetRoleSummary_args _ = P.error "not a struct"
read_GetRoleSummary_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetRoleSummary_args
read_GetRoleSummary_args iprot = to_GetRoleSummary_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoleSummary_args)
decode_GetRoleSummary_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetRoleSummary_args
decode_GetRoleSummary_args iprot bs = to_GetRoleSummary_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoleSummary_args) bs
typemap_GetRoleSummary_args :: T.TypeMap
typemap_GetRoleSummary_args = Map.fromList []
default_GetRoleSummary_args :: GetRoleSummary_args
default_GetRoleSummary_args = GetRoleSummary_args{
}
data GetRoleSummary_result = GetRoleSummary_result  { getRoleSummary_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetRoleSummary_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoleSummary_result_success record  
instance QC.Arbitrary GetRoleSummary_result where 
  arbitrary = M.liftM GetRoleSummary_result (QC.arbitrary)
  shrink obj | obj == default_GetRoleSummary_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoleSummary_result{getRoleSummary_result_success = getRoleSummary_result_success obj} then P.Nothing else P.Just $ default_GetRoleSummary_result{getRoleSummary_result_success = getRoleSummary_result_success obj}
    ]
from_GetRoleSummary_result :: GetRoleSummary_result -> T.ThriftVal
from_GetRoleSummary_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v764 -> P.Just (0, ("success",from_Response _v764))) $ getRoleSummary_result_success record
  ]
write_GetRoleSummary_result :: (T.Protocol p, T.Transport t) => p t -> GetRoleSummary_result -> P.IO ()
write_GetRoleSummary_result oprot record = T.writeVal oprot $ from_GetRoleSummary_result record
encode_GetRoleSummary_result :: (T.Protocol p, T.Transport t) => p t -> GetRoleSummary_result -> LBS.ByteString
encode_GetRoleSummary_result oprot record = T.serializeVal oprot $ from_GetRoleSummary_result record
to_GetRoleSummary_result :: T.ThriftVal -> GetRoleSummary_result
to_GetRoleSummary_result (T.TStruct fields) = GetRoleSummary_result{
  getRoleSummary_result_success = P.maybe (getRoleSummary_result_success default_GetRoleSummary_result) (\(_,_val766) -> (case _val766 of {T.TStruct _val767 -> (to_Response (T.TStruct _val767)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetRoleSummary_result _ = P.error "not a struct"
read_GetRoleSummary_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetRoleSummary_result
read_GetRoleSummary_result iprot = to_GetRoleSummary_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoleSummary_result)
decode_GetRoleSummary_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetRoleSummary_result
decode_GetRoleSummary_result iprot bs = to_GetRoleSummary_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoleSummary_result) bs
typemap_GetRoleSummary_result :: T.TypeMap
typemap_GetRoleSummary_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetRoleSummary_result :: GetRoleSummary_result
default_GetRoleSummary_result = GetRoleSummary_result{
  getRoleSummary_result_success = default_Response}
data GetJobSummary_args = GetJobSummary_args  { getJobSummary_args_role :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobSummary_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobSummary_args_role record  
instance QC.Arbitrary GetJobSummary_args where 
  arbitrary = M.liftM GetJobSummary_args (QC.arbitrary)
  shrink obj | obj == default_GetJobSummary_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobSummary_args{getJobSummary_args_role = getJobSummary_args_role obj} then P.Nothing else P.Just $ default_GetJobSummary_args{getJobSummary_args_role = getJobSummary_args_role obj}
    ]
from_GetJobSummary_args :: GetJobSummary_args -> T.ThriftVal
from_GetJobSummary_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v770 -> P.Just (1, ("role",T.TString $ E.encodeUtf8 _v770))) $ getJobSummary_args_role record
  ]
write_GetJobSummary_args :: (T.Protocol p, T.Transport t) => p t -> GetJobSummary_args -> P.IO ()
write_GetJobSummary_args oprot record = T.writeVal oprot $ from_GetJobSummary_args record
encode_GetJobSummary_args :: (T.Protocol p, T.Transport t) => p t -> GetJobSummary_args -> LBS.ByteString
encode_GetJobSummary_args oprot record = T.serializeVal oprot $ from_GetJobSummary_args record
to_GetJobSummary_args :: T.ThriftVal -> GetJobSummary_args
to_GetJobSummary_args (T.TStruct fields) = GetJobSummary_args{
  getJobSummary_args_role = P.maybe (getJobSummary_args_role default_GetJobSummary_args) (\(_,_val772) -> (case _val772 of {T.TString _val773 -> E.decodeUtf8 _val773; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobSummary_args _ = P.error "not a struct"
read_GetJobSummary_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobSummary_args
read_GetJobSummary_args iprot = to_GetJobSummary_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJobSummary_args)
decode_GetJobSummary_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobSummary_args
decode_GetJobSummary_args iprot bs = to_GetJobSummary_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobSummary_args) bs
typemap_GetJobSummary_args :: T.TypeMap
typemap_GetJobSummary_args = Map.fromList [(1,("role",T.T_STRING))]
default_GetJobSummary_args :: GetJobSummary_args
default_GetJobSummary_args = GetJobSummary_args{
  getJobSummary_args_role = ""}
data GetJobSummary_result = GetJobSummary_result  { getJobSummary_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobSummary_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobSummary_result_success record  
instance QC.Arbitrary GetJobSummary_result where 
  arbitrary = M.liftM GetJobSummary_result (QC.arbitrary)
  shrink obj | obj == default_GetJobSummary_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobSummary_result{getJobSummary_result_success = getJobSummary_result_success obj} then P.Nothing else P.Just $ default_GetJobSummary_result{getJobSummary_result_success = getJobSummary_result_success obj}
    ]
from_GetJobSummary_result :: GetJobSummary_result -> T.ThriftVal
from_GetJobSummary_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v776 -> P.Just (0, ("success",from_Response _v776))) $ getJobSummary_result_success record
  ]
write_GetJobSummary_result :: (T.Protocol p, T.Transport t) => p t -> GetJobSummary_result -> P.IO ()
write_GetJobSummary_result oprot record = T.writeVal oprot $ from_GetJobSummary_result record
encode_GetJobSummary_result :: (T.Protocol p, T.Transport t) => p t -> GetJobSummary_result -> LBS.ByteString
encode_GetJobSummary_result oprot record = T.serializeVal oprot $ from_GetJobSummary_result record
to_GetJobSummary_result :: T.ThriftVal -> GetJobSummary_result
to_GetJobSummary_result (T.TStruct fields) = GetJobSummary_result{
  getJobSummary_result_success = P.maybe (getJobSummary_result_success default_GetJobSummary_result) (\(_,_val778) -> (case _val778 of {T.TStruct _val779 -> (to_Response (T.TStruct _val779)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetJobSummary_result _ = P.error "not a struct"
read_GetJobSummary_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobSummary_result
read_GetJobSummary_result iprot = to_GetJobSummary_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJobSummary_result)
decode_GetJobSummary_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobSummary_result
decode_GetJobSummary_result iprot bs = to_GetJobSummary_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobSummary_result) bs
typemap_GetJobSummary_result :: T.TypeMap
typemap_GetJobSummary_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetJobSummary_result :: GetJobSummary_result
default_GetJobSummary_result = GetJobSummary_result{
  getJobSummary_result_success = default_Response}
data GetTasksStatus_args = GetTasksStatus_args  { getTasksStatus_args_query :: TaskQuery
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetTasksStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTasksStatus_args_query record  
instance QC.Arbitrary GetTasksStatus_args where 
  arbitrary = M.liftM GetTasksStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetTasksStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTasksStatus_args{getTasksStatus_args_query = getTasksStatus_args_query obj} then P.Nothing else P.Just $ default_GetTasksStatus_args{getTasksStatus_args_query = getTasksStatus_args_query obj}
    ]
from_GetTasksStatus_args :: GetTasksStatus_args -> T.ThriftVal
from_GetTasksStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v782 -> P.Just (1, ("query",from_TaskQuery _v782))) $ getTasksStatus_args_query record
  ]
write_GetTasksStatus_args :: (T.Protocol p, T.Transport t) => p t -> GetTasksStatus_args -> P.IO ()
write_GetTasksStatus_args oprot record = T.writeVal oprot $ from_GetTasksStatus_args record
encode_GetTasksStatus_args :: (T.Protocol p, T.Transport t) => p t -> GetTasksStatus_args -> LBS.ByteString
encode_GetTasksStatus_args oprot record = T.serializeVal oprot $ from_GetTasksStatus_args record
to_GetTasksStatus_args :: T.ThriftVal -> GetTasksStatus_args
to_GetTasksStatus_args (T.TStruct fields) = GetTasksStatus_args{
  getTasksStatus_args_query = P.maybe (getTasksStatus_args_query default_GetTasksStatus_args) (\(_,_val784) -> (case _val784 of {T.TStruct _val785 -> (to_TaskQuery (T.TStruct _val785)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetTasksStatus_args _ = P.error "not a struct"
read_GetTasksStatus_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetTasksStatus_args
read_GetTasksStatus_args iprot = to_GetTasksStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetTasksStatus_args)
decode_GetTasksStatus_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetTasksStatus_args
decode_GetTasksStatus_args iprot bs = to_GetTasksStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTasksStatus_args) bs
typemap_GetTasksStatus_args :: T.TypeMap
typemap_GetTasksStatus_args = Map.fromList [(1,("query",(T.T_STRUCT typemap_TaskQuery)))]
default_GetTasksStatus_args :: GetTasksStatus_args
default_GetTasksStatus_args = GetTasksStatus_args{
  getTasksStatus_args_query = default_TaskQuery}
data GetTasksStatus_result = GetTasksStatus_result  { getTasksStatus_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetTasksStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTasksStatus_result_success record  
instance QC.Arbitrary GetTasksStatus_result where 
  arbitrary = M.liftM GetTasksStatus_result (QC.arbitrary)
  shrink obj | obj == default_GetTasksStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTasksStatus_result{getTasksStatus_result_success = getTasksStatus_result_success obj} then P.Nothing else P.Just $ default_GetTasksStatus_result{getTasksStatus_result_success = getTasksStatus_result_success obj}
    ]
from_GetTasksStatus_result :: GetTasksStatus_result -> T.ThriftVal
from_GetTasksStatus_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v788 -> P.Just (0, ("success",from_Response _v788))) $ getTasksStatus_result_success record
  ]
write_GetTasksStatus_result :: (T.Protocol p, T.Transport t) => p t -> GetTasksStatus_result -> P.IO ()
write_GetTasksStatus_result oprot record = T.writeVal oprot $ from_GetTasksStatus_result record
encode_GetTasksStatus_result :: (T.Protocol p, T.Transport t) => p t -> GetTasksStatus_result -> LBS.ByteString
encode_GetTasksStatus_result oprot record = T.serializeVal oprot $ from_GetTasksStatus_result record
to_GetTasksStatus_result :: T.ThriftVal -> GetTasksStatus_result
to_GetTasksStatus_result (T.TStruct fields) = GetTasksStatus_result{
  getTasksStatus_result_success = P.maybe (getTasksStatus_result_success default_GetTasksStatus_result) (\(_,_val790) -> (case _val790 of {T.TStruct _val791 -> (to_Response (T.TStruct _val791)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetTasksStatus_result _ = P.error "not a struct"
read_GetTasksStatus_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetTasksStatus_result
read_GetTasksStatus_result iprot = to_GetTasksStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetTasksStatus_result)
decode_GetTasksStatus_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetTasksStatus_result
decode_GetTasksStatus_result iprot bs = to_GetTasksStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTasksStatus_result) bs
typemap_GetTasksStatus_result :: T.TypeMap
typemap_GetTasksStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetTasksStatus_result :: GetTasksStatus_result
default_GetTasksStatus_result = GetTasksStatus_result{
  getTasksStatus_result_success = default_Response}
data GetTasksWithoutConfigs_args = GetTasksWithoutConfigs_args  { getTasksWithoutConfigs_args_query :: TaskQuery
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetTasksWithoutConfigs_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTasksWithoutConfigs_args_query record  
instance QC.Arbitrary GetTasksWithoutConfigs_args where 
  arbitrary = M.liftM GetTasksWithoutConfigs_args (QC.arbitrary)
  shrink obj | obj == default_GetTasksWithoutConfigs_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTasksWithoutConfigs_args{getTasksWithoutConfigs_args_query = getTasksWithoutConfigs_args_query obj} then P.Nothing else P.Just $ default_GetTasksWithoutConfigs_args{getTasksWithoutConfigs_args_query = getTasksWithoutConfigs_args_query obj}
    ]
from_GetTasksWithoutConfigs_args :: GetTasksWithoutConfigs_args -> T.ThriftVal
from_GetTasksWithoutConfigs_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v794 -> P.Just (1, ("query",from_TaskQuery _v794))) $ getTasksWithoutConfigs_args_query record
  ]
write_GetTasksWithoutConfigs_args :: (T.Protocol p, T.Transport t) => p t -> GetTasksWithoutConfigs_args -> P.IO ()
write_GetTasksWithoutConfigs_args oprot record = T.writeVal oprot $ from_GetTasksWithoutConfigs_args record
encode_GetTasksWithoutConfigs_args :: (T.Protocol p, T.Transport t) => p t -> GetTasksWithoutConfigs_args -> LBS.ByteString
encode_GetTasksWithoutConfigs_args oprot record = T.serializeVal oprot $ from_GetTasksWithoutConfigs_args record
to_GetTasksWithoutConfigs_args :: T.ThriftVal -> GetTasksWithoutConfigs_args
to_GetTasksWithoutConfigs_args (T.TStruct fields) = GetTasksWithoutConfigs_args{
  getTasksWithoutConfigs_args_query = P.maybe (getTasksWithoutConfigs_args_query default_GetTasksWithoutConfigs_args) (\(_,_val796) -> (case _val796 of {T.TStruct _val797 -> (to_TaskQuery (T.TStruct _val797)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetTasksWithoutConfigs_args _ = P.error "not a struct"
read_GetTasksWithoutConfigs_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetTasksWithoutConfigs_args
read_GetTasksWithoutConfigs_args iprot = to_GetTasksWithoutConfigs_args <$> T.readVal iprot (T.T_STRUCT typemap_GetTasksWithoutConfigs_args)
decode_GetTasksWithoutConfigs_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetTasksWithoutConfigs_args
decode_GetTasksWithoutConfigs_args iprot bs = to_GetTasksWithoutConfigs_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTasksWithoutConfigs_args) bs
typemap_GetTasksWithoutConfigs_args :: T.TypeMap
typemap_GetTasksWithoutConfigs_args = Map.fromList [(1,("query",(T.T_STRUCT typemap_TaskQuery)))]
default_GetTasksWithoutConfigs_args :: GetTasksWithoutConfigs_args
default_GetTasksWithoutConfigs_args = GetTasksWithoutConfigs_args{
  getTasksWithoutConfigs_args_query = default_TaskQuery}
data GetTasksWithoutConfigs_result = GetTasksWithoutConfigs_result  { getTasksWithoutConfigs_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetTasksWithoutConfigs_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTasksWithoutConfigs_result_success record  
instance QC.Arbitrary GetTasksWithoutConfigs_result where 
  arbitrary = M.liftM GetTasksWithoutConfigs_result (QC.arbitrary)
  shrink obj | obj == default_GetTasksWithoutConfigs_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTasksWithoutConfigs_result{getTasksWithoutConfigs_result_success = getTasksWithoutConfigs_result_success obj} then P.Nothing else P.Just $ default_GetTasksWithoutConfigs_result{getTasksWithoutConfigs_result_success = getTasksWithoutConfigs_result_success obj}
    ]
from_GetTasksWithoutConfigs_result :: GetTasksWithoutConfigs_result -> T.ThriftVal
from_GetTasksWithoutConfigs_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v800 -> P.Just (0, ("success",from_Response _v800))) $ getTasksWithoutConfigs_result_success record
  ]
write_GetTasksWithoutConfigs_result :: (T.Protocol p, T.Transport t) => p t -> GetTasksWithoutConfigs_result -> P.IO ()
write_GetTasksWithoutConfigs_result oprot record = T.writeVal oprot $ from_GetTasksWithoutConfigs_result record
encode_GetTasksWithoutConfigs_result :: (T.Protocol p, T.Transport t) => p t -> GetTasksWithoutConfigs_result -> LBS.ByteString
encode_GetTasksWithoutConfigs_result oprot record = T.serializeVal oprot $ from_GetTasksWithoutConfigs_result record
to_GetTasksWithoutConfigs_result :: T.ThriftVal -> GetTasksWithoutConfigs_result
to_GetTasksWithoutConfigs_result (T.TStruct fields) = GetTasksWithoutConfigs_result{
  getTasksWithoutConfigs_result_success = P.maybe (getTasksWithoutConfigs_result_success default_GetTasksWithoutConfigs_result) (\(_,_val802) -> (case _val802 of {T.TStruct _val803 -> (to_Response (T.TStruct _val803)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetTasksWithoutConfigs_result _ = P.error "not a struct"
read_GetTasksWithoutConfigs_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetTasksWithoutConfigs_result
read_GetTasksWithoutConfigs_result iprot = to_GetTasksWithoutConfigs_result <$> T.readVal iprot (T.T_STRUCT typemap_GetTasksWithoutConfigs_result)
decode_GetTasksWithoutConfigs_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetTasksWithoutConfigs_result
decode_GetTasksWithoutConfigs_result iprot bs = to_GetTasksWithoutConfigs_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTasksWithoutConfigs_result) bs
typemap_GetTasksWithoutConfigs_result :: T.TypeMap
typemap_GetTasksWithoutConfigs_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetTasksWithoutConfigs_result :: GetTasksWithoutConfigs_result
default_GetTasksWithoutConfigs_result = GetTasksWithoutConfigs_result{
  getTasksWithoutConfigs_result_success = default_Response}
data GetPendingReason_args = GetPendingReason_args  { getPendingReason_args_query :: TaskQuery
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetPendingReason_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPendingReason_args_query record  
instance QC.Arbitrary GetPendingReason_args where 
  arbitrary = M.liftM GetPendingReason_args (QC.arbitrary)
  shrink obj | obj == default_GetPendingReason_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPendingReason_args{getPendingReason_args_query = getPendingReason_args_query obj} then P.Nothing else P.Just $ default_GetPendingReason_args{getPendingReason_args_query = getPendingReason_args_query obj}
    ]
from_GetPendingReason_args :: GetPendingReason_args -> T.ThriftVal
from_GetPendingReason_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v806 -> P.Just (1, ("query",from_TaskQuery _v806))) $ getPendingReason_args_query record
  ]
write_GetPendingReason_args :: (T.Protocol p, T.Transport t) => p t -> GetPendingReason_args -> P.IO ()
write_GetPendingReason_args oprot record = T.writeVal oprot $ from_GetPendingReason_args record
encode_GetPendingReason_args :: (T.Protocol p, T.Transport t) => p t -> GetPendingReason_args -> LBS.ByteString
encode_GetPendingReason_args oprot record = T.serializeVal oprot $ from_GetPendingReason_args record
to_GetPendingReason_args :: T.ThriftVal -> GetPendingReason_args
to_GetPendingReason_args (T.TStruct fields) = GetPendingReason_args{
  getPendingReason_args_query = P.maybe (getPendingReason_args_query default_GetPendingReason_args) (\(_,_val808) -> (case _val808 of {T.TStruct _val809 -> (to_TaskQuery (T.TStruct _val809)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPendingReason_args _ = P.error "not a struct"
read_GetPendingReason_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetPendingReason_args
read_GetPendingReason_args iprot = to_GetPendingReason_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPendingReason_args)
decode_GetPendingReason_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetPendingReason_args
decode_GetPendingReason_args iprot bs = to_GetPendingReason_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPendingReason_args) bs
typemap_GetPendingReason_args :: T.TypeMap
typemap_GetPendingReason_args = Map.fromList [(1,("query",(T.T_STRUCT typemap_TaskQuery)))]
default_GetPendingReason_args :: GetPendingReason_args
default_GetPendingReason_args = GetPendingReason_args{
  getPendingReason_args_query = default_TaskQuery}
data GetPendingReason_result = GetPendingReason_result  { getPendingReason_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetPendingReason_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPendingReason_result_success record  
instance QC.Arbitrary GetPendingReason_result where 
  arbitrary = M.liftM GetPendingReason_result (QC.arbitrary)
  shrink obj | obj == default_GetPendingReason_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPendingReason_result{getPendingReason_result_success = getPendingReason_result_success obj} then P.Nothing else P.Just $ default_GetPendingReason_result{getPendingReason_result_success = getPendingReason_result_success obj}
    ]
from_GetPendingReason_result :: GetPendingReason_result -> T.ThriftVal
from_GetPendingReason_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v812 -> P.Just (0, ("success",from_Response _v812))) $ getPendingReason_result_success record
  ]
write_GetPendingReason_result :: (T.Protocol p, T.Transport t) => p t -> GetPendingReason_result -> P.IO ()
write_GetPendingReason_result oprot record = T.writeVal oprot $ from_GetPendingReason_result record
encode_GetPendingReason_result :: (T.Protocol p, T.Transport t) => p t -> GetPendingReason_result -> LBS.ByteString
encode_GetPendingReason_result oprot record = T.serializeVal oprot $ from_GetPendingReason_result record
to_GetPendingReason_result :: T.ThriftVal -> GetPendingReason_result
to_GetPendingReason_result (T.TStruct fields) = GetPendingReason_result{
  getPendingReason_result_success = P.maybe (getPendingReason_result_success default_GetPendingReason_result) (\(_,_val814) -> (case _val814 of {T.TStruct _val815 -> (to_Response (T.TStruct _val815)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetPendingReason_result _ = P.error "not a struct"
read_GetPendingReason_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetPendingReason_result
read_GetPendingReason_result iprot = to_GetPendingReason_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPendingReason_result)
decode_GetPendingReason_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetPendingReason_result
decode_GetPendingReason_result iprot bs = to_GetPendingReason_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPendingReason_result) bs
typemap_GetPendingReason_result :: T.TypeMap
typemap_GetPendingReason_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetPendingReason_result :: GetPendingReason_result
default_GetPendingReason_result = GetPendingReason_result{
  getPendingReason_result_success = default_Response}
data GetConfigSummary_args = GetConfigSummary_args  { getConfigSummary_args_job :: JobKey
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetConfigSummary_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getConfigSummary_args_job record  
instance QC.Arbitrary GetConfigSummary_args where 
  arbitrary = M.liftM GetConfigSummary_args (QC.arbitrary)
  shrink obj | obj == default_GetConfigSummary_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetConfigSummary_args{getConfigSummary_args_job = getConfigSummary_args_job obj} then P.Nothing else P.Just $ default_GetConfigSummary_args{getConfigSummary_args_job = getConfigSummary_args_job obj}
    ]
from_GetConfigSummary_args :: GetConfigSummary_args -> T.ThriftVal
from_GetConfigSummary_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v818 -> P.Just (1, ("job",from_JobKey _v818))) $ getConfigSummary_args_job record
  ]
write_GetConfigSummary_args :: (T.Protocol p, T.Transport t) => p t -> GetConfigSummary_args -> P.IO ()
write_GetConfigSummary_args oprot record = T.writeVal oprot $ from_GetConfigSummary_args record
encode_GetConfigSummary_args :: (T.Protocol p, T.Transport t) => p t -> GetConfigSummary_args -> LBS.ByteString
encode_GetConfigSummary_args oprot record = T.serializeVal oprot $ from_GetConfigSummary_args record
to_GetConfigSummary_args :: T.ThriftVal -> GetConfigSummary_args
to_GetConfigSummary_args (T.TStruct fields) = GetConfigSummary_args{
  getConfigSummary_args_job = P.maybe (getConfigSummary_args_job default_GetConfigSummary_args) (\(_,_val820) -> (case _val820 of {T.TStruct _val821 -> (to_JobKey (T.TStruct _val821)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetConfigSummary_args _ = P.error "not a struct"
read_GetConfigSummary_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetConfigSummary_args
read_GetConfigSummary_args iprot = to_GetConfigSummary_args <$> T.readVal iprot (T.T_STRUCT typemap_GetConfigSummary_args)
decode_GetConfigSummary_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetConfigSummary_args
decode_GetConfigSummary_args iprot bs = to_GetConfigSummary_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetConfigSummary_args) bs
typemap_GetConfigSummary_args :: T.TypeMap
typemap_GetConfigSummary_args = Map.fromList [(1,("job",(T.T_STRUCT typemap_JobKey)))]
default_GetConfigSummary_args :: GetConfigSummary_args
default_GetConfigSummary_args = GetConfigSummary_args{
  getConfigSummary_args_job = default_JobKey}
data GetConfigSummary_result = GetConfigSummary_result  { getConfigSummary_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetConfigSummary_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getConfigSummary_result_success record  
instance QC.Arbitrary GetConfigSummary_result where 
  arbitrary = M.liftM GetConfigSummary_result (QC.arbitrary)
  shrink obj | obj == default_GetConfigSummary_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetConfigSummary_result{getConfigSummary_result_success = getConfigSummary_result_success obj} then P.Nothing else P.Just $ default_GetConfigSummary_result{getConfigSummary_result_success = getConfigSummary_result_success obj}
    ]
from_GetConfigSummary_result :: GetConfigSummary_result -> T.ThriftVal
from_GetConfigSummary_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v824 -> P.Just (0, ("success",from_Response _v824))) $ getConfigSummary_result_success record
  ]
write_GetConfigSummary_result :: (T.Protocol p, T.Transport t) => p t -> GetConfigSummary_result -> P.IO ()
write_GetConfigSummary_result oprot record = T.writeVal oprot $ from_GetConfigSummary_result record
encode_GetConfigSummary_result :: (T.Protocol p, T.Transport t) => p t -> GetConfigSummary_result -> LBS.ByteString
encode_GetConfigSummary_result oprot record = T.serializeVal oprot $ from_GetConfigSummary_result record
to_GetConfigSummary_result :: T.ThriftVal -> GetConfigSummary_result
to_GetConfigSummary_result (T.TStruct fields) = GetConfigSummary_result{
  getConfigSummary_result_success = P.maybe (getConfigSummary_result_success default_GetConfigSummary_result) (\(_,_val826) -> (case _val826 of {T.TStruct _val827 -> (to_Response (T.TStruct _val827)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetConfigSummary_result _ = P.error "not a struct"
read_GetConfigSummary_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetConfigSummary_result
read_GetConfigSummary_result iprot = to_GetConfigSummary_result <$> T.readVal iprot (T.T_STRUCT typemap_GetConfigSummary_result)
decode_GetConfigSummary_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetConfigSummary_result
decode_GetConfigSummary_result iprot bs = to_GetConfigSummary_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetConfigSummary_result) bs
typemap_GetConfigSummary_result :: T.TypeMap
typemap_GetConfigSummary_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetConfigSummary_result :: GetConfigSummary_result
default_GetConfigSummary_result = GetConfigSummary_result{
  getConfigSummary_result_success = default_Response}
data GetJobs_args = GetJobs_args  { getJobs_args_ownerRole :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobs_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobs_args_ownerRole record  
instance QC.Arbitrary GetJobs_args where 
  arbitrary = M.liftM GetJobs_args (QC.arbitrary)
  shrink obj | obj == default_GetJobs_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobs_args{getJobs_args_ownerRole = getJobs_args_ownerRole obj} then P.Nothing else P.Just $ default_GetJobs_args{getJobs_args_ownerRole = getJobs_args_ownerRole obj}
    ]
from_GetJobs_args :: GetJobs_args -> T.ThriftVal
from_GetJobs_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v830 -> P.Just (1, ("ownerRole",T.TString $ E.encodeUtf8 _v830))) $ getJobs_args_ownerRole record
  ]
write_GetJobs_args :: (T.Protocol p, T.Transport t) => p t -> GetJobs_args -> P.IO ()
write_GetJobs_args oprot record = T.writeVal oprot $ from_GetJobs_args record
encode_GetJobs_args :: (T.Protocol p, T.Transport t) => p t -> GetJobs_args -> LBS.ByteString
encode_GetJobs_args oprot record = T.serializeVal oprot $ from_GetJobs_args record
to_GetJobs_args :: T.ThriftVal -> GetJobs_args
to_GetJobs_args (T.TStruct fields) = GetJobs_args{
  getJobs_args_ownerRole = P.maybe (getJobs_args_ownerRole default_GetJobs_args) (\(_,_val832) -> (case _val832 of {T.TString _val833 -> E.decodeUtf8 _val833; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobs_args _ = P.error "not a struct"
read_GetJobs_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobs_args
read_GetJobs_args iprot = to_GetJobs_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJobs_args)
decode_GetJobs_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobs_args
decode_GetJobs_args iprot bs = to_GetJobs_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobs_args) bs
typemap_GetJobs_args :: T.TypeMap
typemap_GetJobs_args = Map.fromList [(1,("ownerRole",T.T_STRING))]
default_GetJobs_args :: GetJobs_args
default_GetJobs_args = GetJobs_args{
  getJobs_args_ownerRole = ""}
data GetJobs_result = GetJobs_result  { getJobs_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobs_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobs_result_success record  
instance QC.Arbitrary GetJobs_result where 
  arbitrary = M.liftM GetJobs_result (QC.arbitrary)
  shrink obj | obj == default_GetJobs_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobs_result{getJobs_result_success = getJobs_result_success obj} then P.Nothing else P.Just $ default_GetJobs_result{getJobs_result_success = getJobs_result_success obj}
    ]
from_GetJobs_result :: GetJobs_result -> T.ThriftVal
from_GetJobs_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v836 -> P.Just (0, ("success",from_Response _v836))) $ getJobs_result_success record
  ]
write_GetJobs_result :: (T.Protocol p, T.Transport t) => p t -> GetJobs_result -> P.IO ()
write_GetJobs_result oprot record = T.writeVal oprot $ from_GetJobs_result record
encode_GetJobs_result :: (T.Protocol p, T.Transport t) => p t -> GetJobs_result -> LBS.ByteString
encode_GetJobs_result oprot record = T.serializeVal oprot $ from_GetJobs_result record
to_GetJobs_result :: T.ThriftVal -> GetJobs_result
to_GetJobs_result (T.TStruct fields) = GetJobs_result{
  getJobs_result_success = P.maybe (getJobs_result_success default_GetJobs_result) (\(_,_val838) -> (case _val838 of {T.TStruct _val839 -> (to_Response (T.TStruct _val839)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetJobs_result _ = P.error "not a struct"
read_GetJobs_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobs_result
read_GetJobs_result iprot = to_GetJobs_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJobs_result)
decode_GetJobs_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobs_result
decode_GetJobs_result iprot bs = to_GetJobs_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobs_result) bs
typemap_GetJobs_result :: T.TypeMap
typemap_GetJobs_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetJobs_result :: GetJobs_result
default_GetJobs_result = GetJobs_result{
  getJobs_result_success = default_Response}
data GetQuota_args = GetQuota_args  { getQuota_args_ownerRole :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetQuota_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getQuota_args_ownerRole record  
instance QC.Arbitrary GetQuota_args where 
  arbitrary = M.liftM GetQuota_args (QC.arbitrary)
  shrink obj | obj == default_GetQuota_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetQuota_args{getQuota_args_ownerRole = getQuota_args_ownerRole obj} then P.Nothing else P.Just $ default_GetQuota_args{getQuota_args_ownerRole = getQuota_args_ownerRole obj}
    ]
from_GetQuota_args :: GetQuota_args -> T.ThriftVal
from_GetQuota_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v842 -> P.Just (1, ("ownerRole",T.TString $ E.encodeUtf8 _v842))) $ getQuota_args_ownerRole record
  ]
write_GetQuota_args :: (T.Protocol p, T.Transport t) => p t -> GetQuota_args -> P.IO ()
write_GetQuota_args oprot record = T.writeVal oprot $ from_GetQuota_args record
encode_GetQuota_args :: (T.Protocol p, T.Transport t) => p t -> GetQuota_args -> LBS.ByteString
encode_GetQuota_args oprot record = T.serializeVal oprot $ from_GetQuota_args record
to_GetQuota_args :: T.ThriftVal -> GetQuota_args
to_GetQuota_args (T.TStruct fields) = GetQuota_args{
  getQuota_args_ownerRole = P.maybe (getQuota_args_ownerRole default_GetQuota_args) (\(_,_val844) -> (case _val844 of {T.TString _val845 -> E.decodeUtf8 _val845; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetQuota_args _ = P.error "not a struct"
read_GetQuota_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetQuota_args
read_GetQuota_args iprot = to_GetQuota_args <$> T.readVal iprot (T.T_STRUCT typemap_GetQuota_args)
decode_GetQuota_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetQuota_args
decode_GetQuota_args iprot bs = to_GetQuota_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetQuota_args) bs
typemap_GetQuota_args :: T.TypeMap
typemap_GetQuota_args = Map.fromList [(1,("ownerRole",T.T_STRING))]
default_GetQuota_args :: GetQuota_args
default_GetQuota_args = GetQuota_args{
  getQuota_args_ownerRole = ""}
data GetQuota_result = GetQuota_result  { getQuota_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetQuota_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getQuota_result_success record  
instance QC.Arbitrary GetQuota_result where 
  arbitrary = M.liftM GetQuota_result (QC.arbitrary)
  shrink obj | obj == default_GetQuota_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetQuota_result{getQuota_result_success = getQuota_result_success obj} then P.Nothing else P.Just $ default_GetQuota_result{getQuota_result_success = getQuota_result_success obj}
    ]
from_GetQuota_result :: GetQuota_result -> T.ThriftVal
from_GetQuota_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v848 -> P.Just (0, ("success",from_Response _v848))) $ getQuota_result_success record
  ]
write_GetQuota_result :: (T.Protocol p, T.Transport t) => p t -> GetQuota_result -> P.IO ()
write_GetQuota_result oprot record = T.writeVal oprot $ from_GetQuota_result record
encode_GetQuota_result :: (T.Protocol p, T.Transport t) => p t -> GetQuota_result -> LBS.ByteString
encode_GetQuota_result oprot record = T.serializeVal oprot $ from_GetQuota_result record
to_GetQuota_result :: T.ThriftVal -> GetQuota_result
to_GetQuota_result (T.TStruct fields) = GetQuota_result{
  getQuota_result_success = P.maybe (getQuota_result_success default_GetQuota_result) (\(_,_val850) -> (case _val850 of {T.TStruct _val851 -> (to_Response (T.TStruct _val851)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetQuota_result _ = P.error "not a struct"
read_GetQuota_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetQuota_result
read_GetQuota_result iprot = to_GetQuota_result <$> T.readVal iprot (T.T_STRUCT typemap_GetQuota_result)
decode_GetQuota_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetQuota_result
decode_GetQuota_result iprot bs = to_GetQuota_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetQuota_result) bs
typemap_GetQuota_result :: T.TypeMap
typemap_GetQuota_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetQuota_result :: GetQuota_result
default_GetQuota_result = GetQuota_result{
  getQuota_result_success = default_Response}
data PopulateJobConfig_args = PopulateJobConfig_args  { populateJobConfig_args_description :: JobConfiguration
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PopulateJobConfig_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` populateJobConfig_args_description record  
instance QC.Arbitrary PopulateJobConfig_args where 
  arbitrary = M.liftM PopulateJobConfig_args (QC.arbitrary)
  shrink obj | obj == default_PopulateJobConfig_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PopulateJobConfig_args{populateJobConfig_args_description = populateJobConfig_args_description obj} then P.Nothing else P.Just $ default_PopulateJobConfig_args{populateJobConfig_args_description = populateJobConfig_args_description obj}
    ]
from_PopulateJobConfig_args :: PopulateJobConfig_args -> T.ThriftVal
from_PopulateJobConfig_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v854 -> P.Just (1, ("description",from_JobConfiguration _v854))) $ populateJobConfig_args_description record
  ]
write_PopulateJobConfig_args :: (T.Protocol p, T.Transport t) => p t -> PopulateJobConfig_args -> P.IO ()
write_PopulateJobConfig_args oprot record = T.writeVal oprot $ from_PopulateJobConfig_args record
encode_PopulateJobConfig_args :: (T.Protocol p, T.Transport t) => p t -> PopulateJobConfig_args -> LBS.ByteString
encode_PopulateJobConfig_args oprot record = T.serializeVal oprot $ from_PopulateJobConfig_args record
to_PopulateJobConfig_args :: T.ThriftVal -> PopulateJobConfig_args
to_PopulateJobConfig_args (T.TStruct fields) = PopulateJobConfig_args{
  populateJobConfig_args_description = P.maybe (populateJobConfig_args_description default_PopulateJobConfig_args) (\(_,_val856) -> (case _val856 of {T.TStruct _val857 -> (to_JobConfiguration (T.TStruct _val857)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_PopulateJobConfig_args _ = P.error "not a struct"
read_PopulateJobConfig_args :: (T.Transport t, T.Protocol p) => p t -> P.IO PopulateJobConfig_args
read_PopulateJobConfig_args iprot = to_PopulateJobConfig_args <$> T.readVal iprot (T.T_STRUCT typemap_PopulateJobConfig_args)
decode_PopulateJobConfig_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PopulateJobConfig_args
decode_PopulateJobConfig_args iprot bs = to_PopulateJobConfig_args $ T.deserializeVal iprot (T.T_STRUCT typemap_PopulateJobConfig_args) bs
typemap_PopulateJobConfig_args :: T.TypeMap
typemap_PopulateJobConfig_args = Map.fromList [(1,("description",(T.T_STRUCT typemap_JobConfiguration)))]
default_PopulateJobConfig_args :: PopulateJobConfig_args
default_PopulateJobConfig_args = PopulateJobConfig_args{
  populateJobConfig_args_description = default_JobConfiguration}
data PopulateJobConfig_result = PopulateJobConfig_result  { populateJobConfig_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PopulateJobConfig_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` populateJobConfig_result_success record  
instance QC.Arbitrary PopulateJobConfig_result where 
  arbitrary = M.liftM PopulateJobConfig_result (QC.arbitrary)
  shrink obj | obj == default_PopulateJobConfig_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PopulateJobConfig_result{populateJobConfig_result_success = populateJobConfig_result_success obj} then P.Nothing else P.Just $ default_PopulateJobConfig_result{populateJobConfig_result_success = populateJobConfig_result_success obj}
    ]
from_PopulateJobConfig_result :: PopulateJobConfig_result -> T.ThriftVal
from_PopulateJobConfig_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v860 -> P.Just (0, ("success",from_Response _v860))) $ populateJobConfig_result_success record
  ]
write_PopulateJobConfig_result :: (T.Protocol p, T.Transport t) => p t -> PopulateJobConfig_result -> P.IO ()
write_PopulateJobConfig_result oprot record = T.writeVal oprot $ from_PopulateJobConfig_result record
encode_PopulateJobConfig_result :: (T.Protocol p, T.Transport t) => p t -> PopulateJobConfig_result -> LBS.ByteString
encode_PopulateJobConfig_result oprot record = T.serializeVal oprot $ from_PopulateJobConfig_result record
to_PopulateJobConfig_result :: T.ThriftVal -> PopulateJobConfig_result
to_PopulateJobConfig_result (T.TStruct fields) = PopulateJobConfig_result{
  populateJobConfig_result_success = P.maybe (populateJobConfig_result_success default_PopulateJobConfig_result) (\(_,_val862) -> (case _val862 of {T.TStruct _val863 -> (to_Response (T.TStruct _val863)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_PopulateJobConfig_result _ = P.error "not a struct"
read_PopulateJobConfig_result :: (T.Transport t, T.Protocol p) => p t -> P.IO PopulateJobConfig_result
read_PopulateJobConfig_result iprot = to_PopulateJobConfig_result <$> T.readVal iprot (T.T_STRUCT typemap_PopulateJobConfig_result)
decode_PopulateJobConfig_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PopulateJobConfig_result
decode_PopulateJobConfig_result iprot bs = to_PopulateJobConfig_result $ T.deserializeVal iprot (T.T_STRUCT typemap_PopulateJobConfig_result) bs
typemap_PopulateJobConfig_result :: T.TypeMap
typemap_PopulateJobConfig_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_PopulateJobConfig_result :: PopulateJobConfig_result
default_PopulateJobConfig_result = PopulateJobConfig_result{
  populateJobConfig_result_success = default_Response}
data GetLocks_args = GetLocks_args deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetLocks_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetLocks_args where 
  arbitrary = QC.elements [GetLocks_args]
from_GetLocks_args :: GetLocks_args -> T.ThriftVal
from_GetLocks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetLocks_args :: (T.Protocol p, T.Transport t) => p t -> GetLocks_args -> P.IO ()
write_GetLocks_args oprot record = T.writeVal oprot $ from_GetLocks_args record
encode_GetLocks_args :: (T.Protocol p, T.Transport t) => p t -> GetLocks_args -> LBS.ByteString
encode_GetLocks_args oprot record = T.serializeVal oprot $ from_GetLocks_args record
to_GetLocks_args :: T.ThriftVal -> GetLocks_args
to_GetLocks_args (T.TStruct fields) = GetLocks_args{

  }
to_GetLocks_args _ = P.error "not a struct"
read_GetLocks_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetLocks_args
read_GetLocks_args iprot = to_GetLocks_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLocks_args)
decode_GetLocks_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetLocks_args
decode_GetLocks_args iprot bs = to_GetLocks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLocks_args) bs
typemap_GetLocks_args :: T.TypeMap
typemap_GetLocks_args = Map.fromList []
default_GetLocks_args :: GetLocks_args
default_GetLocks_args = GetLocks_args{
}
data GetLocks_result = GetLocks_result  { getLocks_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetLocks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLocks_result_success record  
instance QC.Arbitrary GetLocks_result where 
  arbitrary = M.liftM GetLocks_result (QC.arbitrary)
  shrink obj | obj == default_GetLocks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLocks_result{getLocks_result_success = getLocks_result_success obj} then P.Nothing else P.Just $ default_GetLocks_result{getLocks_result_success = getLocks_result_success obj}
    ]
from_GetLocks_result :: GetLocks_result -> T.ThriftVal
from_GetLocks_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v871 -> P.Just (0, ("success",from_Response _v871))) $ getLocks_result_success record
  ]
write_GetLocks_result :: (T.Protocol p, T.Transport t) => p t -> GetLocks_result -> P.IO ()
write_GetLocks_result oprot record = T.writeVal oprot $ from_GetLocks_result record
encode_GetLocks_result :: (T.Protocol p, T.Transport t) => p t -> GetLocks_result -> LBS.ByteString
encode_GetLocks_result oprot record = T.serializeVal oprot $ from_GetLocks_result record
to_GetLocks_result :: T.ThriftVal -> GetLocks_result
to_GetLocks_result (T.TStruct fields) = GetLocks_result{
  getLocks_result_success = P.maybe (getLocks_result_success default_GetLocks_result) (\(_,_val873) -> (case _val873 of {T.TStruct _val874 -> (to_Response (T.TStruct _val874)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetLocks_result _ = P.error "not a struct"
read_GetLocks_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetLocks_result
read_GetLocks_result iprot = to_GetLocks_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLocks_result)
decode_GetLocks_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetLocks_result
decode_GetLocks_result iprot bs = to_GetLocks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLocks_result) bs
typemap_GetLocks_result :: T.TypeMap
typemap_GetLocks_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetLocks_result :: GetLocks_result
default_GetLocks_result = GetLocks_result{
  getLocks_result_success = default_Response}
data GetJobUpdateSummaries_args = GetJobUpdateSummaries_args  { getJobUpdateSummaries_args_jobUpdateQuery :: JobUpdateQuery
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobUpdateSummaries_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobUpdateSummaries_args_jobUpdateQuery record  
instance QC.Arbitrary GetJobUpdateSummaries_args where 
  arbitrary = M.liftM GetJobUpdateSummaries_args (QC.arbitrary)
  shrink obj | obj == default_GetJobUpdateSummaries_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobUpdateSummaries_args{getJobUpdateSummaries_args_jobUpdateQuery = getJobUpdateSummaries_args_jobUpdateQuery obj} then P.Nothing else P.Just $ default_GetJobUpdateSummaries_args{getJobUpdateSummaries_args_jobUpdateQuery = getJobUpdateSummaries_args_jobUpdateQuery obj}
    ]
from_GetJobUpdateSummaries_args :: GetJobUpdateSummaries_args -> T.ThriftVal
from_GetJobUpdateSummaries_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v877 -> P.Just (1, ("jobUpdateQuery",from_JobUpdateQuery _v877))) $ getJobUpdateSummaries_args_jobUpdateQuery record
  ]
write_GetJobUpdateSummaries_args :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateSummaries_args -> P.IO ()
write_GetJobUpdateSummaries_args oprot record = T.writeVal oprot $ from_GetJobUpdateSummaries_args record
encode_GetJobUpdateSummaries_args :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateSummaries_args -> LBS.ByteString
encode_GetJobUpdateSummaries_args oprot record = T.serializeVal oprot $ from_GetJobUpdateSummaries_args record
to_GetJobUpdateSummaries_args :: T.ThriftVal -> GetJobUpdateSummaries_args
to_GetJobUpdateSummaries_args (T.TStruct fields) = GetJobUpdateSummaries_args{
  getJobUpdateSummaries_args_jobUpdateQuery = P.maybe (getJobUpdateSummaries_args_jobUpdateQuery default_GetJobUpdateSummaries_args) (\(_,_val879) -> (case _val879 of {T.TStruct _val880 -> (to_JobUpdateQuery (T.TStruct _val880)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobUpdateSummaries_args _ = P.error "not a struct"
read_GetJobUpdateSummaries_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobUpdateSummaries_args
read_GetJobUpdateSummaries_args iprot = to_GetJobUpdateSummaries_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJobUpdateSummaries_args)
decode_GetJobUpdateSummaries_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobUpdateSummaries_args
decode_GetJobUpdateSummaries_args iprot bs = to_GetJobUpdateSummaries_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobUpdateSummaries_args) bs
typemap_GetJobUpdateSummaries_args :: T.TypeMap
typemap_GetJobUpdateSummaries_args = Map.fromList [(1,("jobUpdateQuery",(T.T_STRUCT typemap_JobUpdateQuery)))]
default_GetJobUpdateSummaries_args :: GetJobUpdateSummaries_args
default_GetJobUpdateSummaries_args = GetJobUpdateSummaries_args{
  getJobUpdateSummaries_args_jobUpdateQuery = default_JobUpdateQuery}
data GetJobUpdateSummaries_result = GetJobUpdateSummaries_result  { getJobUpdateSummaries_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobUpdateSummaries_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobUpdateSummaries_result_success record  
instance QC.Arbitrary GetJobUpdateSummaries_result where 
  arbitrary = M.liftM GetJobUpdateSummaries_result (QC.arbitrary)
  shrink obj | obj == default_GetJobUpdateSummaries_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobUpdateSummaries_result{getJobUpdateSummaries_result_success = getJobUpdateSummaries_result_success obj} then P.Nothing else P.Just $ default_GetJobUpdateSummaries_result{getJobUpdateSummaries_result_success = getJobUpdateSummaries_result_success obj}
    ]
from_GetJobUpdateSummaries_result :: GetJobUpdateSummaries_result -> T.ThriftVal
from_GetJobUpdateSummaries_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v883 -> P.Just (0, ("success",from_Response _v883))) $ getJobUpdateSummaries_result_success record
  ]
write_GetJobUpdateSummaries_result :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateSummaries_result -> P.IO ()
write_GetJobUpdateSummaries_result oprot record = T.writeVal oprot $ from_GetJobUpdateSummaries_result record
encode_GetJobUpdateSummaries_result :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateSummaries_result -> LBS.ByteString
encode_GetJobUpdateSummaries_result oprot record = T.serializeVal oprot $ from_GetJobUpdateSummaries_result record
to_GetJobUpdateSummaries_result :: T.ThriftVal -> GetJobUpdateSummaries_result
to_GetJobUpdateSummaries_result (T.TStruct fields) = GetJobUpdateSummaries_result{
  getJobUpdateSummaries_result_success = P.maybe (getJobUpdateSummaries_result_success default_GetJobUpdateSummaries_result) (\(_,_val885) -> (case _val885 of {T.TStruct _val886 -> (to_Response (T.TStruct _val886)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetJobUpdateSummaries_result _ = P.error "not a struct"
read_GetJobUpdateSummaries_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobUpdateSummaries_result
read_GetJobUpdateSummaries_result iprot = to_GetJobUpdateSummaries_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJobUpdateSummaries_result)
decode_GetJobUpdateSummaries_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobUpdateSummaries_result
decode_GetJobUpdateSummaries_result iprot bs = to_GetJobUpdateSummaries_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobUpdateSummaries_result) bs
typemap_GetJobUpdateSummaries_result :: T.TypeMap
typemap_GetJobUpdateSummaries_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetJobUpdateSummaries_result :: GetJobUpdateSummaries_result
default_GetJobUpdateSummaries_result = GetJobUpdateSummaries_result{
  getJobUpdateSummaries_result_success = default_Response}
data GetJobUpdateDetails_args = GetJobUpdateDetails_args  { getJobUpdateDetails_args_updateId :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobUpdateDetails_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobUpdateDetails_args_updateId record  
instance QC.Arbitrary GetJobUpdateDetails_args where 
  arbitrary = M.liftM GetJobUpdateDetails_args (QC.arbitrary)
  shrink obj | obj == default_GetJobUpdateDetails_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobUpdateDetails_args{getJobUpdateDetails_args_updateId = getJobUpdateDetails_args_updateId obj} then P.Nothing else P.Just $ default_GetJobUpdateDetails_args{getJobUpdateDetails_args_updateId = getJobUpdateDetails_args_updateId obj}
    ]
from_GetJobUpdateDetails_args :: GetJobUpdateDetails_args -> T.ThriftVal
from_GetJobUpdateDetails_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v889 -> P.Just (1, ("updateId",T.TString $ E.encodeUtf8 _v889))) $ getJobUpdateDetails_args_updateId record
  ]
write_GetJobUpdateDetails_args :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateDetails_args -> P.IO ()
write_GetJobUpdateDetails_args oprot record = T.writeVal oprot $ from_GetJobUpdateDetails_args record
encode_GetJobUpdateDetails_args :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateDetails_args -> LBS.ByteString
encode_GetJobUpdateDetails_args oprot record = T.serializeVal oprot $ from_GetJobUpdateDetails_args record
to_GetJobUpdateDetails_args :: T.ThriftVal -> GetJobUpdateDetails_args
to_GetJobUpdateDetails_args (T.TStruct fields) = GetJobUpdateDetails_args{
  getJobUpdateDetails_args_updateId = P.maybe (getJobUpdateDetails_args_updateId default_GetJobUpdateDetails_args) (\(_,_val891) -> (case _val891 of {T.TString _val892 -> E.decodeUtf8 _val892; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJobUpdateDetails_args _ = P.error "not a struct"
read_GetJobUpdateDetails_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobUpdateDetails_args
read_GetJobUpdateDetails_args iprot = to_GetJobUpdateDetails_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJobUpdateDetails_args)
decode_GetJobUpdateDetails_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobUpdateDetails_args
decode_GetJobUpdateDetails_args iprot bs = to_GetJobUpdateDetails_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobUpdateDetails_args) bs
typemap_GetJobUpdateDetails_args :: T.TypeMap
typemap_GetJobUpdateDetails_args = Map.fromList [(1,("updateId",T.T_STRING))]
default_GetJobUpdateDetails_args :: GetJobUpdateDetails_args
default_GetJobUpdateDetails_args = GetJobUpdateDetails_args{
  getJobUpdateDetails_args_updateId = ""}
data GetJobUpdateDetails_result = GetJobUpdateDetails_result  { getJobUpdateDetails_result_success :: Response
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetJobUpdateDetails_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJobUpdateDetails_result_success record  
instance QC.Arbitrary GetJobUpdateDetails_result where 
  arbitrary = M.liftM GetJobUpdateDetails_result (QC.arbitrary)
  shrink obj | obj == default_GetJobUpdateDetails_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJobUpdateDetails_result{getJobUpdateDetails_result_success = getJobUpdateDetails_result_success obj} then P.Nothing else P.Just $ default_GetJobUpdateDetails_result{getJobUpdateDetails_result_success = getJobUpdateDetails_result_success obj}
    ]
from_GetJobUpdateDetails_result :: GetJobUpdateDetails_result -> T.ThriftVal
from_GetJobUpdateDetails_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v895 -> P.Just (0, ("success",from_Response _v895))) $ getJobUpdateDetails_result_success record
  ]
write_GetJobUpdateDetails_result :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateDetails_result -> P.IO ()
write_GetJobUpdateDetails_result oprot record = T.writeVal oprot $ from_GetJobUpdateDetails_result record
encode_GetJobUpdateDetails_result :: (T.Protocol p, T.Transport t) => p t -> GetJobUpdateDetails_result -> LBS.ByteString
encode_GetJobUpdateDetails_result oprot record = T.serializeVal oprot $ from_GetJobUpdateDetails_result record
to_GetJobUpdateDetails_result :: T.ThriftVal -> GetJobUpdateDetails_result
to_GetJobUpdateDetails_result (T.TStruct fields) = GetJobUpdateDetails_result{
  getJobUpdateDetails_result_success = P.maybe (getJobUpdateDetails_result_success default_GetJobUpdateDetails_result) (\(_,_val897) -> (case _val897 of {T.TStruct _val898 -> (to_Response (T.TStruct _val898)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetJobUpdateDetails_result _ = P.error "not a struct"
read_GetJobUpdateDetails_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetJobUpdateDetails_result
read_GetJobUpdateDetails_result iprot = to_GetJobUpdateDetails_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJobUpdateDetails_result)
decode_GetJobUpdateDetails_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetJobUpdateDetails_result
decode_GetJobUpdateDetails_result iprot bs = to_GetJobUpdateDetails_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJobUpdateDetails_result) bs
typemap_GetJobUpdateDetails_result :: T.TypeMap
typemap_GetJobUpdateDetails_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Response)))]
default_GetJobUpdateDetails_result :: GetJobUpdateDetails_result
default_GetJobUpdateDetails_result = GetJobUpdateDetails_result{
  getJobUpdateDetails_result_success = default_Response}
process_getRoleSummary (seqid, iprot, oprot, handler) = do
  args <- read_GetRoleSummary_args iprot
  (X.catch
    (do
      val <- Iface.getRoleSummary handler
      let res = default_GetRoleSummary_result{getRoleSummary_result_success = val}
      T.writeMessageBegin oprot ("getRoleSummary", T.M_REPLY, seqid)
      write_GetRoleSummary_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getRoleSummary", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getJobSummary (seqid, iprot, oprot, handler) = do
  args <- read_GetJobSummary_args iprot
  (X.catch
    (do
      val <- Iface.getJobSummary handler (getJobSummary_args_role args)
      let res = default_GetJobSummary_result{getJobSummary_result_success = val}
      T.writeMessageBegin oprot ("getJobSummary", T.M_REPLY, seqid)
      write_GetJobSummary_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getJobSummary", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getTasksStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetTasksStatus_args iprot
  (X.catch
    (do
      val <- Iface.getTasksStatus handler (getTasksStatus_args_query args)
      let res = default_GetTasksStatus_result{getTasksStatus_result_success = val}
      T.writeMessageBegin oprot ("getTasksStatus", T.M_REPLY, seqid)
      write_GetTasksStatus_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getTasksStatus", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getTasksWithoutConfigs (seqid, iprot, oprot, handler) = do
  args <- read_GetTasksWithoutConfigs_args iprot
  (X.catch
    (do
      val <- Iface.getTasksWithoutConfigs handler (getTasksWithoutConfigs_args_query args)
      let res = default_GetTasksWithoutConfigs_result{getTasksWithoutConfigs_result_success = val}
      T.writeMessageBegin oprot ("getTasksWithoutConfigs", T.M_REPLY, seqid)
      write_GetTasksWithoutConfigs_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getTasksWithoutConfigs", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getPendingReason (seqid, iprot, oprot, handler) = do
  args <- read_GetPendingReason_args iprot
  (X.catch
    (do
      val <- Iface.getPendingReason handler (getPendingReason_args_query args)
      let res = default_GetPendingReason_result{getPendingReason_result_success = val}
      T.writeMessageBegin oprot ("getPendingReason", T.M_REPLY, seqid)
      write_GetPendingReason_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getPendingReason", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getConfigSummary (seqid, iprot, oprot, handler) = do
  args <- read_GetConfigSummary_args iprot
  (X.catch
    (do
      val <- Iface.getConfigSummary handler (getConfigSummary_args_job args)
      let res = default_GetConfigSummary_result{getConfigSummary_result_success = val}
      T.writeMessageBegin oprot ("getConfigSummary", T.M_REPLY, seqid)
      write_GetConfigSummary_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getConfigSummary", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getJobs (seqid, iprot, oprot, handler) = do
  args <- read_GetJobs_args iprot
  (X.catch
    (do
      val <- Iface.getJobs handler (getJobs_args_ownerRole args)
      let res = default_GetJobs_result{getJobs_result_success = val}
      T.writeMessageBegin oprot ("getJobs", T.M_REPLY, seqid)
      write_GetJobs_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getJobs", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getQuota (seqid, iprot, oprot, handler) = do
  args <- read_GetQuota_args iprot
  (X.catch
    (do
      val <- Iface.getQuota handler (getQuota_args_ownerRole args)
      let res = default_GetQuota_result{getQuota_result_success = val}
      T.writeMessageBegin oprot ("getQuota", T.M_REPLY, seqid)
      write_GetQuota_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getQuota", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_populateJobConfig (seqid, iprot, oprot, handler) = do
  args <- read_PopulateJobConfig_args iprot
  (X.catch
    (do
      val <- Iface.populateJobConfig handler (populateJobConfig_args_description args)
      let res = default_PopulateJobConfig_result{populateJobConfig_result_success = val}
      T.writeMessageBegin oprot ("populateJobConfig", T.M_REPLY, seqid)
      write_PopulateJobConfig_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("populateJobConfig", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getLocks (seqid, iprot, oprot, handler) = do
  args <- read_GetLocks_args iprot
  (X.catch
    (do
      val <- Iface.getLocks handler
      let res = default_GetLocks_result{getLocks_result_success = val}
      T.writeMessageBegin oprot ("getLocks", T.M_REPLY, seqid)
      write_GetLocks_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getLocks", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getJobUpdateSummaries (seqid, iprot, oprot, handler) = do
  args <- read_GetJobUpdateSummaries_args iprot
  (X.catch
    (do
      val <- Iface.getJobUpdateSummaries handler (getJobUpdateSummaries_args_jobUpdateQuery args)
      let res = default_GetJobUpdateSummaries_result{getJobUpdateSummaries_result_success = val}
      T.writeMessageBegin oprot ("getJobUpdateSummaries", T.M_REPLY, seqid)
      write_GetJobUpdateSummaries_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getJobUpdateSummaries", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getJobUpdateDetails (seqid, iprot, oprot, handler) = do
  args <- read_GetJobUpdateDetails_args iprot
  (X.catch
    (do
      val <- Iface.getJobUpdateDetails handler (getJobUpdateDetails_args_updateId args)
      let res = default_GetJobUpdateDetails_result{getJobUpdateDetails_result_success = val}
      T.writeMessageBegin oprot ("getJobUpdateDetails", T.M_REPLY, seqid)
      write_GetJobUpdateDetails_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getJobUpdateDetails", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getRoleSummary" -> process_getRoleSummary (seqid,iprot,oprot,handler)
  "getJobSummary" -> process_getJobSummary (seqid,iprot,oprot,handler)
  "getTasksStatus" -> process_getTasksStatus (seqid,iprot,oprot,handler)
  "getTasksWithoutConfigs" -> process_getTasksWithoutConfigs (seqid,iprot,oprot,handler)
  "getPendingReason" -> process_getPendingReason (seqid,iprot,oprot,handler)
  "getConfigSummary" -> process_getConfigSummary (seqid,iprot,oprot,handler)
  "getJobs" -> process_getJobs (seqid,iprot,oprot,handler)
  "getQuota" -> process_getQuota (seqid,iprot,oprot,handler)
  "populateJobConfig" -> process_populateJobConfig (seqid,iprot,oprot,handler)
  "getLocks" -> process_getLocks (seqid,iprot,oprot,handler)
  "getJobUpdateSummaries" -> process_getJobUpdateSummaries (seqid,iprot,oprot,handler)
  "getJobUpdateDetails" -> process_getJobUpdateDetails (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
